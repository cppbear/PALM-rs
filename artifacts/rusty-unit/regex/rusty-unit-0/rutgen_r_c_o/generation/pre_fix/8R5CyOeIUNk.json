{
  "name": "regex_syntax::ast::visitor::ast::visitor::HeapVisitor<'a>::induct",
  "name_with_impl": "regex_syntax::ast::visitor::{impl#0}::induct",
  "mod_info": {
    "name": "ast::visitor",
    "loc": "regex-syntax/src/ast/mod.rs:23:1:23:13"
  },
  "visible": false,
  "loc": "regex-syntax/src/ast/visitor.rs:271:5:299:6",
  "fn_tests": [
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(ref x) or Ast::Concat(ref x) is true\n",
        "// constraint: *ast matches Ast::Concat(ref x) is true\n",
        "// constraint: x.asts.is_empty() is true\n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "Ast::Concat(ref x) with x.asts being empty; Ast::Alternation(ref x) with x.asts being empty; Ast::Repetition(ref x); Ast::Group(ref x) with no children.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });",
                "    let mut visitor = DummyVisitor {};",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    let result = visitor_instance.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });",
                  "    assert_eq!(result, Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });",
                  "    assert_eq!(result, Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:27\n    |\n565 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:27\n    |\n569 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:42\n    |\n569 |     let ast = Ast::Concat(Concat { span: Span::default(), asts: Vec::new() });\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n570 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n570 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                "    let mut visitor = DummyVisitor {};",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    let result = visitor_instance.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:52\n    |\n565 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:32\n    |\n569 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:52\n    |\n569 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:52\n    |\n565 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:32\n    |\n569 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:52\n    |\n569 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: Vec::new() });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::default())) });",
                "    let mut visitor = DummyVisitor {};",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    let result = visitor_instance.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    assert_eq!(result, Ok(Some(Frame::Repetition(&ast.repetition()))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    assert_eq!(result, Ok(Some(Frame::Repetition(&ast.repetition()))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:31\n    |\n565 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Litera...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:50\n    |\n565 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Litera...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:565:71\n    |\n565 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Litera...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:132\n    |\n565 | ...Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:31\n    |\n569 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Litera...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:50\n    |\n569 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Litera...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:569:71\n    |\n569 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Litera...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:132\n    |\n569 | ...Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `repetition` found for enum `ast::Ast` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:570:55\n    |\n570 |     assert_eq!(result, Ok(Some(Frame::Repetition(&ast.repetition()))));\n    |                                                       ^^^^^^^^^^ method not found in `ast::Ast`\n    |\n   ::: regex-syntax/src/ast/mod.rs:478:1\n    |\n478 | pub enum Ast {\n    | ------------ method `repetition` not found for this enum\n    |\nhelp: there is a variant with a similar name\n    |\n570 |     assert_eq!(result, Ok(Some(Frame::Repetition(&ast.Repetition()))));\n    |                                                       ~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n570 |     assert_eq!(result, Ok(Some(Frame::Repetition(&ast.repetition()))));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:570:5\n    |\n570 |     assert_eq!(result, Ok(Some(Frame::Repetition(&ast.repetition()))));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                "    let mut visitor = DummyVisitor {};",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    let result = visitor_instance.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:26\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:565:63\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:109\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:26\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:569:63\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:109\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:26\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:565:40\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:565:63\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:109\n    |\n565 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:23\n    |\n566 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:26\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:40\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:569:63\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:109\n    |\n569 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Normal, ast: Box::new(Ast::Literal(Literal::default())) });\n    |                                                                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(ref x) or Ast::Concat(ref x) is true\n",
        "// constraint: *ast matches Ast::Concat(ref x) is true\n",
        "// constraint: x.asts.is_empty() is false\n",
        "// constraint: *ast matches Ast::Concat(ref x) is true\n",
        "// constraint: x.asts[0] is \n",
        "// constraint: x.asts[1..] is \n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "*ast = Ast::Concat(ref Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" })] })\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span { start: 0, end: 10 },",
                "        asts: vec![",
                "            Ast::Literal(Literal { value: \"a\" }),",
                "            Ast::Literal(Literal { value: \"b\" }),",
                "        ],",
                "    });",
                "",
                "    let mut visitor = DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..], })));"
                ],
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert!(match result { Ok(Some(Frame::Concat { head, tail })) => head == &ast.asts[0] && tail == &ast.asts[1..], _ => false });"
                ],
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert_eq!(ast.asts.len(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 10 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"a\" }),",
                  "            Ast::Literal(Literal { value: \"b\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..], })));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 10 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"a\" }),",
                  "            Ast::Literal(Literal { value: \"b\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 10 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"a\" }),",
                  "            Ast::Literal(Literal { value: \"b\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert!(match result { Ok(Some(Frame::Concat { head, tail })) => head == &ast.asts[0] && tail == &ast.asts[1..], _ => false });",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 10 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"a\" }),",
                  "            Ast::Literal(Literal { value: \"b\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });",
                  "    assert_eq!(ast.asts.len(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"a\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"b\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:27\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:94\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:132\n    |\n583 | ...Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:584:59\n    |\n584 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..], })));\n    |                                                           ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:584:79\n    |\n584 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..], })));\n    |                                                                               ^^^^ unknown field\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, ()>`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..], })));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, ()>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, ()>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..], })));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, ()>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"a\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"b\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:27\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:94\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:132\n    |\n583 | ...Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"a\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"b\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:27\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:94\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:132\n    |\n583 | ...Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:584:83\n    |\n584 |     assert!(match result { Ok(Some(Frame::Concat { head, tail })) => head == &ast.asts[0] && tail == &ast.asts[1..], _ => false });\n    |                                                                                   ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:584:107\n    |\n584 |     assert!(match result { Ok(Some(Frame::Concat { head, tail })) => head == &ast.asts[0] && tail == &ast.asts[1..], _ => false });\n    |                                                                                                           ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"a\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"b\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:27\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:42\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:94\n    |\n583 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 10 }, asts: vec![Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Litera...\n    |                                                                                              ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:132\n    |\n583 | ...Ast::Literal(Literal { value: \"a\" }), Ast::Literal(Literal { value: \"b\" }),], });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:584:20\n    |\n584 |     assert_eq!(ast.asts.len(), 2);\n    |                    ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span { start: 0, end: 15 },",
                "        asts: vec![",
                "            Ast::Literal(Literal { value: \"x\" }),",
                "            Ast::Literal(Literal { value: \"y\" }),",
                "            Ast::Literal(Literal { value: \"z\" }),",
                "        ],",
                "    });",
                "",
                "    let mut visitor = DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] })));"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(matches!(result, Ok(Some(Frame::Concat { .. }))));"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(ast.asts.len(), 3);"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_ne!(ast.asts[0], ast.asts[1]);"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_ne!(ast.asts[1], ast.asts[2]);"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(ast.asts[0] == Ast::Literal(Literal { value: \"x\" }));"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(ast.asts[1] == Ast::Literal(Literal { value: \"y\" }));"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(ast.asts[2] == Ast::Literal(Literal { value: \"z\" }));"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(result.is_some());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] })));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(matches!(result, Ok(Some(Frame::Concat { .. }))));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(ast.asts.len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_ne!(ast.asts[0], ast.asts[1]);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert_ne!(ast.asts[1], ast.asts[2]);",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(ast.asts[0] == Ast::Literal(Literal { value: \"x\" }));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(ast.asts[1] == Ast::Literal(Literal { value: \"y\" }));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(ast.asts[2] == Ast::Literal(Literal { value: \"z\" }));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 15 },",
                  "        asts: vec![",
                  "            Ast::Literal(Literal { value: \"x\" }),",
                  "            Ast::Literal(Literal { value: \"y\" }),",
                  "            Ast::Literal(Literal { value: \"z\" }),",
                  "        ],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span { start: 0, end: 15 },",
                  "    asts: vec![",
                  "    Ast::Literal(Literal { value: \"x\" }),",
                  "    Ast::Literal(Literal { value: \"y\" }),",
                  "    Ast::Literal(Literal { value: \"z\" }),",
                  "    ],",
                  "    });",
                  "    assert!(result.is_some());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:59\n    |\n592 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] })));\n    |                                                           ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:79\n    |\n592 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] })));\n    |                                                                               ^^^^ unknown field\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, ()>`\n   --> regex-syntax/src/ast/visitor.rs:592:5\n    |\n592 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] })));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, ()>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, ()>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:592:5\n    |\n592 |     assert_eq!(result, Ok(Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] })));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, ()>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:20\n    |\n592 |     assert_eq!(ast.asts.len(), 3);\n    |                    ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:20\n    |\n592 |     assert_ne!(ast.asts[0], ast.asts[1]);\n    |                    ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:33\n    |\n592 |     assert_ne!(ast.asts[0], ast.asts[1]);\n    |                                 ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:20\n    |\n592 |     assert_ne!(ast.asts[1], ast.asts[2]);\n    |                    ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:33\n    |\n592 |     assert_ne!(ast.asts[1], ast.asts[2]);\n    |                                 ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:41\n    |\n592 |     assert!(ast.asts[0] == Ast::Literal(Literal { value: \"x\" }));\n    |                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:17\n    |\n592 |     assert!(ast.asts[0] == Ast::Literal(Literal { value: \"x\" }));\n    |                 ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:41\n    |\n592 |     assert!(ast.asts[1] == Ast::Literal(Literal { value: \"y\" }));\n    |                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:17\n    |\n592 |     assert!(ast.asts[1] == Ast::Literal(Literal { value: \"y\" }));\n    |                 ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:41\n    |\n592 |     assert!(ast.asts[2] == Ast::Literal(Literal { value: \"z\" }));\n    |                                         ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:592:17\n    |\n592 |     assert!(ast.asts[2] == Ast::Literal(Literal { value: \"z\" }));\n    |                 ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 15 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |             Ast::Literal(Literal { value: \"x\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:26\n    |\n575 |             Ast::Literal(Literal { value: \"y\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:26\n    |\n576 |             Ast::Literal(Literal { value: \"z\" }),\n    |                          ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:27\n    |\n584 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span { start: 0, end: 15 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:18\n    |\n587 |     Ast::Literal(Literal { value: \"x\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:588:18\n    |\n588 |     Ast::Literal(Literal { value: \"y\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:589:18\n    |\n589 |     Ast::Literal(Literal { value: \"z\" }),\n    |                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0599]: no method named `is_some` found for enum `std::result::Result` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:592:20\n    |\n592 |     assert!(result.is_some());\n    |                    ^^^^^^^\n    |\nnote: the method `is_some` exists on the type `Option<ast::visitor::Frame<'_>>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/option.rs:609:5\nhelp: consider using `Result::expect` to unwrap the `Option<ast::visitor::Frame<'_>>` value, panicking if the value is a `Result::Err`\n    |\n592 |     assert!(result.expect(\"REASON\").is_some());\n    |                   +++++++++++++++++\nhelp: there is a method `is_ok` with a similar name\n    |\n592 |     assert!(result.is_ok());\n    |                    ~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct DummyVisitor;",
                "    impl Visitor for DummyVisitor {",
                "        type Output = ();",
                "        type Err = ();",
                "    }",
                "",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span { start: 0, end: 5 },",
                "        asts: vec![Ast::Literal(Literal { value: \"c\" })],",
                "    });",
                "",
                "    let mut visitor = DummyVisitor;",
                "    let mut heap_visitor = HeapVisitor::new();",
                "",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });",
                  "    let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });",
                  "    assert_eq!(result, Ok(expected));"
                ],
                [
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });",
                  "    let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });",
                  "    assert_eq!(heap_visitor.stack.len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 5 },",
                  "        asts: vec![Ast::Literal(Literal { value: \"c\" })],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });",
                  "    let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });",
                  "    assert_eq!(result, Ok(expected));",
                  "}"
                ],
                [
                  "{",
                  "    struct DummyVisitor;",
                  "    impl Visitor for DummyVisitor {",
                  "        type Output = ();",
                  "        type Err = ();",
                  "    }",
                  "",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span { start: 0, end: 5 },",
                  "        asts: vec![Ast::Literal(Literal { value: \"c\" })],",
                  "    });",
                  "",
                  "    let mut visitor = DummyVisitor;",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });",
                  "    let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });",
                  "    assert_eq!(heap_visitor.stack.len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:33\n    |\n573 |         asts: vec![Ast::Literal(Literal { value: \"c\" })],\n    |                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:42\n    |\n580 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:93\n    |\n580 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });\n    |                                                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:581:52\n    |\n581 |     let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });\n    |                                                    ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:581:72\n    |\n581 |     let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });\n    |                                                                        ^^^^ unknown field\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, ()>`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     assert_eq!(result, Ok(expected));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, ()>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, ()>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     assert_eq!(result, Ok(expected));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, ()>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0369, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:27\n    |\n571 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span { start: 0, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:33\n    |\n573 |         asts: vec![Ast::Literal(Literal { value: \"c\" })],\n    |                                 ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:27\n    |\n580 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:42\n    |\n580 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });\n    |                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:93\n    |\n580 |     let ast = Ast::Concat(Concat { span: Span { start: 0, end: 5 }, asts: vec![Ast::Literal(Literal { value: \"c\" })] });\n    |                                                                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `finish`\n   --> regex-syntax/src/ast/visitor.rs:566:5\n    |\n41  |     fn finish(self) -> Result<Self::Output, Self::Err>;\n    |     --------------------------------------------------- `finish` from trait\n...\n566 |     impl Visitor for DummyVisitor {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `finish` in implementation\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:581:52\n    |\n581 |     let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });\n    |                                                    ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:581:72\n    |\n581 |     let expected = Some(Frame::Concat { head: &ast.asts[0], tail: &ast.asts[1..] });\n    |                                                                        ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0422, E0432, E0609.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(ref x) or Ast::Alternation(ref x) is true\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n",
        "// constraint: x.asts.is_empty() is true\n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "*ast = Alternation with x.asts = [] (empty); *ast = Alternation with x.asts = [OneAst, TwoAst, ... , NthAst] (where 1  N  max allowed); ast must be of type Ast.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let alternation = ast::Alternation {",
                "        span: Span::new(0, 0),",
                "        asts: Vec::new(),",
                "    };",
                "    let ast = Ast::Alternation(alternation);",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let alternation = ast::Alternation { span: Span::new(0, 0), asts: Vec::new() };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 0),",
                  "        asts: Vec::new(),",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let alternation = ast::Alternation { span: Span::new(0, 0), asts: Vec::new() };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:48\n    |\n573 |     let alternation = ast::Alternation { span: Span::new(0, 0), asts: Vec::new() };\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n578 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:578:5\n    |\n578 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let first_ast = Ast::Literal(Literal::from('a'));",
                "    let alternation = ast::Alternation {",
                "        span: Span::new(0, 1),",
                "        asts: vec![first_ast],",
                "    };",
                "    let ast = Ast::Alternation(alternation);",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 1),",
                  "    asts: vec![first_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 1),",
                  "    asts: vec![first_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 1),",
                  "        asts: vec![first_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 1),",
                  "    asts: vec![first_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 1),",
                  "        asts: vec![first_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 1),",
                  "    asts: vec![first_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:34\n    |\n565 |     let first_ast = Ast::Literal(Literal::from('a'));\n    |                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:34\n    |\n574 |     let first_ast = Ast::Literal(Literal::from('a'));\n    |                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:34\n    |\n565 |     let first_ast = Ast::Literal(Literal::from('a'));\n    |                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:34\n    |\n574 |     let first_ast = Ast::Literal(Literal::from('a'));\n    |                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     assert_eq!(result.unwrap(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     assert_eq!(result.unwrap(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let first_ast = Ast::Literal(Literal::from('a'));",
                "    let second_ast = Ast::Literal(Literal::from('b'));",
                "    let alternation = ast::Alternation {",
                "        span: Span::new(0, 2),",
                "        asts: vec![first_ast, second_ast],",
                "    };",
                "    let ast = Ast::Alternation(alternation);",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let second_ast = Ast::Literal(Literal::from('b'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![first_ast.clone(), second_ast.clone()],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let second_ast = Ast::Literal(Literal::from('b'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![first_ast.clone(), second_ast.clone()],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), Some(Frame::Alternation {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let second_ast = Ast::Literal(Literal::from('b'));",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![first_ast, second_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let second_ast = Ast::Literal(Literal::from('b'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![first_ast.clone(), second_ast.clone()],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let second_ast = Ast::Literal(Literal::from('b'));",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![first_ast, second_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let first_ast = Ast::Literal(Literal::from('a'));",
                  "    let second_ast = Ast::Literal(Literal::from('b'));",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![first_ast.clone(), second_ast.clone()],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), Some(Frame::Alternation {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:34\n    |\n565 |     let first_ast = Ast::Literal(Literal::from('a'));\n    |                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:35\n    |\n566 |     let second_ast = Ast::Literal(Literal::from('b'));\n    |                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:575:34\n    |\n575 |     let first_ast = Ast::Literal(Literal::from('a'));\n    |                                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:576:35\n    |\n576 |     let second_ast = Ast::Literal(Literal::from('b'));\n    |                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:578:11\n    |\n578 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:582:23\n    |\n582 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:585:37\n    |\n564 | {\n    | - closing delimiter possibly meant for this\n...\n585 |     assert_eq!(result.unwrap(), Some(Frame::Alternation {\n    |                                     ^ unclosed delimiter\n586 | }\n587 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:587:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n587 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                "    let alternation = ast::Alternation {",
                "        span: Span::new(0, 10),",
                "        asts,",
                "    };",
                "    let ast = Ast::Alternation(alternation);",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 10),",
                  "    asts,",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 10),",
                  "    asts,",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let frame = result.unwrap();",
                  "    assert!(frame.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 10),",
                  "        asts,",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 10),",
                  "    asts,",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 10),",
                  "        asts,",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();",
                  "    let alternation = ast::Alternation {",
                  "    span: Span::new(0, 10),",
                  "    asts,",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let frame = result.unwrap();",
                  "    assert!(frame.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:55\n    |\n565 |     let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();\n    |                                                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:55\n    |\n574 |     let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();\n    |                                                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:565:55\n    |\n565 |     let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();\n    |                                                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 10),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:574:55\n    |\n574 |     let asts: Vec<Ast> = (0..10).map(|i| Ast::Literal(Literal::from((b'a' + i) as char))).collect();\n    |                                                       ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::new(0, 10),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let repetition_ast = Ast::Repetition(Repetition {",
                "        span: Span::new(0, 3),",
                "        op: RepetitionOp::Plus,",
                "        greedy: true,",
                "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                "    });",
                "    let alternation = ast::Alternation {",
                "        span: Span::new(0, 4),",
                "        asts: vec![repetition_ast],",
                "    };",
                "    let ast = Ast::Alternation(alternation);",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::from('a'))), });",
                  "    let alternation = ast::Alternation { span: Span::new(0, 4), asts: vec![repetition_ast], };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::from('a'))), });",
                  "    let alternation = ast::Alternation { span: Span::new(0, 4), asts: vec![repetition_ast], };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), Some(Frame::Alternation { head: &ast.asts[0], tail: &[] }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let repetition_ast = Ast::Repetition(Repetition {",
                  "        span: Span::new(0, 3),",
                  "        op: RepetitionOp::Plus,",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 4),",
                  "        asts: vec![repetition_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::from('a'))), });",
                  "    let alternation = ast::Alternation { span: Span::new(0, 4), asts: vec![repetition_ast], };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let repetition_ast = Ast::Repetition(Repetition {",
                  "        span: Span::new(0, 3),",
                  "        op: RepetitionOp::Plus,",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::new(0, 4),",
                  "        asts: vec![repetition_ast],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::from('a'))), });",
                  "    let alternation = ast::Alternation { span: Span::new(0, 4), asts: vec![repetition_ast], };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), Some(Frame::Alternation { head: &ast.asts[0], tail: &[] }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let repetition_ast = Ast::Repetition(Repetition {\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:567:13\n    |\n567 |         op: RepetitionOp::Plus,\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span::new(0, 4),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Lit...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:61\n    |\n579 |     let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Lit...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:579:82\n    |\n579 |     let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Lit...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:143\n    |\n579 | ...Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::from('a'))), });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:48\n    |\n580 |     let alternation = ast::Alternation { span: Span::new(0, 4), asts: vec![repetition_ast], };\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:582:23\n    |\n582 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:42\n    |\n565 |     let repetition_ast = Ast::Repetition(Repetition {\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:567:13\n    |\n567 |         op: RepetitionOp::Plus,\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         span: Span::new(0, 4),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:42\n    |\n579 |     let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Lit...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:61\n    |\n579 |     let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Lit...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:579:82\n    |\n579 |     let repetition_ast = Ast::Repetition(Repetition { span: Span::new(0, 3), op: RepetitionOp::Plus, greedy: true, ast: Box::new(Ast::Lit...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:143\n    |\n579 | ...Plus, greedy: true, ast: Box::new(Ast::Literal(Literal::from('a'))), });\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:48\n    |\n580 |     let alternation = ast::Alternation { span: Span::new(0, 4), asts: vec![repetition_ast], };\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:582:23\n    |\n582 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:585:70\n    |\n585 |     assert_eq!(result.unwrap(), Some(Frame::Alternation { head: &ast.asts[0], tail: &[] }));\n    |                                                                      ^^^^ unknown field\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:585:5\n    |\n585 |     assert_eq!(result.unwrap(), Some(Frame::Alternation { head: &ast.asts[0], tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:585:5\n    |\n585 |     assert_eq!(result.unwrap(), Some(Frame::Alternation { head: &ast.asts[0], tail: &[] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(ref x) or Ast::Alternation(ref x) is true\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n",
        "// constraint: x.asts.is_empty() is false\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is true\n",
        "// constraint: x.asts[0] is \n",
        "// constraint: x.asts[1..] is \n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "Ast::Alternation(ref x) with x.asts length [2, 10] and each x.asts[i] as valid Ast variants.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Literal(Literal::default()),",
                "            Ast::Group(Group {",
                "                span: Span::default(),",
                "                kind: GroupKind::default(),",
                "                ast: Box::new(Ast::Empty(Span::default())),",
                "            }),",
                "        ],",
                "    });",
                "    let mut visitor = MyVisitor::new();",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert!(matches!(visitor_instance.induct(&ast, &mut visitor), Ok(Some(Frame::Alternation { head, tail }))));"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(head, &ast.asts[0]);"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(tail, &ast.asts[1..]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::default()),",
                  "            Ast::Group(Group {",
                  "                span: Span::default(),",
                  "                kind: GroupKind::default(),",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert!(matches!(visitor_instance.induct(&ast, &mut visitor), Ok(Some(Frame::Alternation { head, tail }))));",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::default()),",
                  "            Ast::Group(Group {",
                  "                span: Span::default(),",
                  "                kind: GroupKind::default(),",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(head, &ast.asts[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::default()),",
                  "            Ast::Group(Group {",
                  "                span: Span::default(),",
                  "                kind: GroupKind::default(),",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::default()),",
                  "    Ast::Group(Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    assert_eq!(tail, &ast.asts[1..]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:26\n    |\n568 |             Ast::Literal(Literal::default()),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Group(Group {\n    |                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 kind: GroupKind::default(),\n    |                       ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:42\n    |\n572 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:32\n    |\n579 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n582 |     Ast::Literal(Literal::default()),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     Ast::Group(Group {\n    |                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:30\n    |\n586 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:26\n    |\n568 |             Ast::Literal(Literal::default()),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Group(Group {\n    |                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 kind: GroupKind::default(),\n    |                       ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:42\n    |\n572 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:32\n    |\n579 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n582 |     Ast::Literal(Literal::default()),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     Ast::Group(Group {\n    |                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:30\n    |\n586 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `head` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:16\n    |\n590 |     assert_eq!(head, &ast.asts[0]);\n    |                ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:590:27\n    |\n590 |     assert_eq!(head, &ast.asts[0]);\n    |                           ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:26\n    |\n568 |             Ast::Literal(Literal::default()),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Group(Group {\n    |                        ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 kind: GroupKind::default(),\n    |                       ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:572:42\n    |\n572 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:32\n    |\n579 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:18\n    |\n582 |     Ast::Literal(Literal::default()),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:16\n    |\n583 |     Ast::Group(Group {\n    |                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:586:30\n    |\n586 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `tail` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:16\n    |\n590 |     assert_eq!(tail, &ast.asts[1..]);\n    |                ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:590:27\n    |\n590 |     assert_eq!(tail, &ast.asts[1..]);\n    |                           ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Repetition(Repetition {",
                "                span: Span::default(),",
                "                op: RepetitionOp::default(),",
                "                greedy: true,",
                "                ast: Box::new(Ast::Literal(Literal::default())),",
                "            }),",
                "            Ast::Class(Class::Bracketed(ClassBracketed {",
                "                span: Span::default(),",
                "                negated: false,",
                "                kind: ClassSet::default(),",
                "            })),",
                "        ],",
                "    });",
                "    let mut visitor = MyVisitor::new();",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    }),",
                  "    Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassSet::default(),",
                  "    })),",
                  "    ],",
                  "    });",
                  "    let expected = Some(Frame::Alternation {",
                  "    head: &ast.asts[0],",
                  "    tail: &ast.asts[1..],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert_eq!(result, expected);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Repetition(Repetition {",
                  "                span: Span::default(),",
                  "                op: RepetitionOp::default(),",
                  "                greedy: true,",
                  "                ast: Box::new(Ast::Literal(Literal::default())),",
                  "            }),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed {",
                  "                span: Span::default(),",
                  "                negated: false,",
                  "                kind: ClassSet::default(),",
                  "            })),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    }),",
                  "    Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::default(),",
                  "    negated: false,",
                  "    kind: ClassSet::default(),",
                  "    })),",
                  "    ],",
                  "    });",
                  "    let expected = Some(Frame::Alternation {",
                  "    head: &ast.asts[0],",
                  "    tail: &ast.asts[1..],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert_eq!(result, expected);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |             Ast::Repetition(Repetition {\n    |                             ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:570:21\n    |\n570 |                 op: RepetitionOp::default(),\n    |                     ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:572:44\n    |\n572 |                 ast: Box::new(Ast::Literal(Literal::default())),\n    |                                            ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:574:24\n    |\n574 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:41\n    |\n574 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                         ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:23\n    |\n577 |                 kind: ClassSet::default(),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:32\n    |\n584 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:585:11\n    |\n585 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:587:21\n    |\n587 |     Ast::Repetition(Repetition {\n    |                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:588:11\n    |\n588 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:589:9\n    |\n589 |     op: RepetitionOp::default(),\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:591:32\n    |\n591 |     ast: Box::new(Ast::Literal(Literal::default())),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:593:16\n    |\n593 |     Ast::Class(Class::Bracketed(ClassBracketed {\n    |                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:593:33\n    |\n593 |     Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                 ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:11\n    |\n594 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:596:11\n    |\n596 |     kind: ClassSet::default(),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:581:23\n    |\n581 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:601:16\n    |\n601 |     head: &ast.asts[0],\n    |                ^^^^ unknown field\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:602:16\n    |\n602 |     tail: &ast.asts[1..],\n    |                ^^^^ unknown field\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, expected);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:605:5\n    |\n605 |     assert_eq!(result, expected);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Dot(Span::default()),",
                "            Ast::Flags(SetFlags::default()),",
                "            Ast::Class(Class::Bracketed(ClassBracketed {",
                "                span: Span::default(),",
                "                negated: false,",
                "                kind: ClassSet::default(),",
                "            })),",
                "        ],",
                "    });",
                "    let mut visitor = MyVisitor::new();",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(matches!(result, Some(Frame::Alternation { head, tail }) if matches!(head, &Ast::Dot(_)) && tail.len() == 2));"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(matches!(tail[0], Ast::Flags(_)));"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(matches!(tail[1], Ast::Class(Class::Bracketed(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Dot(Span::default()),",
                  "            Ast::Flags(SetFlags::default()),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed {",
                  "                span: Span::default(),",
                  "                negated: false,",
                  "                kind: ClassSet::default(),",
                  "            })),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Dot(Span::default()),",
                  "            Ast::Flags(SetFlags::default()),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed {",
                  "                span: Span::default(),",
                  "                negated: false,",
                  "                kind: ClassSet::default(),",
                  "            })),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(matches!(result, Some(Frame::Alternation { head, tail }) if matches!(head, &Ast::Dot(_)) && tail.len() == 2));",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Dot(Span::default()),",
                  "            Ast::Flags(SetFlags::default()),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed {",
                  "                span: Span::default(),",
                  "                negated: false,",
                  "                kind: ClassSet::default(),",
                  "            })),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(matches!(tail[0], Ast::Flags(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Dot(Span::default()),",
                  "            Ast::Flags(SetFlags::default()),",
                  "            Ast::Class(Class::Bracketed(ClassBracketed {",
                  "                span: Span::default(),",
                  "                negated: false,",
                  "                kind: ClassSet::default(),",
                  "            })),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(matches!(tail[1], Ast::Class(Class::Bracketed(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |             Ast::Dot(Span::default()),\n    |                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Flags(SetFlags::default()),\n    |                        ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:570:24\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                         ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 kind: ClassSet::default(),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:32\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:52\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:89\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:580:118\n    |\n580 | ...s: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default()...\n    |                                                  ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:580:151\n    |\n580 | ...()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassS...\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:168\n    |\n580 | ...tFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))...\n    |                                                    ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:191\n    |\n580 | ...st::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:230\n    |\n580 | ... span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:577:23\n    |\n577 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:581:23\n    |\n581 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |             Ast::Dot(Span::default()),\n    |                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Flags(SetFlags::default()),\n    |                        ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:570:24\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                         ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 kind: ClassSet::default(),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:32\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:52\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:89\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:580:118\n    |\n580 | ...s: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default()...\n    |                                                  ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:580:151\n    |\n580 | ...()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassS...\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:168\n    |\n580 | ...tFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))...\n    |                                                    ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:191\n    |\n580 | ...st::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:230\n    |\n580 | ... span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:577:23\n    |\n577 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:581:23\n    |\n581 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |             Ast::Dot(Span::default()),\n    |                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Flags(SetFlags::default()),\n    |                        ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:570:24\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                         ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 kind: ClassSet::default(),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:32\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:52\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:89\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:580:118\n    |\n580 | ...s: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default()...\n    |                                                  ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:580:151\n    |\n580 | ...()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassS...\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:168\n    |\n580 | ...tFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))...\n    |                                                    ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:191\n    |\n580 | ...st::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:230\n    |\n580 | ... span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0425]: cannot find value `tail` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:22\n    |\n584 |     assert!(matches!(tail[0], Ast::Flags(_)));\n    |                      ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:577:23\n    |\n577 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:581:23\n    |\n581 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |             Ast::Dot(Span::default()),\n    |                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:569:24\n    |\n569 |             Ast::Flags(SetFlags::default()),\n    |                        ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:570:24\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |             Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                         ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:23\n    |\n571 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 kind: ClassSet::default(),\n    |                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:32\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:52\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:89\n    |\n580 |     let ast = Ast::Alternation(Alternation { span: Span::default(), asts: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default())...\n    |                                                                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/visitor.rs:580:118\n    |\n580 | ...s: vec![Ast::Dot(Span::default()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default()...\n    |                                                  ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:580:151\n    |\n580 | ...()), Ast::Flags(SetFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassS...\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:168\n    |\n580 | ...tFlags::default()), Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))...\n    |                                                    ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:191\n    |\n580 | ...st::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:230\n    |\n580 | ... span: Span::default(), negated: false, kind: ClassSet::default(), }))], });\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0425]: cannot find value `tail` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:22\n    |\n584 |     assert!(matches!(tail[1], Ast::Class(Class::Bracketed(_))));\n    |                      ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:584:42\n    |\n584 |     assert!(matches!(tail[1], Ast::Class(Class::Bracketed(_))));\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:577:23\n    |\n577 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:581:23\n    |\n581 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Assertion(Assertion::default()),",
                "            Ast::Literal(Literal::default()),",
                "        ],",
                "    });",
                "    let mut visitor = MyVisitor::new();",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Assertion(Assertion::default()),",
                  "    Ast::Literal(Literal::default()),",
                  "    ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Assertion(Assertion::default()),",
                  "    Ast::Literal(Literal::default()),",
                  "    ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(head, &ast.asts[0]);"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Assertion(Assertion::default()),",
                  "    Ast::Literal(Literal::default()),",
                  "    ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(tail, &ast.asts[1..]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Assertion(Assertion::default()),",
                  "            Ast::Literal(Literal::default()),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Assertion(Assertion::default()),",
                  "    Ast::Literal(Literal::default()),",
                  "    ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Assertion(Assertion::default()),",
                  "            Ast::Literal(Literal::default()),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Assertion(Assertion::default()),",
                  "    Ast::Literal(Literal::default()),",
                  "    ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(head, &ast.asts[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Assertion(Assertion::default()),",
                  "            Ast::Literal(Literal::default()),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Assertion(Assertion::default()),",
                  "    Ast::Literal(Literal::default()),",
                  "    ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    if let Some(frame) = result {",
                  "    match frame {",
                  "    Frame::Alternation { head, tail } => {",
                  "    assert_eq!(tail, &ast.asts[1..]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n   --> regex-syntax/src/ast/visitor.rs:568:28\n    |\n568 |             Ast::Assertion(Assertion::default()),\n    |                            ^^^^^^^^^ use of undeclared type `Assertion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:26\n    |\n569 |             Ast::Literal(Literal::default()),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:32\n    |\n575 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n   --> regex-syntax/src/ast/visitor.rs:578:20\n    |\n578 |     Ast::Assertion(Assertion::default()),\n    |                    ^^^^^^^^^ use of undeclared type `Assertion`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n579 |     Ast::Literal(Literal::default()),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:582:23\n    |\n582 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n564 | {\n    | - unclosed delimiter\n...\n585 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n586 |     match frame {\n587 |     Frame::Alternation { head, tail } => {\n    |                                          - this delimiter might not be properly closed...\n588 |     assert_eq!(head, &ast.asts[0]);\n589 | }\n    | - ...as it matches this but it has different indentation\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:590:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n564 | {\n    | - unclosed delimiter\n...\n585 |     if let Some(frame) = result {\n    |                                 - unclosed delimiter\n586 |     match frame {\n587 |     Frame::Alternation { head, tail } => {\n    |                                          - this delimiter might not be properly closed...\n588 |     assert_eq!(tail, &ast.asts[1..]);\n589 | }\n    | - ...as it matches this but it has different indentation\n590 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::default(),",
                "        asts: vec![",
                "            Ast::Concat(Concat {",
                "                span: Span::default(),",
                "                asts: vec![Ast::Literal(Literal::default())],",
                "            }),",
                "            Ast::Repetition(Repetition {",
                "                span: Span::default(),",
                "                op: RepetitionOp::default(),",
                "                greedy: false,",
                "                ast: Box::new(Ast::Empty(Span::default())),",
                "            }),",
                "        ],",
                "    });",
                "    let mut visitor = MyVisitor::new();",
                "    let mut visitor_instance = HeapVisitor::new();",
                "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(result.is_some());"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let frame = result.unwrap();",
                  "    assert!(matches!(frame, Frame::Alternation { head, tail }));"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let frame = result.unwrap();",
                  "    assert_eq!(head, &ast.asts[0]);"
                ],
                [
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let frame = result.unwrap();",
                  "    assert_eq!(tail, &ast.asts[1..]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Concat(Concat {",
                  "                span: Span::default(),",
                  "                asts: vec![Ast::Literal(Literal::default())],",
                  "            }),",
                  "            Ast::Repetition(Repetition {",
                  "                span: Span::default(),",
                  "                op: RepetitionOp::default(),",
                  "                greedy: false,",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    assert!(result.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Concat(Concat {",
                  "                span: Span::default(),",
                  "                asts: vec![Ast::Literal(Literal::default())],",
                  "            }),",
                  "            Ast::Repetition(Repetition {",
                  "                span: Span::default(),",
                  "                op: RepetitionOp::default(),",
                  "                greedy: false,",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let frame = result.unwrap();",
                  "    assert!(matches!(frame, Frame::Alternation { head, tail }));",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Concat(Concat {",
                  "                span: Span::default(),",
                  "                asts: vec![Ast::Literal(Literal::default())],",
                  "            }),",
                  "            Ast::Repetition(Repetition {",
                  "                span: Span::default(),",
                  "                op: RepetitionOp::default(),",
                  "                greedy: false,",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let frame = result.unwrap();",
                  "    assert_eq!(head, &ast.asts[0]);",
                  "}"
                ],
                [
                  "{",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![",
                  "            Ast::Concat(Concat {",
                  "                span: Span::default(),",
                  "                asts: vec![Ast::Literal(Literal::default())],",
                  "            }),",
                  "            Ast::Repetition(Repetition {",
                  "                span: Span::default(),",
                  "                op: RepetitionOp::default(),",
                  "                greedy: false,",
                  "                ast: Box::new(Ast::Empty(Span::default())),",
                  "            }),",
                  "        ],",
                  "    });",
                  "    let mut visitor = MyVisitor::new();",
                  "    let mut visitor_instance = HeapVisitor::new();",
                  "    visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::default(),",
                  "    asts: vec![",
                  "    Ast::Concat(Concat {",
                  "    span: Span::default(),",
                  "    asts: vec![Ast::Literal(Literal::default())],",
                  "    }),",
                  "    Ast::Repetition(Repetition {",
                  "    span: Span::default(),",
                  "    op: RepetitionOp::default(),",
                  "    greedy: false,",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    }),",
                  "    ],",
                  "    });",
                  "    let result = visitor_instance.induct(&ast, &mut visitor).unwrap();",
                  "    let frame = result.unwrap();",
                  "    assert_eq!(tail, &ast.asts[1..]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |             Ast::Concat(Concat {\n    |                         ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |                 asts: vec![Ast::Literal(Literal::default())],\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:29\n    |\n572 |             Ast::Repetition(Repetition {\n    |                             ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:574:21\n    |\n574 |                 op: RepetitionOp::default(),\n    |                     ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:32\n    |\n583 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     Ast::Concat(Concat {\n    |                 ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:29\n    |\n588 |     asts: vec![Ast::Literal(Literal::default())],\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:21\n    |\n590 |     Ast::Repetition(Repetition {\n    |                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:592:9\n    |\n592 |     op: RepetitionOp::default(),\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |             Ast::Concat(Concat {\n    |                         ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |                 asts: vec![Ast::Literal(Literal::default())],\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:29\n    |\n572 |             Ast::Repetition(Repetition {\n    |                             ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:574:21\n    |\n574 |                 op: RepetitionOp::default(),\n    |                     ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:32\n    |\n583 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     Ast::Concat(Concat {\n    |                 ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:29\n    |\n588 |     asts: vec![Ast::Literal(Literal::default())],\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:21\n    |\n590 |     Ast::Repetition(Repetition {\n    |                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:592:9\n    |\n592 |     op: RepetitionOp::default(),\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |             Ast::Concat(Concat {\n    |                         ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |                 asts: vec![Ast::Literal(Literal::default())],\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:29\n    |\n572 |             Ast::Repetition(Repetition {\n    |                             ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:574:21\n    |\n574 |                 op: RepetitionOp::default(),\n    |                     ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:32\n    |\n583 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     Ast::Concat(Concat {\n    |                 ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:29\n    |\n588 |     asts: vec![Ast::Literal(Literal::default())],\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:21\n    |\n590 |     Ast::Repetition(Repetition {\n    |                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:592:9\n    |\n592 |     op: RepetitionOp::default(),\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `head` in this scope\n   --> regex-syntax/src/ast/visitor.rs:600:16\n    |\n600 |     assert_eq!(head, &ast.asts[0]);\n    |                ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |     assert_eq!(head, &ast.asts[0]);\n    |                           ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:32\n    |\n565 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:566:15\n    |\n566 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:25\n    |\n568 |             Ast::Concat(Concat {\n    |                         ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:23\n    |\n569 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:41\n    |\n570 |                 asts: vec![Ast::Literal(Literal::default())],\n    |                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:29\n    |\n572 |             Ast::Repetition(Repetition {\n    |                             ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |                 span: Span::default(),\n    |                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:574:21\n    |\n574 |                 op: RepetitionOp::default(),\n    |                     ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:42\n    |\n576 |                 ast: Box::new(Ast::Empty(Span::default())),\n    |                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:32\n    |\n583 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:586:17\n    |\n586 |     Ast::Concat(Concat {\n    |                 ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:587:11\n    |\n587 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:29\n    |\n588 |     asts: vec![Ast::Literal(Literal::default())],\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:590:21\n    |\n590 |     Ast::Repetition(Repetition {\n    |                     ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:592:9\n    |\n592 |     op: RepetitionOp::default(),\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:594:30\n    |\n594 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `tail` in this scope\n   --> regex-syntax/src/ast/visitor.rs:600:16\n    |\n600 |     assert_eq!(tail, &ast.asts[1..]);\n    |                ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MyVisitor`\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MyVisitor::new();\n    |                       ^^^^^^^^^\n    |                       |\n    |                       use of undeclared type `MyVisitor`\n    |                       help: a trait with a similar name exists: `Visitor`\n\nerror[E0609]: no field `asts` on type `ast::Ast`\n   --> regex-syntax/src/ast/visitor.rs:600:27\n    |\n600 |     assert_eq!(tail, &ast.asts[1..]);\n    |                           ^^^^ unknown field\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0609.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "Ast::Group(ref x) where x has a non-empty collection of child nodes, ensuring a valid Group with at least one child Ast.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = DummyVisitor;",
                "    let group = ast::Group {",
                "        span: Span::default(),",
                "        kind: GroupKind::default(),",
                "        ast: Box::new(Ast::Literal(Literal::default())),",
                "    };",
                "    let ast = Ast::Group(group);",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());"
                ],
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Group(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Literal(Literal::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Group(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::default())),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:32\n    |\n578 |     ast: Box::new(Ast::Literal(Literal::default())),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::default())),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:32\n    |\n578 |     ast: Box::new(Ast::Literal(Literal::default())),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::default())),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:578:32\n    |\n578 |     ast: Box::new(Ast::Literal(Literal::default())),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = DummyVisitor;",
                "    let children = vec![",
                "        Ast::Literal(Literal::default()),",
                "        Ast::Literal(Literal::default()),",
                "    ];",
                "    let group = ast::Group {",
                "        span: Span::default(),",
                "        kind: GroupKind::default(),",
                "        ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                "    };",
                "    let ast = Ast::Group(group);",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(Some(Frame::Group(&group))));"
                ],
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let children = vec![Ast::Literal(Literal::default())];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(Some(Frame::Group(&group))));"
                ],
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let children = vec![Ast::Literal(Literal::default())];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![",
                  "        Ast::Literal(Literal::default()),",
                  "        Ast::Literal(Literal::default()),",
                  "    ];",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(Some(Frame::Group(&group))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![",
                  "        Ast::Literal(Literal::default()),",
                  "        Ast::Literal(Literal::default()),",
                  "    ];",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let children = vec![Ast::Literal(Literal::default())];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(Some(Frame::Group(&group))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![",
                  "        Ast::Literal(Literal::default()),",
                  "        Ast::Literal(Literal::default()),",
                  "    ];",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let children = vec![Ast::Literal(Literal::default())];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let children = vec![];",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Empty(Span::default())),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:567:22\n    |\n567 |         Ast::Literal(Literal::default()),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |         Ast::Literal(Literal::default()),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:35\n    |\n573 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:50\n    |\n573 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:23\n    |\n578 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:31\n    |\n583 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:46\n    |\n583 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:588:5\n    |\n588 |     assert_eq!(result, Ok(Some(Frame::Group(&group))));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:588:5\n    |\n588 |     assert_eq!(result, Ok(Some(Frame::Group(&group))));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:567:22\n    |\n567 |         Ast::Literal(Literal::default()),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |         Ast::Literal(Literal::default()),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:35\n    |\n573 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:50\n    |\n573 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:23\n    |\n578 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:31\n    |\n583 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:46\n    |\n583 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:38\n    |\n588 |     let children = vec![Ast::Literal(Literal::default())];\n    |                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:590:11\n    |\n590 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:31\n    |\n592 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:592:46\n    |\n592 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:597:5\n    |\n597 |     assert_eq!(result, Ok(Some(Frame::Group(&group))));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:597:5\n    |\n597 |     assert_eq!(result, Ok(Some(Frame::Group(&group))));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:567:22\n    |\n567 |         Ast::Literal(Literal::default()),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:22\n    |\n568 |         Ast::Literal(Literal::default()),\n    |                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:35\n    |\n573 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:573:50\n    |\n573 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:23\n    |\n578 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:582:11\n    |\n582 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:31\n    |\n583 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:583:46\n    |\n583 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:588:38\n    |\n588 |     let children = vec![Ast::Literal(Literal::default())];\n    |                                      ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:590:11\n    |\n590 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:591:11\n    |\n591 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:592:31\n    |\n592 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:592:46\n    |\n592 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: children })),\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:599:11\n    |\n599 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:600:11\n    |\n600 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:601:30\n    |\n601 |     ast: Box::new(Ast::Empty(Span::default())),\n    |                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:606:5\n    |\n606 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:606:5\n    |\n606 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = DummyVisitor;",
                "    let group = ast::Group {",
                "        span: Span::default(),",
                "        kind: GroupKind::default(),",
                "        ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),",
                "    };",
                "    let ast = Ast::Group(group);",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(result, Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let group = ast::Group {",
                  "    span: Span::default(),",
                  "    kind: GroupKind::default(),",
                  "    ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(result, Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:35\n    |\n569 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),\n    |                                   ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:50\n    |\n569 |         ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::default(),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     kind: GroupKind::default(),\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:31\n    |\n577 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),\n    |                               ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:46\n    |\n577 |     ast: Box::new(Ast::Concat(Concat { span: Span::default(), asts: vec![] })),\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:580:5\n    |\n580 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:580:5\n    |\n580 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = DummyVisitor;",
                "    let alternation = ast::Alternation {",
                "        span: Span::default(),",
                "        asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],",
                "    };",
                "    let group = ast::Group {",
                "        span: Span::default(),",
                "        kind: GroupKind::default(),",
                "        ast: Box::new(Ast::Alternation(alternation)),",
                "    };",
                "    let ast = Ast::Group(group);",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())] };",
                  "    let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = DummyVisitor;",
                  "    let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())] };",
                  "    let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Group(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],",
                  "    };",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Alternation(alternation)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())] };",
                  "    let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = DummyVisitor;",
                  "    let alternation = ast::Alternation {",
                  "        span: Span::default(),",
                  "        asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],",
                  "    };",
                  "    let group = ast::Group {",
                  "        span: Span::default(),",
                  "        kind: GroupKind::default(),",
                  "        ast: Box::new(Ast::Alternation(alternation)),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = DummyVisitor;",
                  "    let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())] };",
                  "    let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Group(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:33\n    |\n568 |         asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],\n    |                                 ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:67\n    |\n568 |         asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],\n    |                                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:23\n    |\n578 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:48\n    |\n579 |     let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::defaul...\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:89\n    |\n579 |     let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::defaul...\n    |                                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:123\n    |\n579 | ...Ast::Literal(Literal::default()), Ast::Literal(Literal::default())] };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:36\n    |\n580 |     let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };\n    |                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:580:59\n    |\n580 |     let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };\n    |                                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:33\n    |\n568 |         asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],\n    |                                 ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:67\n    |\n568 |         asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::default())],\n    |                                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span::default(),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:572:15\n    |\n572 |         kind: GroupKind::default(),\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:23\n    |\n578 |     let mut visitor = DummyVisitor;\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:48\n    |\n579 |     let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::defaul...\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:89\n    |\n579 |     let alternation = ast::Alternation { span: Span::default(), asts: vec![Ast::Literal(Literal::default()), Ast::Literal(Literal::defaul...\n    |                                                                                         ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:123\n    |\n579 | ...Ast::Literal(Literal::default()), Ast::Literal(Literal::default())] };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:580:36\n    |\n580 |     let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };\n    |                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:580:59\n    |\n580 |     let group = ast::Group { span: Span::default(), kind: GroupKind::default(), ast: Box::new(Ast::Alternation(alternation)) };\n    |                                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n",
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "Ast::Repetition(ref x) where x contains varying spans, greediness; Ast::Class(ast::Class::Bracketed(ref x)) where x contains nested classes or ranges; Ast::Group(ref x) where x has multiple spans; Ast::Concat(ref x) where x.asts has minimum 1 and maximum reasonable size (e.g., 0-5); Ast::Alternation(ref x) where x.asts contains minimum of 1 and maximum reasonable size (0-5).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 5 };",
                "    let repetition = Repetition {",
                "        span,",
                "        op: RepetitionOp::Plus,",
                "        greedy: true,",
                "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    ",
                "    let mut visitor = DummyVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition {",
                  "    span,",
                  "    op: RepetitionOp::Plus,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition {",
                  "    span,",
                  "    op: RepetitionOp::Plus,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), Some(Frame::Repetition(&repetition)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition {",
                  "        span,",
                  "        op: RepetitionOp::Plus,",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition {",
                  "    span,",
                  "    op: RepetitionOp::Plus,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition {",
                  "        span,",
                  "        op: RepetitionOp::Plus,",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    ",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 5 };",
                  "    let repetition = Repetition {",
                  "    span,",
                  "    op: RepetitionOp::Plus,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), Some(Frame::Repetition(&repetition)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:22\n    |\n566 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |         op: RepetitionOp::Plus,\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:36\n    |\n570 |         ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:16\n    |\n577 |     let span = Span { start: 0, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:22\n    |\n578 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:580:9\n    |\n580 |     op: RepetitionOp::Plus,\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:32\n    |\n582 |     ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:22\n    |\n566 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |         op: RepetitionOp::Plus,\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:36\n    |\n570 |         ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:16\n    |\n577 |     let span = Span { start: 0, end: 5 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:22\n    |\n578 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:580:9\n    |\n580 |     op: RepetitionOp::Plus,\n    |         ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:32\n    |\n582 |     ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:588:5\n    |\n588 |     assert_eq!(result.unwrap(), Some(Frame::Repetition(&repetition)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:588:5\n    |\n588 |     assert_eq!(result.unwrap(), Some(Frame::Repetition(&repetition)));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 10 };",
                "    let class_set = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                "    };",
                "    let ast = Ast::Class(Class::Bracketed(class_set));",
                "",
                "    let mut visitor = DummyVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_set = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                  "    };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_set = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                  "    };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Repetition(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_set = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(class_set));",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_set = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                  "    };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_set = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(class_set));",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 10 };",
                  "    let class_set = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),",
                  "    };",
                  "    let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Repetition(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 10 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:21\n    |\n566 |     let class_set = ClassBracketed {\n    |                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:64\n    |\n569 |         kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:571:26\n    |\n571 |     let ast = Ast::Class(Class::Bracketed(class_set));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span { start: 0, end: 10 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:21\n    |\n577 |     let class_set = ClassBracketed {\n    |                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:32\n    |\n580 |     kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:31\n    |\n582 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:582:54\n    |\n582 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });\n    |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 10 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:21\n    |\n566 |     let class_set = ClassBracketed {\n    |                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                    ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:64\n    |\n569 |         kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:571:26\n    |\n571 |     let ast = Ast::Class(Class::Bracketed(class_set));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span { start: 0, end: 10 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:21\n    |\n577 |     let class_set = ClassBracketed {\n    |                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:580:11\n    |\n580 |     kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:32\n    |\n580 |     kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:580:60\n    |\n580 |     kind: ClassSet::Union(vec![ClassSetItem::Literal('a'), ClassSetItem::Literal('b')]),\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:31\n    |\n582 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:582:54\n    |\n582 |     let ast = Ast::Repetition(Repetition { span, op: RepetitionOp::Plus, greedy: true, ast: Box::new(ast) });\n    |                                                      ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 3 };",
                "    let group = Group {",
                "        span,",
                "        kind: GroupKind::Capture,",
                "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                "    };",
                "    let ast = Ast::Group(group);",
                "",
                "    let mut visitor = DummyVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());"
                ],
                [
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_matches!(result.unwrap(), Some(Frame::Group(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group {",
                  "        span,",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group {",
                  "        span,",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group {",
                  "        span,",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span { start: 0, end: 3 };",
                  "    let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_matches!(result.unwrap(), Some(Frame::Group(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::Capture,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span { start: 0, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:17\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:577:37\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:84\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:23\n    |\n579 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::Capture,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span { start: 0, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:17\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:577:37\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:84\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:23\n    |\n579 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror: cannot find macro `assert_matches` in this scope\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     assert_matches!(result.unwrap(), Some(Frame::Group(_)));\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n560 +    use std::assert_matches::assert_matches;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span { start: 0, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:17\n    |\n566 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::Capture,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::Char('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span { start: 0, end: 3 };\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:17\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:577:37\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:84\n    |\n577 |     let group = Group { span, kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal::Char('a'))) };\n    |                                                                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:23\n    |\n579 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span1 = Span { start: 0, end: 1 };",
                "    let lit1 = Ast::Literal(Literal::Char('a'));",
                "    let span2 = Span { start: 1, end: 2 };",
                "    let lit2 = Ast::Literal(Literal::Char('b'));",
                "",
                "    let concat = Concat {",
                "        span: Span { start: 0, end: 2 },",
                "        asts: vec![lit1, lit2],",
                "    };",
                "    let ast = Ast::Concat(concat);",
                "",
                "    let mut visitor = DummyVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let concat = Concat {",
                  "    span: Span { start: 0, end: 2 },",
                  "    asts: vec![lit1, lit2],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "    assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), Some(Frame::Concat { head: &lit1, tail: &[lit2] }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "",
                  "    let concat = Concat {",
                  "        span: Span { start: 0, end: 2 },",
                  "        asts: vec![lit1, lit2],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let concat = Concat {",
                  "    span: Span { start: 0, end: 2 },",
                  "    asts: vec![lit1, lit2],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "    assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), Some(Frame::Concat { head: &lit1, tail: &[lit2] }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:29\n    |\n566 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:18\n    |\n570 |     let concat = Concat {\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span { start: 0, end: 2 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:17\n    |\n579 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:29\n    |\n580 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:17\n    |\n581 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:29\n    |\n582 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:18\n    |\n583 |     let concat = Concat {\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:584:11\n    |\n584 |     span: Span { start: 0, end: 2 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:588:5\n    |\n588 |     assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), Some(Frame::Concat { head: &lit1, tail: &[lit2] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:588:5\n    |\n588 |     assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), Some(Frame::Concat { head: &lit1, tail: &[lit2] }));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span1 = Span { start: 0, end: 1 };",
                "    let lit1 = Ast::Literal(Literal::Char('a'));",
                "    let span2 = Span { start: 1, end: 2 };",
                "    let lit2 = Ast::Literal(Literal::Char('b'));",
                "",
                "    let alternation = Alternation {",
                "        span: Span { start: 0, end: 2 },",
                "        asts: vec![lit1, lit2],",
                "    };",
                "    let ast = Ast::Alternation(alternation);",
                "",
                "    let mut visitor = DummyVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());"
                ],
                [
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Alternation { head: _, tail: _ })));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "",
                  "    let alternation = Alternation {",
                  "        span: Span { start: 0, end: 2 },",
                  "        asts: vec![lit1, lit2],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "",
                  "    let alternation = Alternation {",
                  "        span: Span { start: 0, end: 2 },",
                  "        asts: vec![lit1, lit2],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "",
                  "    let alternation = Alternation {",
                  "        span: Span { start: 0, end: 2 },",
                  "        asts: vec![lit1, lit2],",
                  "    };",
                  "    let ast = Ast::Alternation(alternation);",
                  "",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span1 = Span { start: 0, end: 1 };",
                  "    let lit1 = Ast::Literal(Literal::Char('a'));",
                  "    let span2 = Span { start: 1, end: 2 };",
                  "    let lit2 = Ast::Literal(Literal::Char('b'));",
                  "    let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };",
                  "    let ast = Ast::Alternation(alternation);",
                  "    let mut visitor = DummyVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(matches!(result.unwrap(), Some(Frame::Alternation { head: _, tail: _ })));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:29\n    |\n566 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let alternation = Alternation {\n    |                       ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span { start: 0, end: 2 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:17\n    |\n579 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:29\n    |\n580 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:17\n    |\n581 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:29\n    |\n582 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };\n    |                       ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:43\n    |\n583 |     let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };\n    |                                           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:29\n    |\n566 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let alternation = Alternation {\n    |                       ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span { start: 0, end: 2 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:17\n    |\n579 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:29\n    |\n580 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:17\n    |\n581 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:29\n    |\n582 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };\n    |                       ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:43\n    |\n583 |     let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };\n    |                                           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:17\n    |\n565 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:566:29\n    |\n566 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:568:29\n    |\n568 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:23\n    |\n570 |     let alternation = Alternation {\n    |                       ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         span: Span { start: 0, end: 2 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:23\n    |\n576 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:17\n    |\n579 |     let span1 = Span { start: 0, end: 1 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:29\n    |\n580 |     let lit1 = Ast::Literal(Literal::Char('a'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:581:17\n    |\n581 |     let span2 = Span { start: 1, end: 2 };\n    |                 ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:582:29\n    |\n582 |     let lit2 = Ast::Literal(Literal::Char('b'));\n    |                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:23\n    |\n583 |     let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };\n    |                       ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:583:43\n    |\n583 |     let alternation = Alternation { span: Span { start: 0, end: 2 }, asts: vec![lit1, lit2] };\n    |                                           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `DummyVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:585:23\n    |\n585 |     let mut visitor = DummyVisitor {};\n    |                       ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches Ast::Repetition(ref x) is false\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is false\n",
        "// constraint: *ast matches Ast::Group(ref x) is false\n",
        "// constraint: *ast matches _ is true\n",
        "// constraint: *ast matches Ast::Alternation(ref x) is false\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is false\n",
        "// constraint: *ast matches Ast::Concat(ref x) is false\n",
        "// constraint: *ast matches Ast::Concat(ref x) is false\n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "Ast::Empty(Span), Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: false, kind: ClassSet })), Ast::Literal(Literal)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {}; ",
                "    let ast = Ast::Empty(span);",
                "    let mut visitor = MockVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let ast = Ast::Empty(span);",
                  "    assert_eq!(heap_visitor.induct(&ast, &mut visitor), Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {}; ",
                  "    let ast = Ast::Empty(span);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span {};",
                  "    let ast = Ast::Empty(span);",
                  "    assert_eq!(heap_visitor.induct(&ast, &mut visitor), Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span {}; \n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:23\n    |\n567 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:570:16\n    |\n570 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:572:5\n    |\n572 |     assert_eq!(heap_visitor.induct(&ast, &mut visitor), Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:572:5\n    |\n572 |     assert_eq!(heap_visitor.induct(&ast, &mut visitor), Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {};",
                "    let class_set = ClassSet {}; ",
                "    let class_bracketed = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: class_set,",
                "    };",
                "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                "    let mut visitor = MockVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let class_set = ClassSet {};",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: class_set };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let class_set = ClassSet {};",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: class_set };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {};",
                  "    let class_set = ClassSet {}; ",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: class_set,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span {};",
                  "    let class_set = ClassSet {};",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: class_set };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {};",
                  "    let class_set = ClassSet {}; ",
                  "    let class_bracketed = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: class_set,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span {};",
                  "    let class_set = ClassSet {};",
                  "    let class_bracketed = ClassBracketed { span, negated: false, kind: class_set };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:21\n    |\n566 |     let class_set = ClassSet {}; \n    |                     ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:27\n    |\n567 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:572:26\n    |\n572 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:21\n    |\n577 |     let class_set = ClassSet {};\n    |                     ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let class_bracketed = ClassBracketed { span, negated: false, kind: class_set };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:579:26\n    |\n579 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:21\n    |\n566 |     let class_set = ClassSet {}; \n    |                     ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:27\n    |\n567 |     let class_bracketed = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:572:26\n    |\n572 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:16\n    |\n576 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassSet` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:21\n    |\n577 |     let class_set = ClassSet {};\n    |                     ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let class_bracketed = ClassBracketed { span, negated: false, kind: class_set };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:579:26\n    |\n579 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:23\n    |\n580 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span {};",
                "    let literal = Literal {}; ",
                "    let ast = Ast::Literal(literal);",
                "    let mut visitor = MockVisitor {};",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span {};",
                  "    let literal = Literal {};",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span {};",
                  "    let literal = Literal {};",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span {};",
                  "    let literal = Literal {}; ",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span {};",
                  "    let literal = Literal {};",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span {};",
                  "    let literal = Literal {}; ",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let _ = heap_visitor.induct(&ast, &mut visitor);",
                  "    let span = Span {};",
                  "    let literal = Literal {};",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut visitor = MockVisitor {};",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal {}; \n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal {};\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:565:16\n    |\n565 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:19\n    |\n566 |     let literal = Literal {}; \n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:23\n    |\n568 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/visitor.rs:571:16\n    |\n571 |     let span = Span {};\n    |                ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/visitor.rs:572:19\n    |\n572 |     let literal = Literal {};\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Literal;\n    |\n560 +    use ast::ClassSetItem::Literal;\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `MockVisitor` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:23\n    |\n574 |     let mut visitor = MockVisitor {};\n    |                       ^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:577:5\n    |\n577 |     assert_eq!(result.unwrap(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:577:5\n    |\n577 |     assert_eq!(result.unwrap(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: self.visit_class(x, visitor)? is Err/None\n"
      ],
      "input_infer": "0 < x.asts.len() < 1, visitor should return None, self.visit_class(x, visitor) returns Err\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let class_set_item = ast::ClassSetItem::new(); // Initialize as needed",
                "    let bracketed_class = ClassBracketed {",
                "        span: Span::new(0, 1), // Replace with valid Span",
                "        negated: false,",
                "        kind: ClassSet::Single(class_set_item), // Initialize properly",
                "    };",
                "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Single(class_set_item),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Single(class_set_item),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.err().unwrap(), visitor.error());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Single(class_set_item),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        negated: false,",
                  "        kind: ClassSet::Single(class_set_item), // Initialize properly",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Single(class_set_item),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        negated: false,",
                  "        kind: ClassSet::Single(class_set_item), // Initialize properly",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Single(class_set_item),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.err().unwrap(), visitor.error());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let bracketed_class = ClassBracketed {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        negated: false,",
                  "        kind: ClassSet::Single(class_set_item), // Initialize properly",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let class_set_item = ast::ClassSetItem::new();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Single(class_set_item),",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:27\n    |\n568 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         kind: ClassSet::Single(class_set_item), // Initialize properly\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     kind: ClassSet::Single(class_set_item),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:583:26\n    |\n583 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:45\n    |\n567 |     let class_set_item = ast::ClassSetItem::new(); // Initialize as needed\n    |                                             ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:45\n    |\n577 |     let class_set_item = ast::ClassSetItem::new();\n    |                                             ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:27\n    |\n568 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         kind: ClassSet::Single(class_set_item), // Initialize properly\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     kind: ClassSet::Single(class_set_item),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:583:26\n    |\n583 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:45\n    |\n567 |     let class_set_item = ast::ClassSetItem::new(); // Initialize as needed\n    |                                             ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:45\n    |\n577 |     let class_set_item = ast::ClassSetItem::new();\n    |                                             ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:568:27\n    |\n568 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:571:15\n    |\n571 |         kind: ClassSet::Single(class_set_item), // Initialize properly\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:573:26\n    |\n573 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:27\n    |\n578 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     kind: ClassSet::Single(class_set_item),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:583:26\n    |\n583 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:45\n    |\n567 |     let class_set_item = ast::ClassSetItem::new(); // Initialize as needed\n    |                                             ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:45\n    |\n577 |     let class_set_item = ast::ClassSetItem::new();\n    |                                             ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:585:5\n    |\n585 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:585:5\n    |\n585 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let concat = Concat {",
                "        span: Span::new(0, 1), // Replace with valid Span",
                "        asts: vec![],",
                "    };",
                "    let ast = Ast::Concat(concat);",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![] };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![] };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let concat = Concat {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        asts: vec![],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![] };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let concat = Concat {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        asts: vec![],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![] };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:18\n    |\n567 |     let concat = Concat {\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let concat = Concat { span: Span::new(0, 1), asts: vec![] };\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:33\n    |\n575 |     let concat = Concat { span: Span::new(0, 1), asts: vec![] };\n    |                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:18\n    |\n567 |     let concat = Concat {\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:575:18\n    |\n575 |     let concat = Concat { span: Span::new(0, 1), asts: vec![] };\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:33\n    |\n575 |     let concat = Concat { span: Span::new(0, 1), asts: vec![] };\n    |                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let ast1 = ast::ClassSetItem::new(); // Initialize as needed",
                "    let ast2 = ast::ClassSetItem::new(); // Initialize as needed",
                "    let concat = Concat {",
                "        span: Span::new(0, 1), // Replace with valid Span",
                "        asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],",
                "    };",
                "    let ast = Ast::Concat(concat);",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let ast1 = ast::ClassSetItem::new();",
                  "    let ast2 = ast::ClassSetItem::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let ast1 = ast::ClassSetItem::new();",
                  "    let ast2 = ast::ClassSetItem::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let ast1 = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let ast2 = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let concat = Concat {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let ast1 = ast::ClassSetItem::new();",
                  "    let ast2 = ast::ClassSetItem::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let ast1 = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let ast2 = ast::ClassSetItem::new(); // Initialize as needed",
                  "    let concat = Concat {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],",
                  "    };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let ast1 = ast::ClassSetItem::new();",
                  "    let ast2 = ast::ClassSetItem::new();",
                  "    let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };",
                  "    let ast = Ast::Concat(concat);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:18\n    |\n569 |     let concat = Concat {\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:571:31\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:571:48\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:571:84\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                                                                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:571:101\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                                                                                                     ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n579 |     let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracke...\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:33\n    |\n579 |     let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracke...\n    |                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:579:72\n    |\n579 |     let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracke...\n    |                                                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:579:89\n    |\n579 | ... asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };\n    |                                            ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:579:125\n    |\n579 | ...s::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:579:142\n    |\n579 | ...d::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };\n    |                                            ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:35\n    |\n567 |     let ast1 = ast::ClassSetItem::new(); // Initialize as needed\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:35\n    |\n568 |     let ast2 = ast::ClassSetItem::new(); // Initialize as needed\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:35\n    |\n577 |     let ast1 = ast::ClassSetItem::new();\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:35\n    |\n578 |     let ast2 = ast::ClassSetItem::new();\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:569:18\n    |\n569 |     let concat = Concat {\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:570:15\n    |\n570 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:571:31\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:571:48\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                                                ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:571:84\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                                                                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:571:101\n    |\n571 |         asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))],\n    |                                                                                                     ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n579 |     let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracke...\n    |                  ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:33\n    |\n579 |     let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracke...\n    |                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:579:72\n    |\n579 |     let concat = Concat { span: Span::new(0, 1), asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracke...\n    |                                                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:579:89\n    |\n579 | ... asts: vec![Ast::Class(Class::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };\n    |                                            ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:579:125\n    |\n579 | ...s::Bracketed(ClassBracketed::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };\n    |                                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/visitor.rs:579:142\n    |\n579 | ...d::new())), Ast::Class(Class::Bracketed(ClassBracketed::new()))], };\n    |                                            ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:567:35\n    |\n567 |     let ast1 = ast::ClassSetItem::new(); // Initialize as needed\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:568:35\n    |\n568 |     let ast2 = ast::ClassSetItem::new(); // Initialize as needed\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:577:35\n    |\n577 |     let ast1 = ast::ClassSetItem::new();\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nerror[E0599]: no variant or associated item named `new` found for enum `ClassSetItem` in the current scope\n   --> regex-syntax/src/ast/visitor.rs:578:35\n    |\n578 |     let ast2 = ast::ClassSetItem::new();\n    |                                   ^^^ variant or associated item not found in `ClassSetItem`\n    |\n   ::: regex-syntax/src/ast/mod.rs:963:1\n    |\n963 | pub enum ClassSetItem {\n    | --------------------- variant or associated item `new` not found for this enum\n    |\nhelp: there is a method `ne` with a similar name, but with different arguments\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/cmp.rs:262:5\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let repetition = Repetition {",
                "        span: Span::new(0, 1), // Replace with valid Span",
                "        op: RepetitionOp::ZeroOrMore, // Use an appropriate operation",
                "        greedy: true,",
                "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed",
                "    };",
                "    let ast = Ast::Repetition(repetition);",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_matches!(result.unwrap().unwrap(), Frame::Repetition(_));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        op: RepetitionOp::ZeroOrMore, // Use an appropriate operation",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        op: RepetitionOp::ZeroOrMore, // Use an appropriate operation",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        op: RepetitionOp::ZeroOrMore, // Use an appropriate operation",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed",
                  "    };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_matches!(result.unwrap().unwrap(), Frame::Repetition(_));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:22\n    |\n567 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:569:13\n    |\n569 |         op: RepetitionOp::ZeroOrMore, // Use an appropriate operation\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:571:36\n    |\n571 |         ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:22\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:577:62\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:129\n    |\n577 | ...More, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:22\n    |\n567 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:569:13\n    |\n569 |         op: RepetitionOp::ZeroOrMore, // Use an appropriate operation\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:571:36\n    |\n571 |         ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:22\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:577:62\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:129\n    |\n577 | ...More, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror: cannot find macro `assert_matches` in this scope\n   --> regex-syntax/src/ast/visitor.rs:580:5\n    |\n580 |     assert_matches!(result.unwrap().unwrap(), Frame::Repetition(_));\n    |     ^^^^^^^^^^^^^^\n    |\nhelp: consider importing this macro\n    |\n560 +    use std::assert_matches::assert_matches;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:22\n    |\n567 |     let repetition = Repetition {\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:569:13\n    |\n569 |         op: RepetitionOp::ZeroOrMore, // Use an appropriate operation\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:571:36\n    |\n571 |         ast: Box::new(Ast::Literal(Literal::new('a'))), // Initialize as needed\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:577:22\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:41\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:577:62\n    |\n577 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal::...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:129\n    |\n577 | ...More, greedy: true, ast: Box::new(Ast::Literal(Literal::new('a'))) };\n    |                                                   ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    let group = Group {",
                "        span: Span::new(0, 1), // Replace with valid Span",
                "        kind: GroupKind::Capture, // Use an appropriate GroupKind",
                "        ast: Box::new(Ast::Literal(Literal::new('b'))), // Initialize as needed",
                "    };",
                "    let ast = Ast::Group(group);",
                "    let result = heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let group = Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Literal(Literal::new('b'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let group = Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Literal(Literal::new('b'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let group = Group {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        kind: GroupKind::Capture, // Use an appropriate GroupKind",
                  "        ast: Box::new(Ast::Literal(Literal::new('b'))), // Initialize as needed",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let group = Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Literal(Literal::new('b'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let group = Group {",
                  "        span: Span::new(0, 1), // Replace with valid Span",
                  "        kind: GroupKind::Capture, // Use an appropriate GroupKind",
                  "        ast: Box::new(Ast::Literal(Literal::new('b'))), // Initialize as needed",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let group = Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Literal(Literal::new('b'))),",
                  "    };",
                  "    let ast = Ast::Group(group);",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: GroupKind::Capture, // Use an appropriate GroupKind\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:36\n    |\n570 |         ast: Box::new(Ast::Literal(Literal::new('b'))), // Initialize as needed\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:17\n    |\n576 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:578:11\n    |\n578 |     kind: GroupKind::Capture,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:32\n    |\n579 |     ast: Box::new(Ast::Literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:19\n    |\n574 |     let visitor = MockVisitor::new();\n    |                   ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:567:17\n    |\n567 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         span: Span::new(0, 1), // Replace with valid Span\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: GroupKind::Capture, // Use an appropriate GroupKind\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:36\n    |\n570 |         ast: Box::new(Ast::Literal(Literal::new('b'))), // Initialize as needed\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:17\n    |\n576 |     let group = Group {\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:578:11\n    |\n578 |     kind: GroupKind::Capture,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:32\n    |\n579 |     ast: Box::new(Ast::Literal(Literal::new('b'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:574:19\n    |\n574 |     let visitor = MockVisitor::new();\n    |                   ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: *ast matches  is true\n",
        "// constraint: *ast matches Ast::Class(ast::Class::Bracketed(ref x)) is true\n",
        "// constraint: self.visit_class(x, visitor)? is Ok/Some\n",
        "// expected return value/type: Ok(match *ast {\n            Ast::Class(ast::Class::Bracketed(ref x)) => {\n                self.visit_class(x, visitor)?;\n                None\n            }\n            Ast::Repetition(ref x) => Some(Frame::Repetition(x)),\n            Ast::Group(ref x) => Some(Frame::Group(x)),\n            Ast::Concat(ref x) if x.asts.is_empty() => None,\n            Ast::Concat(ref x) => {\n                Some(Frame::Concat {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            Ast::Alternation(ref x) if x.asts.is_empty() => None,\n            Ast::Alternation(ref x) => {\n                Some(Frame::Alternation {\n                    head: &x.asts[0],\n                    tail: &x.asts[1..],\n                })\n            }\n            _ => None,\n        })\n"
      ],
      "input_infer": "Test input ranges: (Ast::Class(ast::Class::Bracketed(ref x)) with various character sets including empty, single character, and multiple characters; also include Repetition, Group, Concat with 0-3 child nodes, and Alternation with 0-3 child nodes).\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                "        span: Span::new(0, 0),",
                "        negated: false,",
                "        kind: ClassSet::Normal(vec![]),",
                "    }));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 0),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 0),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "        span: Span::new(0, 0),",
                  "        negated: false,",
                  "        kind: ClassSet::Normal(vec![]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 0),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "        span: Span::new(0, 0),",
                  "        negated: false,",
                  "        kind: ClassSet::Normal(vec![]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 0),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Normal(vec![]),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 0),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: ClassSet::Normal(vec![]),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Normal(vec![]),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 0),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: ClassSet::Normal(vec![]),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                "        span: Span::new(0, 1),",
                "        negated: false,",
                "        kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                "    }));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let frame = result.unwrap();",
                  "    assert!(frame.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "        span: Span::new(0, 1),",
                  "        negated: false,",
                  "        kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "        span: Span::new(0, 1),",
                  "        negated: false,",
                  "        kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 1),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let frame = result.unwrap();",
                  "    assert!(frame.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:37\n    |\n569 |         kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |                                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:577:33\n    |\n577 |     kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |                                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:19\n    |\n573 |     let visitor = MockVisitor::new();\n    |                   ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:569:37\n    |\n569 |         kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |                                     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:43\n    |\n574 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:577:33\n    |\n577 |     kind: ClassSet::Normal(vec![ClassSetItem::Literal('a')]),\n    |                                 ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:19\n    |\n573 |     let visitor = MockVisitor::new();\n    |                   ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                "        span: Span::new(0, 3),",
                "        negated: false,",
                "        kind: ClassSet::Normal(vec![",
                "            ClassSetItem::Literal('a'),",
                "            ClassSetItem::Literal('b'),",
                "            ClassSetItem::Literal('c'),",
                "        ]),",
                "    }));",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 3),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![",
                  "    ClassSetItem::Literal('a'),",
                  "    ClassSetItem::Literal('b'),",
                  "    ClassSetItem::Literal('c'),",
                  "    ]),",
                  "    }));",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 3),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![",
                  "    ClassSetItem::Literal('a'),",
                  "    ClassSetItem::Literal('b'),",
                  "    ClassSetItem::Literal('c'),",
                  "    ]),",
                  "    }));",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let frame = result.unwrap();",
                  "    assert!(frame.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "        span: Span::new(0, 3),",
                  "        negated: false,",
                  "        kind: ClassSet::Normal(vec![",
                  "            ClassSetItem::Literal('a'),",
                  "            ClassSetItem::Literal('b'),",
                  "            ClassSetItem::Literal('c'),",
                  "        ]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 3),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![",
                  "    ClassSetItem::Literal('a'),",
                  "    ClassSetItem::Literal('b'),",
                  "    ClassSetItem::Literal('c'),",
                  "    ]),",
                  "    }));",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "        span: Span::new(0, 3),",
                  "        negated: false,",
                  "        kind: ClassSet::Normal(vec![",
                  "            ClassSetItem::Literal('a'),",
                  "            ClassSetItem::Literal('b'),",
                  "            ClassSetItem::Literal('c'),",
                  "        ]),",
                  "    }));",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed {",
                  "    span: Span::new(0, 3),",
                  "    negated: false,",
                  "    kind: ClassSet::Normal(vec![",
                  "    ClassSetItem::Literal('a'),",
                  "    ClassSetItem::Literal('b'),",
                  "    ClassSetItem::Literal('c'),",
                  "    ]),",
                  "    }));",
                  "    let heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    let frame = result.unwrap();",
                  "    assert!(frame.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Normal(vec![\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:13\n    |\n570 |             ClassSetItem::Literal('a'),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |             ClassSetItem::Literal('b'),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |             ClassSetItem::Literal('c'),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:578:26\n    |\n578 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:43\n    |\n578 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 3),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     kind: ClassSet::Normal(vec![\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     ClassSetItem::Literal('a'),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     ClassSetItem::Literal('b'),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     ClassSetItem::Literal('c'),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |     let visitor = MockVisitor::new();\n    |                   ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:43\n    |\n566 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 3),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:569:15\n    |\n569 |         kind: ClassSet::Normal(vec![\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:570:13\n    |\n570 |             ClassSetItem::Literal('a'),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:571:13\n    |\n571 |             ClassSetItem::Literal('b'),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:572:13\n    |\n572 |             ClassSetItem::Literal('c'),\n    |             ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/visitor.rs:578:26\n    |\n578 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::Class;\n    |\n560 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/visitor.rs:578:43\n    |\n578 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed {\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:579:11\n    |\n579 |     span: Span::new(0, 3),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/visitor.rs:581:11\n    |\n581 |     kind: ClassSet::Normal(vec![\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:582:5\n    |\n582 |     ClassSetItem::Literal('a'),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:583:5\n    |\n583 |     ClassSetItem::Literal('b'),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSetItem`\n   --> regex-syntax/src/ast/visitor.rs:584:5\n    |\n584 |     ClassSetItem::Literal('c'),\n    |     ^^^^^^^^^^^^ use of undeclared type `ClassSetItem`\n    |\nhelp: consider importing this enum\n    |\n560 +    use ast::ClassSetItem;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:577:19\n    |\n577 |     let visitor = MockVisitor::new();\n    |                   ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Repetition(Repetition {",
                "        span: Span::new(0, 1),",
                "        op: RepetitionOp::Plus,",
                "        greedy: true,",
                "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                "    });",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = None;",
                  "    assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), expected_output);"
                ],
                [
                  "    let expected_output = None;",
                  "    assert!(visitor.called);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Repetition(Repetition {",
                  "        span: Span::new(0, 1),",
                  "        op: RepetitionOp::Plus,",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let expected_output = None;",
                  "    assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Repetition(Repetition {",
                  "        span: Span::new(0, 1),",
                  "        op: RepetitionOp::Plus,",
                  "        greedy: true,",
                  "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let expected_output = None;",
                  "    assert!(visitor.called);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let ast = Ast::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |         op: RepetitionOp::Plus,\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:36\n    |\n570 |         ast: Box::new(Ast::Literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:575:5\n    |\n575 |     assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), expected_output);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:575:5\n    |\n575 |     assert_eq!(heap_visitor.induct(&ast, &mut visitor).unwrap(), expected_output);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:31\n    |\n566 |     let ast = Ast::Repetition(Repetition {\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Repetition;\n    |\n560 +    use ast::Repetition;\n    |\n560 +    use ast::visitor::Frame::Repetition;\n    |\n560 +    use hir::HirKind::Repetition;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/visitor.rs:568:13\n    |\n568 |         op: RepetitionOp::Plus,\n    |             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:36\n    |\n570 |         ast: Box::new(Ast::Literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Group(Group {",
                "        span: Span::new(0, 1),",
                "        kind: GroupKind::Capture,",
                "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                "    });",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span::new(0, 1),",
                  "        kind: GroupKind::Capture,",
                  "        ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capture,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:26\n    |\n566 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 1),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:568:15\n    |\n568 |         kind: GroupKind::Capture,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:36\n    |\n569 |         ast: Box::new(Ast::Literal(Literal::from('a'))),\n    |                                    ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/visitor.rs:574:26\n    |\n574 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Group;\n    |\n560 +    use ast::Group;\n    |\n560 +    use ast::visitor::Frame::Group;\n    |\n560 +    use hir::Group;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:575:11\n    |\n575 |     span: Span::new(0, 1),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/visitor.rs:576:11\n    |\n576 |     kind: GroupKind::Capture,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n560 +    use ast::GroupKind;\n    |\n560 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:577:32\n    |\n577 |     ast: Box::new(Ast::Literal(Literal::from('a'))),\n    |                                ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:573:23\n    |\n573 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     Option<_>\n    |\nnote: the foreign item type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>` doesn't implement `PartialEq<Option<_>>`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/result.rs:527:1\n    |\n    = note: not implement `PartialEq<Option<_>>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:581:5\n    |\n581 |     assert_eq!(result, None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span::new(0, 2),",
                "        asts: vec![",
                "            Ast::Literal(Literal::from('a')),",
                "            Ast::Literal(Literal::from('b')),",
                "        ],",
                "    });",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast, visitor), Ok(Some(Frame::Concat {"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_empty_concat, visitor), Ok(None));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_repetition, visitor), Ok(Some(Frame::Repetition(&ast_repetition))));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_group, visitor), Ok(Some(Frame::Group(&ast_group))));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_empty_alternation, visitor), Ok(None));"
                ],
                [
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_alternation, visitor), Ok(Some(Frame::Alternation {"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast, visitor), Ok(Some(Frame::Concat {",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_empty_concat, visitor), Ok(None));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_repetition, visitor), Ok(Some(Frame::Repetition(&ast_repetition))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_group, visitor), Ok(Some(Frame::Group(&ast_group))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_empty_alternation, visitor), Ok(None));",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    head: &Ast::Literal(Literal::from('a')),",
                  "    tail: &[Ast::Literal(Literal::from('b'))],",
                  "    })));",
                  "    let ast_empty_concat = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_repetition = Ast::Repetition(Repetition {",
                  "    span: Span::new(0, 1),",
                  "    op: RepetitionOp::ZeroOrMore,",
                  "    greedy: true,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_group = Ast::Group(Group {",
                  "    span: Span::new(0, 1),",
                  "    kind: GroupKind::Capturing,",
                  "    ast: Box::new(Ast::Literal(Literal::from('a'))),",
                  "    });",
                  "    let ast_empty_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let ast_alternation = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    assert_eq!(heap_visitor.induct(&ast_alternation, visitor), Ok(Some(Frame::Alternation {",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/ast/visitor.rs:583:59\n    |\n564 | {\n    | - closing delimiter possibly meant for this\n...\n583 |     assert_eq!(heap_visitor.induct(&ast, visitor), Ok(Some(Frame::Concat {\n    |                                                           ^ unclosed delimiter\n584 | }\n585 | }\n    | ^ mismatched closing delimiter\n\nerror: this file contains an unclosed delimiter\n   --> regex-syntax/src/ast/visitor.rs:585:3\n    |\n559 | mod llmtests {\n    |              - unclosed delimiter\n...\n585 | }\n    |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:559:14\n    |\n559 | mod llmtests {\n    |              ^ unclosed delimiter\n...\n585 |     })));\n    |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:585:7\n    |\n585 |     })));\n    |      -^ unexpected closing delimiter\n    |      |\n    |      missing open `(` for this delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:559:14\n    |\n559 | mod llmtests {\n    |              ^ unclosed delimiter\n...\n585 |     })));\n    |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:585:7\n    |\n585 |     })));\n    |      -^ unexpected closing delimiter\n    |      |\n    |      missing open `(` for this delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:559:14\n    |\n559 | mod llmtests {\n    |              ^ unclosed delimiter\n...\n585 |     })));\n    |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:585:7\n    |\n585 |     })));\n    |      -^ unexpected closing delimiter\n    |      |\n    |      missing open `(` for this delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:559:14\n    |\n559 | mod llmtests {\n    |              ^ unclosed delimiter\n...\n585 |     })));\n    |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:585:7\n    |\n585 |     })));\n    |      -^ unexpected closing delimiter\n    |      |\n    |      missing open `(` for this delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:559:14\n    |\n559 | mod llmtests {\n    |              ^ unclosed delimiter\n...\n585 |     })));\n    |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `)`\n   --> regex-syntax/src/ast/visitor.rs:585:7\n    |\n585 |     })));\n    |      -^ unexpected closing delimiter\n    |      |\n    |      missing open `(` for this delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Concat(Concat {",
                "        span: Span::new(0, 0),",
                "        asts: vec![],",
                "    });",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "        span: Span::new(0, 0),",
                  "        asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Concat(Concat {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result, Ok(None));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:27\n    |\n566 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:27\n    |\n573 |     let ast = Ast::Concat(Concat {\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Ast::Concat;\n    |\n560 +    use ast::Concat;\n    |\n560 +    use ast::visitor::Frame::Concat;\n    |\n560 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:11\n    |\n574 |     span: Span::new(0, 0),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0369]: binary operation `==` cannot be applied to type `std::result::Result<Option<ast::visitor::Frame<'_>>, _>`\n   --> regex-syntax/src/ast/visitor.rs:579:5\n    |\n579 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |     std::result::Result<Option<ast::visitor::Frame<'_>>, _>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:579:5\n    |\n579 |     assert_eq!(result, Ok(None));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `std::result::Result<Option<ast::visitor::Frame<'_>>, _>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `std::result::Result<T, E>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::new(0, 2),",
                "        asts: vec![",
                "            Ast::Literal(Literal::from('a')),",
                "            Ast::Literal(Literal::from('b')),",
                "        ],",
                "    });",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::new(0, 2),",
                  "        asts: vec![",
                  "            Ast::Literal(Literal::from('a')),",
                  "            Ast::Literal(Literal::from('b')),",
                  "        ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 2),",
                  "    asts: vec![",
                  "    Ast::Literal(Literal::from('a')),",
                  "    Ast::Literal(Literal::from('b')),",
                  "    ],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert_eq!(result.unwrap(), None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:32\n    |\n566 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:26\n    |\n569 |             Ast::Literal(Literal::from('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:26\n    |\n570 |             Ast::Literal(Literal::from('b')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:32\n    |\n576 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n579 |     Ast::Literal(Literal::from('a')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:18\n    |\n580 |     Ast::Literal(Literal::from('b')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:32\n    |\n566 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 2),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:569:26\n    |\n569 |             Ast::Literal(Literal::from('a')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:570:26\n    |\n570 |             Ast::Literal(Literal::from('b')),\n    |                          ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:576:32\n    |\n576 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:577:11\n    |\n577 |     span: Span::new(0, 2),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:579:18\n    |\n579 |     Ast::Literal(Literal::from('a')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/visitor.rs:580:18\n    |\n580 |     Ast::Literal(Literal::from('b')),\n    |                  ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Literal;\n    |\n560 +    use hir::Literal;\n    |\n560 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:575:23\n    |\n575 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<ast::visitor::Frame<'_>>`\n   --> regex-syntax/src/ast/visitor.rs:585:5\n    |\n585 |     assert_eq!(result.unwrap(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     Option<ast::visitor::Frame<'_>>\n    |     Option<ast::visitor::Frame<'_>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::visitor::Frame<'_>`\n   --> regex-syntax/src/ast/visitor.rs:147:1\n    |\n147 | enum Frame<'a> {\n    | ^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(PartialEq)]`\n    |\n147 + #[derive(PartialEq)]\n148 | enum Frame<'a> {\n    |\n\nerror[E0277]: `ast::visitor::Frame<'_>` doesn't implement `Debug`\n   --> regex-syntax/src/ast/visitor.rs:585:5\n    |\n585 |     assert_eq!(result.unwrap(), None);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `ast::visitor::Frame<'_>` cannot be formatted using `{:?}`\n    |\n    = help: the trait `Debug` is not implemented for `ast::visitor::Frame<'_>`, which is required by `Option<ast::visitor::Frame<'_>>: Debug`\n    = note: add `#[derive(Debug)]` to `ast::visitor::Frame<'_>` or manually `impl Debug for ast::visitor::Frame<'_>`\n    = help: the trait `Debug` is implemented for `Option<T>`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `ast::visitor::Frame<'_>` with `#[derive(Debug)]`\n    |\n147 + #[derive(Debug)]\n148 | enum Frame<'a> {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut visitor = MockVisitor::new();",
                "    let ast = Ast::Alternation(Alternation {",
                "        span: Span::new(0, 0),",
                "        asts: vec![],",
                "    });",
                "    let mut heap_visitor = HeapVisitor::new();",
                "    heap_visitor.induct(&ast, &mut visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::new(0, 0),",
                  "        asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "        span: Span::new(0, 0),",
                  "        asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    heap_visitor.induct(&ast, &mut visitor);",
                  "    let mut visitor = MockVisitor::new();",
                  "    let ast = Ast::Alternation(Alternation {",
                  "    span: Span::new(0, 0),",
                  "    asts: vec![],",
                  "    });",
                  "    let mut heap_visitor = HeapVisitor::new();",
                  "    let result = heap_visitor.induct(&ast, &mut visitor);",
                  "    assert!(result.unwrap().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:32\n    |\n566 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:32\n    |\n573 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:11\n    |\n574 |     span: Span::new(0, 0),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/visitor.rs:561:8\n    |\n561 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:566:32\n    |\n566 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:567:15\n    |\n567 |         span: Span::new(0, 0),\n    |               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/visitor.rs:573:32\n    |\n573 |     let ast = Ast::Alternation(Alternation {\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n560 +    use ast::Alternation;\n    |\n560 +    use ast::Ast::Alternation;\n    |\n560 +    use ast::visitor::Frame::Alternation;\n    |\n560 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/visitor.rs:574:11\n    |\n574 |     span: Span::new(0, 0),\n    |           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n560 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:565:23\n    |\n565 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nerror[E0433]: failed to resolve: use of undeclared type `MockVisitor`\n   --> regex-syntax/src/ast/visitor.rs:572:23\n    |\n572 |     let mut visitor = MockVisitor::new();\n    |                       ^^^^^^^^^^^ use of undeclared type `MockVisitor`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}