{
  "name": "regex_syntax::ast::print::<ast::print::Writer<'p, W> as ast::visitor::Visitor>::visit_post",
  "name_with_impl": "regex_syntax::ast::print::{impl#3}::visit_post",
  "mod_info": {
    "name": "ast::print",
    "loc": "regex-syntax/src/ast/mod.rs:22:1:22:15"
  },
  "visible": true,
  "loc": "regex-syntax/src/ast/print.rs:102:5:121:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Concat(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "Ast::Concat(_)\n",
      "answers": [
        {
          "uses": [
            "use ast::Ast;",
            "use ast::Literal;",
            "use ast::Concat;",
            "use ast::Span;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{Ast, Concat};",
                "    let span = Span::new(0, 1);",
                "    let concat_ast = Concat {",
                "        span,",
                "        expressions: vec![],",
                "    };",
                "    let ast_input = Ast::Concat(concat_ast);",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast_input);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 1);",
                  "    let concat_ast = Concat {",
                  "    span,",
                  "    expressions: vec![],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let result = writer.visit_post(&ast_input);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{Ast, Concat};",
                  "    let span = Span::new(0, 1);",
                  "    let concat_ast = Concat {",
                  "        span,",
                  "        expressions: vec![],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast_input);",
                  "    let span = Span::new(0, 1);",
                  "    let concat_ast = Concat {",
                  "    span,",
                  "    expressions: vec![],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let result = writer.visit_post(&ast_input);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:595:16\n    |\n595 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Concat` has no field named `expressions`\n   --> regex-syntax/src/ast/print.rs:598:9\n    |\n598 |         expressions: vec![],\n    |         ^^^^^^^^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `expressions`\n   --> regex-syntax/src/ast/print.rs:607:5\n    |\n607 |     expressions: vec![],\n    |     ^^^^^^^^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `asts`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{Ast, Concat};",
                "    let span = Span::new(0, 0);",
                "    let concat_ast = Concat {",
                "        span,",
                "        expressions: vec![],",
                "    };",
                "    let ast_input = Ast::Concat(concat_ast);",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast_input);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 0);",
                  "    let concat_ast = Concat {",
                  "    span,",
                  "    expressions: vec![],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let result = writer.visit_post(&ast_input);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{Ast, Concat};",
                  "    let span = Span::new(0, 0);",
                  "    let concat_ast = Concat {",
                  "        span,",
                  "        expressions: vec![],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast_input);",
                  "    let span = Span::new(0, 0);",
                  "    let concat_ast = Concat {",
                  "    span,",
                  "    expressions: vec![],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let result = writer.visit_post(&ast_input);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:595:16\n    |\n595 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0560]: struct `ast::Concat` has no field named `expressions`\n   --> regex-syntax/src/ast/print.rs:598:9\n    |\n598 |         expressions: vec![],\n    |         ^^^^^^^^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `asts`\n\nerror[E0560]: struct `ast::Concat` has no field named `expressions`\n   --> regex-syntax/src/ast/print.rs:607:5\n    |\n607 |     expressions: vec![],\n    |     ^^^^^^^^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `asts`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{Ast, Concat, Literal, Span};",
                "    let span = Span::new(0, 1);",
                "    let literal = Literal {",
                "        span,",
                "        kind: LiteralKind::Verbatim,",
                "        c: 'a',",
                "    };",
                "    let concat_ast = Concat {",
                "        span: Span::new(0, 1),",
                "        expressions: vec![Ast::Literal(literal)],",
                "    };",
                "    let ast_input = Ast::Concat(concat_ast);",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast_input);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 1);",
                  "    let literal = Literal {",
                  "    span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    };",
                  "    let concat_ast = Concat {",
                  "    span: Span::new(0, 1),",
                  "    expressions: vec![Ast::Literal(literal)],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast_input), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{Ast, Concat, Literal, Span};",
                  "    let span = Span::new(0, 1);",
                  "    let literal = Literal {",
                  "        span,",
                  "        kind: LiteralKind::Verbatim,",
                  "        c: 'a',",
                  "    };",
                  "    let concat_ast = Concat {",
                  "        span: Span::new(0, 1),",
                  "        expressions: vec![Ast::Literal(literal)],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast_input);",
                  "    let span = Span::new(0, 1);",
                  "    let literal = Literal {",
                  "    span,",
                  "    kind: LiteralKind::Verbatim,",
                  "    c: 'a',",
                  "    };",
                  "    let concat_ast = Concat {",
                  "    span: Span::new(0, 1),",
                  "    expressions: vec![Ast::Literal(literal)],",
                  "    };",
                  "    let ast_input = Ast::Concat(concat_ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast_input), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: LiteralKind::Verbatim,\n    |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:612:11\n    |\n612 |     kind: LiteralKind::Verbatim,\n    |           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/print.rs:595:16\n    |\n595 |     let span = Span::new(0, 1);\n    |                ^^^^^^^^^ -  - expected `Position`, found integer\n    |                          |\n    |                          expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/print.rs:602:15\n    |\n602 |         span: Span::new(0, 1),\n    |               ^^^^^^^^^ -  - expected `Position`, found integer\n    |                         |\n    |                         expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0560]: struct `ast::Concat` has no field named `expressions`\n   --> regex-syntax/src/ast/print.rs:603:9\n    |\n603 |         expressions: vec![Ast::Literal(literal)],\n    |         ^^^^^^^^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `asts`\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/print.rs:609:16\n    |\n609 |     let span = Span::new(0, 1);\n    |                ^^^^^^^^^ -  - expected `Position`, found integer\n    |                          |\n    |                          expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0308]: arguments to this function are incorrect\n   --> regex-syntax/src/ast/print.rs:616:11\n    |\n616 |     span: Span::new(0, 1),\n    |           ^^^^^^^^^ -  - expected `Position`, found integer\n    |                     |\n    |                     expected `Position`, found integer\n    |\nnote: associated function defined here\n   --> regex-syntax/src/ast/mod.rs:396:12\n    |\n396 |     pub fn new(start: Position, end: Position) -> Span {\n    |            ^^^ ---------------  -------------\n\nerror[E0560]: struct `ast::Concat` has no field named `expressions`\n   --> regex-syntax/src/ast/print.rs:617:5\n    |\n617 |     expressions: vec![Ast::Literal(literal)],\n    |     ^^^^^^^^^^^ `ast::Concat` does not have this field\n    |\n    = note: available fields are: `asts`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0560.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Alternation(_) is true\n",
        "// constraint: *ast matches Ast::Alternation(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0, 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let ast = Ast::Empty(Span);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    assert!(output.contains(\"(?\"));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \".\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"^\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\d\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\pa\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"]\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    assert!(output.contains(\"(?\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \".\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"^\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\pa\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:90\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:90\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:93\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:90\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:93\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:60\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:616:127\n    |\n616 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:143\n    |\n616 | ...dy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:616:155\n    |\n616 | ...w(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:90\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:93\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:60\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:616:127\n    |\n616 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:143\n    |\n616 | ...dy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:616:155\n    |\n616 | ...w(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:618:40\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:618:52\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                                    ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:618:99\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                                                                                   ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:90\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:93\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:60\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:616:127\n    |\n616 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:143\n    |\n616 | ...dy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:616:155\n    |\n616 | ...w(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:618:40\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:618:52\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                                    ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:618:99\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                                                                                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:620:50\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:66\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:620:78\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:620:32\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 39 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:56\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:60\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:68\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:90\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:93\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                             ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:60\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { s...\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:616:127\n    |\n616 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:143\n    |\n616 | ...dy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:616:155\n    |\n616 | ...w(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:618:40\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:618:52\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                                    ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:618:99\n    |\n618 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });\n    |                                                                                                   ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:620:50\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |                                                  ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:66\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:620:78\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:622:45\n    |\n622 |     let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);\n    |                                             ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:622:61\n    |\n622 |     let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);\n    |                                                             ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:622:73\n    |\n622 |     let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);\n    |                                                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:620:32\n    |\n620 |     let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:622:27\n    |\n622 |     let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);\n    |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 43 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let flags = SetFlags { span: Span, flags: Flags };",
                "    let ast = Ast::Flags(flags);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert_eq!(output, \"(?flags)\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(output, \"a\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    assert_eq!(output, \".\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(output, \"^\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    assert_eq!(output, r\"\\d\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    assert_eq!(output, r\"\\pc\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    assert_eq!(output, \"]\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(Vec::new());",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(Vec::new());",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert_eq!(output, \"(?flags)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    assert_eq!(output, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    assert_eq!(output, \".\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(output, \"^\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    assert_eq!(output, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    assert_eq!(output, r\"\\pc\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(Vec::new());",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Vec::new());",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(Vec::new());",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:17\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:31\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:43\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:88\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:17\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:31\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:43\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:88\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:17\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:31\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:43\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:88\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:636:32\n    |\n636 |     let ast = Ast::Alternation(Vec::new());\n    |               ---------------- ^^^^^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:17\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:31\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:43\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:88\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:636:32\n    |\n636 |     let ast = Ast::Alternation(Vec::new());\n    |               ---------------- ^^^^^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:17\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:31\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:43\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:88\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:636:32\n    |\n636 |     let ast = Ast::Alternation(Vec::new());\n    |               ---------------- ^^^^^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:639:27\n    |\n639 |     let ast = Ast::Concat(Vec::new());\n    |               ----------- ^^^^^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 36 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^\n    |\nhelp: a local variable with a similar name exists (notice the capitalization difference)\n    |\n601 |     let flags = SetFlags { span: Span, flags: flags };\n    |                                               ~~~~~\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:19\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:35\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:47\n    |\n605 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:24\n    |\n609 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:21\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:39\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:51\n    |\n612 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:25\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:46\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:74\n    |\n620 |     let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:27\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:50\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:624:78\n    |\n624 |     let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:625:26\n    |\n625 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:22\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:41\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:51\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:116\n    |\n628 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:17\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:31\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:43\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:88\n    |\n632 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:636:32\n    |\n636 |     let ast = Ast::Alternation(Vec::new());\n    |               ---------------- ^^^^^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:639:27\n    |\n639 |     let ast = Ast::Concat(Vec::new());\n    |               ----------- ^^^^^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 36 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"(?...)\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"^\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\d\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\Pc\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \".\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"(?...)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"^\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\Pc\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \".\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:626:48\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:626:32\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:626:48\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:630:22\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:41\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:630:51\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:116\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:626:32\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 27 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:626:48\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:630:22\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:41\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:630:51\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:116\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:635:25\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:46\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:635:73\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                         ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:636:26\n    |\n636 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:626:32\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 31 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:626:48\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:630:22\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:41\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:630:51\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:116\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:635:25\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:46\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:635:73\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                         ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:636:26\n    |\n636 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:640:24\n    |\n640 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:626:32\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:626:48\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:630:22\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:41\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:630:51\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:116\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:635:25\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:46\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:635:73\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                         ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:636:26\n    |\n636 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:640:24\n    |\n640 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:644:26\n    |\n644 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:626:32\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:47\n    |\n596 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:601:19\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:35\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:601:47\n    |\n601 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:39\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:51\n    |\n611 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:22\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:40\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:617:26\n    |\n617 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:621:17\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:31\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:621:43\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:621:90\n    |\n621 |     let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                          ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:626:48\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:630:22\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:41\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:630:51\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:116\n    |\n630 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:635:25\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:46\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:635:73\n    |\n635 |     let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };\n    |                                                                         ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:636:26\n    |\n636 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:640:24\n    |\n640 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:644:26\n    |\n644 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:648:27\n    |\n648 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:648:50\n    |\n648 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:648:78\n    |\n648 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:649:26\n    |\n649 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:626:32\n    |\n626 |     let ast = Ast::Alternation(vec![Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let ast = Ast::Dot(Span);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"(flags)\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"^\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\d\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\pa\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"]\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Alternation);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Alternation);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(Concat);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"(flags)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"^\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, r\"\\pa\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Alternation);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Empty(Span);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(Alternation);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(Concat);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:41\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:62\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:90\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:41\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:62\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:90\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:624:26\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:43\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:66\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ClassSet` in this scope\n   --> regex-syntax/src/ast/print.rs:624:93\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                                             ^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:41\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:62\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:90\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:624:26\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:43\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:66\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ClassSet` in this scope\n   --> regex-syntax/src/ast/print.rs:624:93\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                                             ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:31\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:50\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:60\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:123\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                                                           ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 28 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:41\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:62\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:90\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:624:26\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:43\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:66\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ClassSet` in this scope\n   --> regex-syntax/src/ast/print.rs:624:93\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                                             ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:31\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:50\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:60\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:123\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                                                           ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:26\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:40\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:52\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                                    ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:95\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                               ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:41\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:62\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:90\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:624:26\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:43\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:66\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ClassSet` in this scope\n   --> regex-syntax/src/ast/print.rs:624:93\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                                             ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:31\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:50\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:60\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:123\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                                                           ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:26\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:40\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:52\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                                    ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:95\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                               ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Alternation` in this scope\n   --> regex-syntax/src/ast/print.rs:636:32\n    |\n636 |     let ast = Ast::Alternation(Alternation);\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n589 +    use ast::Ast::Alternation;\n    |\n589 +    use hir::HirKind::Alternation;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span);\n    |                          ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:56\n    |\n604 |     let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });\n    |                                                        ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:28\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:608:44\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:608:56\n    |\n608 |     let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                        ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:612:30\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:612:48\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:612:60\n    |\n612 |     let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });\n    |                                                            ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:616:38\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:56\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:616:68\n    |\n616 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:620:41\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:62\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:90\n    |\n620 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:624:26\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:624:43\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:624:66\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ClassSet` in this scope\n   --> regex-syntax/src/ast/print.rs:624:93\n    |\n624 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));\n    |                                                                                             ^^^^^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:628:31\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:50\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:628:60\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                            ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:628:123\n    |\n628 |     let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                                                           ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:632:26\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:40\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:632:52\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                                    ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:632:95\n    |\n632 |     let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });\n    |                                                                                               ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Alternation` in this scope\n   --> regex-syntax/src/ast/print.rs:636:32\n    |\n636 |     let ast = Ast::Alternation(Alternation);\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n589 +    use ast::Ast::Alternation;\n    |\n589 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0425]: cannot find value `Concat` in this scope\n   --> regex-syntax/src/ast/print.rs:640:27\n    |\n640 |     let ast = Ast::Concat(Concat);\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these tuple variants\n    |\n589 +    use ast::Ast::Concat;\n    |\n589 +    use hir::HirKind::Concat;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"^\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"(?)\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"a\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \".\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"\\d\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"\\pb\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \")\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"\");"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(literal)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"^\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"(?)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \".\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"\\pb\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let flags = SetFlags { span: Span, flags: Flags };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Dot(Span);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(vec![Ast::Literal(literal)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:625:25\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:46\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:625:74\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:626:26\n    |\n626 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:625:25\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:46\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:625:74\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:626:26\n    |\n626 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:630:27\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:50\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:630:78\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:631:26\n    |\n631 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:625:25\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:46\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:625:74\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:626:26\n    |\n626 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:630:27\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:50\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:630:78\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:631:26\n    |\n631 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:635:22\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:41\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:635:51\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:625:25\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:46\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:625:74\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:626:26\n    |\n626 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:630:27\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:50\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:630:78\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:631:26\n    |\n631 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:635:22\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:41\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:635:51\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:640:17\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:640:31\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:640:43\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 32 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:625:25\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:46\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:625:74\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:626:26\n    |\n626 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:630:27\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:50\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:630:78\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:631:26\n    |\n631 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:635:22\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:41\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:635:51\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:640:17\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:640:31\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:640:43\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:645:32\n    |\n645 |     let ast = Ast::Alternation(vec![Ast::Literal(literal)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };\n    |                                                   ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Flags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:47\n    |\n606 |     let flags = SetFlags { span: Span, flags: Flags };\n    |                                               ^^^^^ not found in this scope\n    |\nhelp: consider importing this tuple variant\n    |\n589 +    use ast::Ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:19\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:611:35\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:47\n    |\n611 |     let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:616:24\n    |\n616 |     let ast = Ast::Dot(Span);\n    |                        ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:620:22\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:620:40\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:620:52\n    |\n620 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:26\n    |\n621 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:625:25\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:625:46\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:625:74\n    |\n625 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:626:26\n    |\n626 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:630:27\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:630:50\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:630:78\n    |\n630 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:631:26\n    |\n631 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:635:22\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:635:41\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:635:51\n    |\n635 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:640:17\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:640:31\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:640:43\n    |\n640 |     let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:645:32\n    |\n645 |     let ast = Ast::Alternation(vec![Ast::Literal(literal)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:649:27\n    |\n649 |     let ast = Ast::Concat(vec![Ast::Literal(literal)]);\n    |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                "    let ast = Ast::Class(Class::Perl(class_perl));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:40\n    |\n596 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:596:52\n    |\n596 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:601:22\n    |\n601 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:40\n    |\n601 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:601:52\n    |\n601 |     let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };\n    |                                                    ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).expect(\"Expected result to be Ok(())\");",
                  "    assert_eq!(output, r\"\\pa\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast).expect(\"Expected result to be Ok(())\");",
                  "    assert_eq!(output, r\"\\pa\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:74\n    |\n596 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:25\n    |\n601 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:46\n    |\n601 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:74\n    |\n601 |     let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:78\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:601:27\n    |\n601 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:50\n    |\n601 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:601:78\n    |\n601 |     let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };\n    |                                                                              ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                "    let ast = Ast::Repetition(repetition);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:51\n    |\n596 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:116\n    |\n596 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:601:22\n    |\n601 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:41\n    |\n601 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                         ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:601:51\n    |\n601 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                   ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:116\n    |\n601 |     let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                                                    ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                "    let ast = Ast::Group(group);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(...);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(...);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(output.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(...);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(...);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(output.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast = Ast::Alternation(...);\n    |                                ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n601 |     let ast = Ast::Alternation(..);\n    |                                ~~\nhelp: or `..=` for an inclusive range\n    |\n601 |     let ast = Ast::Alternation(..=);\n    |                                ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast = Ast::Alternation(...);\n    |                                ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n601 -     let ast = Ast::Alternation(...);\n601 +     let ast = Ast::Alternation(..);\n    |\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:31\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:596:43\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:88\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0586.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unexpected token: `...`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast = Ast::Alternation(...);\n    |                                ^^^\n    |\nhelp: use `..` for an exclusive range\n    |\n601 |     let ast = Ast::Alternation(..);\n    |                                ~~\nhelp: or `..=` for an inclusive range\n    |\n601 |     let ast = Ast::Alternation(..=);\n    |                                ~~~\n\nerror[E0586]: inclusive range with no end\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast = Ast::Alternation(...);\n    |                                ^^^\n    |\n    = note: inclusive ranges must be bounded at the end (`..=b` or `a..=b`)\nhelp: use `..` instead\n    |\n601 -     let ast = Ast::Alternation(...);\n601 +     let ast = Ast::Alternation(..);\n    |\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:31\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:596:43\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:88\n    |\n596 |     let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };\n    |                                                                                        ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0586.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:48\n    |\n596 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:66\n    |\n596 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:48\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:66\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                                  ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:600:32\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    writer.visit_post(&ast);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:43\n    |\n596 |     let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:61\n    |\n596 |     let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                             ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:48\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:66\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                                  ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:600:32\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:43\n    |\n596 |     let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                           ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:61\n    |\n596 |     let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                             ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:48\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:66\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |                                                                  ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |               ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Concat`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:600:32\n    |\n600 |     let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);\n    |               ---------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Alternation`, found `Vec<Ast>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<ast::Ast>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Group(ref x) is true\n",
        "// constraint: *ast matches Ast::Group(ref x) is true\n"
      ],
      "input_infer": "0 <= ast.span.start < ast.span.end <= 10000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Group(Group {",
                "        span: Span { start: 0, end: 10 },",
                "        kind: GroupKind::Simple,",
                "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                "    });",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 0, end: 10 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    assert_eq!(writer.wtr, \")\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 0, end: 10 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    assert_eq!(writer.printer, &Printer { _priv: () });"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span { start: 0, end: 10 },",
                  "        kind: GroupKind::Simple,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 0, end: 10 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    assert_eq!(writer.wtr, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span { start: 0, end: 10 },",
                  "        kind: GroupKind::Simple,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 0, end: 10 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    assert_eq!(writer.printer, &Printer { _priv: () });",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 0, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: GroupKind::Simple,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:34\n    |\n599 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:11\n    |\n605 |     span: Span { start: 0, end: 10 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:606:11\n    |\n606 |     kind: GroupKind::Simple,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:30\n    |\n607 |     ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 0, end: 10 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: GroupKind::Simple,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:34\n    |\n599 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:11\n    |\n605 |     span: Span { start: 0, end: 10 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:606:11\n    |\n606 |     kind: GroupKind::Simple,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:30\n    |\n607 |     ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `&mut ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:609:5\n    |\n609 |     assert_eq!(writer.printer, &Printer { _priv: () });\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     &mut ast::print::Printer\n    |     &ast::print::Printer\n    |\nnote: an implementation of `PartialEq` might be missing for `ast::print::Printer`\n   --> regex-syntax/src/ast/print.rs:59:1\n    |\n59  | pub struct Printer {\n    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Group(Group {",
                "        span: Span { start: 0, end: 9999 },",
                "        kind: GroupKind::Simple,",
                "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                "    });",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group { span: Span { start: 0, end: 9999 }, kind: GroupKind::Simple, ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })), });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span { start: 0, end: 9999 },",
                  "        kind: GroupKind::Simple,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group { span: Span { start: 0, end: 9999 }, kind: GroupKind::Simple, ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })), });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 0, end: 9999 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: GroupKind::Simple,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:34\n    |\n599 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Group(Group { span: Span { start: 0, end: 9999 }, kind: GroupKind::Simple, ast: Box::new(Ast::Empty(Span { start: 0, e...\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast = Ast::Group(Group { span: Span { start: 0, end: 9999 }, kind: GroupKind::Simple, ast: Box::new(Ast::Empty(Span { start: 0, e...\n    |                                        ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast = Ast::Group(Group { span: Span { start: 0, end: 9999 }, kind: GroupKind::Simple, ast: Box::new(Ast::Empty(Span { start: 0, e...\n    |                                                                            ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:120\n    |\n604 | ...}, kind: GroupKind::Simple, ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })), });\n    |                                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Group(Group {",
                "        span: Span { start: 9999, end: 10000 },",
                "        kind: GroupKind::Simple,",
                "        ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                "    });",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 9999, end: 10000 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                  "    });",
                  "    assert_eq!(writer.visit_post(&ast).unwrap(), ());"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 9999, end: 10000 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                  "    });",
                  "    assert_eq!(writer.wtr, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span { start: 9999, end: 10000 },",
                  "        kind: GroupKind::Simple,",
                  "        ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                  "    });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 9999, end: 10000 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                  "    });",
                  "    assert_eq!(writer.visit_post(&ast).unwrap(), ());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span { start: 9999, end: 10000 },",
                  "        kind: GroupKind::Simple,",
                  "        ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                  "    });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 9999, end: 10000 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),",
                  "    });",
                  "    assert_eq!(writer.wtr, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 9999, end: 10000 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: GroupKind::Simple,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:34\n    |\n599 |         ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),\n    |                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:11\n    |\n605 |     span: Span { start: 9999, end: 10000 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:606:11\n    |\n606 |     kind: GroupKind::Simple,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:30\n    |\n607 |     ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),\n    |                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 9999, end: 10000 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: GroupKind::Simple,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:34\n    |\n599 |         ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),\n    |                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:11\n    |\n605 |     span: Span { start: 9999, end: 10000 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:606:11\n    |\n606 |     kind: GroupKind::Simple,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:607:30\n    |\n607 |     ast: Box::new(Ast::Empty(Span { start: 9999, end: 9999 })),\n    |                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Group(Group {",
                "        span: Span { start: 10, end: 0 }, // Invalid because start >= end",
                "        kind: GroupKind::Simple,",
                "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                "    });",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 10, end: 0 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    assert!(writer.visit_post(&ast).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Group(Group {",
                  "        span: Span { start: 10, end: 0 }, // Invalid because start >= end",
                  "        kind: GroupKind::Simple,",
                  "        ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group {",
                  "    span: Span { start: 10, end: 0 },",
                  "    kind: GroupKind::Simple,",
                  "    ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),",
                  "    });",
                  "    assert!(writer.visit_post(&ast).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         span: Span { start: 10, end: 0 }, // Invalid because start >= end\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:599:15\n    |\n599 |         kind: GroupKind::Simple,\n    |               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:34\n    |\n600 |         ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:603:26\n    |\n603 |     let ast = Ast::Group(Group {\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:604:11\n    |\n604 |     span: Span { start: 10, end: 0 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:605:11\n    |\n605 |     kind: GroupKind::Simple,\n    |           ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:30\n    |\n606 |     ast: Box::new(Ast::Empty(Span { start: 0, end: 0 })),\n    |                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n",
        "// constraint: *ast matches Ast::Repetition(ref x) is true\n"
      ],
      "input_infer": "0 <= x.span.start <= x.span.end <= 1000, x.greedy in [true, false], x.op.kind in [ZeroOrOne, ZeroOrMore, OneOrMore], x.ast is valid Ast variant\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let repetition = ast::Repetition {",
                "        span: Span { start: 0, end: 1 },",
                "        op: ast::RepetitionOp { kind: ast::RepetitionKind::ZeroOrMore },",
                "        greedy: true,",
                "        ast: Box::new(ast::Ast::Empty(Span { start: 0, end: 0 })),",
                "    };",
                "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "    span: Span { start: 0, end: 1 },",
                  "    op: ast::RepetitionOp { kind: ast::RepetitionKind::ZeroOrMore },",
                  "    greedy: true,",
                  "    ast: Box::new(ast::Ast::Empty(Span { start: 0, end: 0 })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    assert_eq!(writer, \"*\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "        span: Span { start: 0, end: 1 },",
                  "        op: ast::RepetitionOp { kind: ast::RepetitionKind::ZeroOrMore },",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Empty(Span { start: 0, end: 0 })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "    span: Span { start: 0, end: 1 },",
                  "    op: ast::RepetitionOp { kind: ast::RepetitionKind::ZeroOrMore },",
                  "    greedy: true,",
                  "    ast: Box::new(ast::Ast::Empty(Span { start: 0, end: 0 })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    assert_eq!(writer, \"*\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 0, end: 1 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:39\n    |\n600 |         ast: Box::new(ast::Ast::Empty(Span { start: 0, end: 0 })),\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:11\n    |\n606 |     span: Span { start: 0, end: 1 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:35\n    |\n609 |     ast: Box::new(ast::Ast::Empty(Span { start: 0, end: 0 })),\n    |                                   ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:598:13\n    |\n598 |         op: ast::RepetitionOp { kind: ast::RepetitionKind::ZeroOrMore },\n    |             ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:607:9\n    |\n607 |     op: ast::RepetitionOp { kind: ast::RepetitionKind::ZeroOrMore },\n    |         ^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let repetition = ast::Repetition {",
                "        span: Span { start: 1, end: 2 },",
                "        op: ast::RepetitionOp { kind: ast::RepetitionKind::OneOrMore },",
                "        greedy: false,",
                "        ast: Box::new(ast::Ast::Literal(ast::Literal { span: Span { start: 1, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' })),",
                "    };",
                "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "    span: Span { start: 1, end: 2 },",
                  "    op: ast::RepetitionOp { kind: ast::RepetitionKind::OneOrMore },",
                  "    greedy: false,",
                  "    ast: Box::new(ast::Ast::Literal(ast::Literal { span: Span { start: 1, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition)).unwrap();",
                  "    assert_eq!(writer, \"a+\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "        span: Span { start: 1, end: 2 },",
                  "        op: ast::RepetitionOp { kind: ast::RepetitionKind::OneOrMore },",
                  "        greedy: false,",
                  "        ast: Box::new(ast::Ast::Literal(ast::Literal { span: Span { start: 1, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "    span: Span { start: 1, end: 2 },",
                  "    op: ast::RepetitionOp { kind: ast::RepetitionKind::OneOrMore },",
                  "    greedy: false,",
                  "    ast: Box::new(ast::Ast::Literal(ast::Literal { span: Span { start: 1, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition)).unwrap();",
                  "    assert_eq!(writer, \"a+\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 1, end: 2 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:62\n    |\n600 |         ast: Box::new(ast::Ast::Literal(ast::Literal { span: Span { start: 1, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' })),\n    |                                                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:606:11\n    |\n606 |     span: Span { start: 1, end: 2 },\n    |           ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:609:58\n    |\n609 |     ast: Box::new(ast::Ast::Literal(ast::Literal { span: Span { start: 1, end: 1 }, kind: ast::LiteralKind::Verbatim, c: 'a' })),\n    |                                                          ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:598:13\n    |\n598 |         op: ast::RepetitionOp { kind: ast::RepetitionKind::OneOrMore },\n    |             ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:607:9\n    |\n607 |     op: ast::RepetitionOp { kind: ast::RepetitionKind::OneOrMore },\n    |         ^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let repetition = ast::Repetition {",
                "        span: Span { start: 2, end: 5 },",
                "        op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },",
                "        greedy: true,",
                "        ast: Box::new(ast::Ast::Assertion(ast::Assertion { span: Span { start: 2, end: 2 }, kind: ast::AssertionKind::WordBoundary })),",
                "    };",
                "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                "}"
              ],
              "oracles": [
                [
                  "    writer.clear();",
                  "    let expected_output = \"2, 4\";",
                  "    assert_eq!(writer, expected_output);"
                ],
                [
                  "    writer.clear();",
                  "    let expected_output = \"2, 4\";",
                  "    assert!(visitor.finish().is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "        span: Span { start: 2, end: 5 },",
                  "        op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Assertion(ast::Assertion { span: Span { start: 2, end: 2 }, kind: ast::AssertionKind::WordBoundary })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    writer.clear();",
                  "    let expected_output = \"2, 4\";",
                  "    assert_eq!(writer, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "        span: Span { start: 2, end: 5 },",
                  "        op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },",
                  "        greedy: true,",
                  "        ast: Box::new(ast::Ast::Assertion(ast::Assertion { span: Span { start: 2, end: 2 }, kind: ast::AssertionKind::WordBoundary })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    writer.clear();",
                  "    let expected_output = \"2, 4\";",
                  "    assert!(visitor.finish().is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 2, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0574]: expected struct, variant or union type, found enum `ast::RepetitionRange`\n    --> regex-syntax/src/ast/print.rs:598:66\n     |\n598  |         op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },\n     |                                                                  ^^^^^---------------\n     |                                                                       |\n     |                                                                       help: a struct with a similar name exists: `Repetition`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | pub struct Repetition {\n     | --------------------- similarly named struct `Repetition` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:66\n    |\n600 |         ast: Box::new(ast::Ast::Assertion(ast::Assertion { span: Span { start: 2, end: 2 }, kind: ast::AssertionKind::WordBoundary })),\n    |                                                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:598:13\n    |\n598 |         op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },\n    |             ^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0574.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 2, end: 5 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0574]: expected struct, variant or union type, found enum `ast::RepetitionRange`\n    --> regex-syntax/src/ast/print.rs:598:66\n     |\n598  |         op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },\n     |                                                                  ^^^^^---------------\n     |                                                                       |\n     |                                                                       help: a struct with a similar name exists: `Repetition`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | pub struct Repetition {\n     | --------------------- similarly named struct `Repetition` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:66\n    |\n600 |         ast: Box::new(ast::Ast::Assertion(ast::Assertion { span: Span { start: 2, end: 2 }, kind: ast::AssertionKind::WordBoundary })),\n    |                                                                  ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:598:13\n    |\n598 |         op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 2, end: 4 }) },\n    |             ^^^^^^^^^^^^^^^^^ missing `span`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0574.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut writer = String::new();",
                "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                "    let repetition = ast::Repetition {",
                "        span: Span { start: 3, end: 6 },",
                "        op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) },",
                "        greedy: false,",
                "        ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })),",
                "    };",
                "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition { span: Span { start: 3, end: 6 }, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) }, greedy: false, ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })) };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition)).unwrap();",
                  "    assert_eq!(writer, \".*?\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition {",
                  "        span: Span { start: 3, end: 6 },",
                  "        op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) },",
                  "        greedy: false,",
                  "        ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })),",
                  "    };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition));",
                  "    let mut writer = String::new();",
                  "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
                  "    let repetition = ast::Repetition { span: Span { start: 3, end: 6 }, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) }, greedy: false, ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })) };",
                  "    visitor.visit_post(&ast::Ast::Repetition(repetition)).unwrap();",
                  "    assert_eq!(writer, \".*?\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:597:15\n    |\n597 |         span: Span { start: 3, end: 6 },\n    |               ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0574]: expected struct, variant or union type, found enum `ast::RepetitionRange`\n    --> regex-syntax/src/ast/print.rs:598:66\n     |\n598  |         op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) },\n     |                                                                  ^^^^^---------------\n     |                                                                       |\n     |                                                                       help: a struct with a similar name exists: `Repetition`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | pub struct Repetition {\n     | --------------------- similarly named struct `Repetition` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:58\n    |\n600 | ...   ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast...\n    |                                                        ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:600:146\n    |\n600 | ...t::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })),\n    |                                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:46\n    |\n605 |     let repetition = ast::Repetition { span: Span { start: 3, end: 6 }, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::Rep...\n    |                                              ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0574]: expected struct, variant or union type, found enum `ast::RepetitionRange`\n    --> regex-syntax/src/ast/print.rs:605:130\n     |\n605  | ...: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) }, greedy: false, ast: Box::new(ast::Ast::Group(ast::Group { s...\n     |                                 ^^^^^---------------\n     |                                      |\n     |                                      help: a struct with a similar name exists: `Repetition`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1127:1\n     |\n1127 | pub struct Repetition {\n     | --------------------- similarly named struct `Repetition` defined here\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:240\n    |\n605 | ...se, ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::As...\n    |                                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:605:328\n    |\n605 | ...t::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })) };\n    |                                                         ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:598:13\n    |\n598 |         op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) },\n    |             ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/print.rs:600:107\n     |\n600  | ... 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })),\n     |                                        ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n     |\nhelp: there is a variant with a similar name\n     |\n600  |         ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })),\n     |                                                                                                           ~~~~~~~~~~~~\n\nerror[E0063]: missing field `span` in initializer of `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:605:77\n    |\n605 |     let repetition = ast::Repetition { span: Span { start: 3, end: 6 }, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::Rep...\n    |                                                                             ^^^^^^^^^^^^^^^^^ missing `span`\n\nerror[E0599]: no variant or associated item named `Capturing` found for enum `ast::GroupKind` in the current scope\n    --> regex-syntax/src/ast/print.rs:605:289\n     |\n605  | ... 3, end: 3 }, kind: ast::GroupKind::Capturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })) };\n     |                                        ^^^^^^^^^ variant or associated item not found in `GroupKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1233:1\n     |\n1233 | pub enum GroupKind {\n     | ------------------ variant or associated item `Capturing` not found for this enum\n     |\nhelp: there is a variant with a similar name\n     |\n605  |     let repetition = ast::Repetition { span: Span { start: 3, end: 6 }, op: ast::RepetitionOp { kind: ast::RepetitionKind::Range(ast::RepetitionRange { start: 1, end: 3 }) }, greedy: false, ast: Box::new(ast::Ast::Group(ast::Group { span: Span { start: 3, end: 3 }, kind: ast::GroupKind::NonCapturing, ast: Box::new(ast::Ast::Dot(Span { start: 3, end: 3 })) })) };\n     |                                                                                                                                                                                                                                                                                                 ~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0422, E0432, E0574, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(Class::Unicode(ref x)) or Ast::Class(Class::Bracketed(ref x)) or Ast::Class(Class::Perl(ref x)) is true\n",
        "// constraint: *ast matches Ast::Literal(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(Class::Bracketed(ref x)) is true\n"
      ],
      "input_infer": "Ast::Class(Class::Unicode(ref x)), Ast::Class(Class::Bracketed(ref x)), Ast::Class(Class::Perl(ref x)), Ast::Literal(ref x) where x encompasses valid Unicode character classes, inclusive of negation scenarios, and literals covering various escape sequences and punctuation characters.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 0);",
                "    let ast = Ast::Empty(span);",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&flags));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&literal));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&assertion));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&perl_class));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&unicode_class));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&bracketed_class));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&repetition));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let group = Group { span, kind, ast: Box::new() };",
                  "    let ast = Ast::Group(group);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&group));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let group = Group { span, kind, ast: Box::new() };",
                  "    let ast = Ast::Group(group);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Alternation();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let group = Group { span, kind, ast: Box::new() };",
                  "    let ast = Ast::Group(group);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Alternation();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Concat();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&flags));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&literal));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&assertion));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&perl_class));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&unicode_class));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&bracketed_class));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&repetition));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let group = Group { span, kind, ast: Box::new() };",
                  "    let ast = Ast::Group(group);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&group));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let group = Group { span, kind, ast: Box::new() };",
                  "    let ast = Ast::Group(group);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Alternation();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Flags(SetFlags { span, flags });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let perl_class = ClassPerl { span, kind, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(perl_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let unicode_class = ClassUnicode { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let bracketed_class = ClassBracketed { span, negated: false, kind };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let repetition = Repetition { span, op, greedy: true, ast: Box::new() };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let group = Group { span, kind, ast: Box::new() };",
                  "    let ast = Ast::Group(group);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Alternation();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Concat();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:607:63\n    |\n607 |     assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&flags));\n    |                                                               ^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0599]: no method named `write_str` found for struct `String` in the current scope\n   --> regex-syntax/src/ast/print.rs:616:52\n    |\n616 |     assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));\n    |                                                    ^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:150:8\n    |\n    = note: the method is available for `String` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n589 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n616 |     assert_eq!(writer.visit_post(&ast), writer.wtr.write_char(\".\"));\n    |                                                    ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:626:16\n    |\n626 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:627:25\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:627:62\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:628:26\n    |\n628 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:626:16\n    |\n626 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:627:25\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:627:62\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:628:26\n    |\n628 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:631:16\n    |\n631 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:632:27\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:632:66\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:633:26\n    |\n633 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:637:73\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                         ^\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:626:16\n    |\n626 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:627:25\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:627:62\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:628:26\n    |\n628 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:631:16\n    |\n631 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:632:27\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:632:66\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:633:26\n    |\n633 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:636:16\n    |\n636 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:637:22\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `op` in this scope\n   --> regex-syntax/src/ast/print.rs:637:41\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                         ^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:637:64\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new(/* x */) };\n    |                                                                        ~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:637:73\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                         ^\n\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:642:51\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                                                   ^\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:626:16\n    |\n626 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:627:25\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:627:62\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:628:26\n    |\n628 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:631:16\n    |\n631 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:632:27\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:632:66\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:633:26\n    |\n633 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:636:16\n    |\n636 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:637:22\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `op` in this scope\n   --> regex-syntax/src/ast/print.rs:637:41\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                         ^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:641:16\n    |\n641 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:642:17\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:642:31\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                               ^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:637:64\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new(/* x */) };\n    |                                                                        ~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:642:42\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                                          ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n642 |     let group = Group { span, kind, ast: Box::new(/* x */) };\n    |                                                  ~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:637:73\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                         ^\n\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:642:51\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                                                   ^\n\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:647:32\n    |\n647 |     let ast = Ast::Alternation();\n    |                                ^\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:626:16\n    |\n626 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:627:25\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:627:62\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:628:26\n    |\n628 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:631:16\n    |\n631 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:632:27\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:632:66\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:633:26\n    |\n633 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:636:16\n    |\n636 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:637:22\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `op` in this scope\n   --> regex-syntax/src/ast/print.rs:637:41\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                         ^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:641:16\n    |\n641 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:642:17\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:642:31\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:646:16\n    |\n646 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:637:64\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new(/* x */) };\n    |                                                                        ~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:642:42\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                                          ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n642 |     let group = Group { span, kind, ast: Box::new(/* x */) };\n    |                                                  ~~~~~~~~~\n\nerror[E0061]: this enum variant takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:647:15\n    |\n647 |     let ast = Ast::Alternation();\n    |               ^^^^^^^^^^^^^^^^--- argument #1 of type `ast::Alternation` is missing\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\nhelp: provide the argument\n    |\n647 |     let ast = Ast::Alternation(/* ast::Alternation */);\n    |                               ~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 38 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:637:73\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                         ^\n\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:642:51\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                                                   ^\n\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:647:32\n    |\n647 |     let ast = Ast::Alternation();\n    |                                ^\n\nerror: unknown start of token: \\u{2026}\n   --> regex-syntax/src/ast/print.rs:651:27\n    |\n651 |     let ast = Ast::Concat();\n    |                           ^\n\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:16\n    |\n603 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0425]: cannot find value `flags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:43\n    |\n604 |     let ast = Ast::Flags(SetFlags { span, flags });\n    |                                           ^^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:608:19\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:608:35\n    |\n608 |     let literal = Literal { span, kind, c: 'a' };\n    |                                   ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:16\n    |\n612 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:16\n    |\n616 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:617:21\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:617:39\n    |\n617 |     let assertion = Assertion { span, kind };\n    |                                       ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:621:16\n    |\n621 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:622:22\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:622:40\n    |\n622 |     let perl_class = ClassPerl { span, kind, negated: false };\n    |                                        ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:623:26\n    |\n623 |     let ast = Ast::Class(Class::Perl(perl_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:626:16\n    |\n626 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:627:25\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:627:62\n    |\n627 |     let unicode_class = ClassUnicode { span, negated: false, kind };\n    |                                                              ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:628:26\n    |\n628 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:631:16\n    |\n631 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:632:27\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:632:66\n    |\n632 |     let bracketed_class = ClassBracketed { span, negated: false, kind };\n    |                                                                  ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:633:26\n    |\n633 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:636:16\n    |\n636 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:637:22\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0425]: cannot find value `op` in this scope\n   --> regex-syntax/src/ast/print.rs:637:41\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                         ^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:641:16\n    |\n641 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:642:17\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0425]: cannot find value `kind` in this scope\n   --> regex-syntax/src/ast/print.rs:642:31\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                               ^^^^ not found in this scope\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:646:16\n    |\n646 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:650:16\n    |\n650 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:637:64\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new() };\n    |                                                                ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n637 |     let repetition = Repetition { span, op, greedy: true, ast: Box::new(/* x */) };\n    |                                                                        ~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:642:42\n    |\n642 |     let group = Group { span, kind, ast: Box::new() };\n    |                                          ^^^^^^^^--- argument #1 is missing\n    |\nnote: associated function defined here\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/boxed.rs:258:12\nhelp: provide the argument\n    |\n642 |     let group = Group { span, kind, ast: Box::new(/* x */) };\n    |                                                  ~~~~~~~~~\n\nerror[E0061]: this enum variant takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:647:15\n    |\n647 |     let ast = Ast::Alternation();\n    |               ^^^^^^^^^^^^^^^^--- argument #1 of type `ast::Alternation` is missing\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\nhelp: provide the argument\n    |\n647 |     let ast = Ast::Alternation(/* ast::Alternation */);\n    |                               ~~~~~~~~~~~~~~~~~~~~~~~~\n\nerror[E0061]: this enum variant takes 1 argument but 0 arguments were supplied\n   --> regex-syntax/src/ast/print.rs:651:15\n    |\n651 |     let ast = Ast::Concat();\n    |               ^^^^^^^^^^^--- argument #1 of type `ast::Concat` is missing\n    |\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\nhelp: provide the argument\n    |\n651 |     let ast = Ast::Concat(/* ast::Concat */);\n    |                          ~~~~~~~~~~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 1);",
                "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"a\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"a\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:595:28\n    |\n595 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:595:50\n    |\n595 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:28\n    |\n600 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:50\n    |\n600 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 1);",
                "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\pa\");"
                ],
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"a\");"
                ],
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Union }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\pa\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Union }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:595:83\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:600:41\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:600:83\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:595:83\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:600:41\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:600:83\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:28\n    |\n605 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:50\n    |\n605 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:595:83\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:600:41\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:600:83\n    |\n600 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: true, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                   ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:605:28\n    |\n605 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:605:50\n    |\n605 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:16\n    |\n609 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Union }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:610:43\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Union }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:610:87\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Union }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 1);",
                "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.wtr, r\"\\p{L}\");"
                ],
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast_bracketed);",
                  "    assert_eq!(writer.wtr, \"]\");"
                ],
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast_bracketed);",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast_perl);",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.wtr, r\"\\p{L}\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast_bracketed);",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast_bracketed);",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast_perl);",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:595:84\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:34\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:600:49\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:600:92\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                                                            ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:36\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:601:53\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:601:98\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                                                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:31\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                           ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:595:84\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:34\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:600:49\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:600:92\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                                                            ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:36\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:601:53\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:601:98\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                                                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:31\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                           ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:595:84\n    |\n595 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:34\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:600:49\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:600:92\n    |\n600 |     let ast_unicode = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::Named('L') }));\n    |                                                                                            ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:36\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:601:53\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                                     ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:601:98\n    |\n601 |     let ast_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n    |                                                                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:31\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                           ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast_perl = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 2);",
                "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = \"]\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ],
                [
                  "    let expected_output = \"]\";",
                  "    let expected_span = Span::new(0, 2);",
                  "    assert_eq!(ast.span(), expected_span);"
                ],
                [
                  "    let expected_output = \"]\";",
                  "    let expected_span = Span::new(0, 2);",
                  "    assert!(matches!(ast, Ast::Class(Class::Bracketed(_))));"
                ],
                [
                  "    let expected_output = \"]\";",
                  "    let expected_span = Span::new(0, 2);",
                  "    let negated = match ast {",
                  "    Ast::Class(Class::Bracketed(ref x)) => x.negated,",
                  "    _ => false",
                  "    };",
                  "    assert!(negated);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 2);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = \"]\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 2);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = \"]\";",
                  "    let expected_span = Span::new(0, 2);",
                  "    assert_eq!(ast.span(), expected_span);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 2);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = \"]\";",
                  "    let expected_span = Span::new(0, 2);",
                  "    assert!(matches!(ast, Ast::Class(Class::Bracketed(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 2);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = \"]\";",
                  "    let expected_span = Span::new(0, 2);",
                  "    let negated = match ast {",
                  "    Ast::Class(Class::Bracketed(ref x)) => x.negated,",
                  "    _ => false",
                  "    };",
                  "    assert!(negated);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 2);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:43\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:595:87\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 2);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:43\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:595:87\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:25\n    |\n600 |     let expected_span = Span::new(0, 2);\n    |                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 2);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:43\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:595:87\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:25\n    |\n600 |     let expected_span = Span::new(0, 2);\n    |                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:38\n    |\n601 |     assert!(matches!(ast, Ast::Class(Class::Bracketed(_))));\n    |                                      ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 2);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:43\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:595:87\n    |\n595 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:25\n    |\n600 |     let expected_span = Span::new(0, 2);\n    |                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     Ast::Class(Class::Bracketed(ref x)) => x.negated,\n    |                ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 1);",
                "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.wtr, r\"\\D\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.wtr, r\"\\D\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:595:38\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:595:62\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:600:38\n    |\n600 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:600:62\n    |\n600 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Digit, negated: true }));\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 1);",
                "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = r\"\\s\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ],
                [
                  "    let expected_output = r\"\\s\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\p{a}\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ],
                [
                  "    let expected_output = r\"\\s\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"]\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ],
                [
                  "    let expected_output = r\"\\s\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"]\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'x' });",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = \"x\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\s\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\s\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\p{a}\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\s\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"]\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\s\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = r\"]\";",
                  "    let span = Span::new(0, 1);",
                  "    let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'x' });",
                  "    writer.wtr.clear();",
                  "    writer.visit_post(&ast);",
                  "    let expected_output = \"x\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:595:38\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:595:62\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:595:38\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:595:62\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:41\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:84\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:595:38\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:595:62\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:41\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:84\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:16\n    |\n605 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:606:43\n    |\n606 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:606:87\n    |\n606 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:595:26\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:595:38\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:595:62\n    |\n595 |     let ast = Ast::Class(Class::Perl(ClassPerl { span, kind: ClassPerlKind::Space, negated: false }));\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:41\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:84\n    |\n601 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:16\n    |\n605 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:606:43\n    |\n606 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:606:87\n    |\n606 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n    |                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:16\n    |\n610 |     let span = Span::new(0, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:28\n    |\n611 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'x' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:50\n    |\n611 |     let ast = Ast::Literal(Literal { span, kind: LiteralKind::Verbatim, c: 'x' });\n    |                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(0, 0);",
                "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_perl = ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let ast = Ast::Empty(span);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let flags = SetFlags { span, flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(0, 0);",
                  "    let class_perl = ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:41\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:41\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:16\n    |\n606 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:19\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:41\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:41\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:16\n    |\n606 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:19\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:41\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:16\n    |\n610 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:45\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:41\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:16\n    |\n606 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:19\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:41\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:16\n    |\n610 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:45\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:16\n    |\n614 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:615:25\n    |\n615 |     let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:615:52\n    |\n615 |     let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };\n    |                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:41\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:16\n    |\n606 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:19\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:41\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:16\n    |\n610 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:45\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:16\n    |\n614 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:615:25\n    |\n615 |     let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:615:52\n    |\n615 |     let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };\n    |                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:16\n    |\n618 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:619:27\n    |\n619 |     let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:619:56\n    |\n619 |     let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };\n    |                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:30\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:54\n    |\n595 |     let ast = Ast::Assertion(Assertion { span, kind: AssertionKind::StartLine });\n    |                                                      ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:16\n    |\n602 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:41\n    |\n603 |     let flags = SetFlags { span, flags: Flags::default() };\n    |                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:16\n    |\n606 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:19\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:41\n    |\n607 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:16\n    |\n610 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:21\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:45\n    |\n611 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:16\n    |\n614 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:615:25\n    |\n615 |     let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:615:52\n    |\n615 |     let class_unicode = ClassUnicode { span, kind: ClassUnicodeKind::OneLetter('c'), negated: false };\n    |                                                    ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:616:26\n    |\n616 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:16\n    |\n618 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:619:27\n    |\n619 |     let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:619:56\n    |\n619 |     let class_bracketed = ClassBracketed { span, kind: ClassSet::Normal, negated: false };\n    |                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:620:26\n    |\n620 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:622:16\n    |\n622 |     let span = Span::new(0, 0);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:623:22\n    |\n623 |     let class_perl = ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:623:46\n    |\n623 |     let class_perl = ClassPerl { span, kind: ClassPerlKind::Digit, negated: true };\n    |                                              ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:624:26\n    |\n624 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(Class::Unicode(ref x)) or Ast::Class(Class::Bracketed(ref x)) or Ast::Class(Class::Perl(ref x)) is true\n",
        "// constraint: *ast matches Ast::Flags(ref x) is true\n",
        "// constraint: *ast matches Ast::Class(Class::Perl(ref x)) is true\n"
      ],
      "input_infer": "test input ranges: Ast::Class(Class::Unicode), Ast::Class(Class::Bracketed), Ast::Class(Class::Perl), Ast::Flags, Ast::Literal, Ast::Assertion, Ast::Repetition, Ast::Group\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Empty(Span::new(0, 0));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
                  "    let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::new(0, 0));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });",
                  "    let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });",
                  "    let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:609:26\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:108\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:609:26\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:108\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Alternation;\n    |\n589 +    use ast::Ast::Alternation;\n    |\n589 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:72\n    |\n610 |     let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });\n    |                                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:26\n    |\n596 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::new(0, 0));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 0), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:609:26\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:108\n    |\n609 |     let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::new(0, 0))) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Alternation` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });\n    |                                ^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Alternation;\n    |\n589 +    use ast::Ast::Alternation;\n    |\n589 +    use hir::HirKind::Alternation;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:72\n    |\n610 |     let ast = Ast::Alternation(Alternation { branches: vec![Ast::Empty(Span::new(0, 0))] });\n    |                                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Concat` in this scope\n   --> regex-syntax/src/ast/print.rs:611:27\n    |\n611 |     let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });\n    |                           ^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Concat;\n    |\n589 +    use ast::Concat;\n    |\n589 +    use hir::HirKind::Concat;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:59\n    |\n611 |     let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });\n    |                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:88\n    |\n611 |     let ast = Ast::Concat(Concat { parts: vec![Ast::Empty(Span::new(0, 0)), Ast::Empty(Span::new(0, 0))] });\n    |                                                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 38 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
                "    let ast = Ast::Flags(flags);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert!(writer.wtr == \"(?{})\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    assert!(writer.wtr == \"(?{})\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:34\n    |\n596 |     let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:596:58\n    |\n596 |     let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:58\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 1), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"a\");"
                ],
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"(?\");"
                ],
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ],
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\pb\");"
                ],
                [
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"]\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"(?\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\pb\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:58\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:19\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:58\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:58\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:19\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:58\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:34\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:58\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:19\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:58\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:34\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:22\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:40\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:63\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:58\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:19\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:58\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:34\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:22\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:40\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:63\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:609:25\n    |\n609 |     let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:46\n    |\n609 |     let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:609:85\n    |\n609 |     let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:596:19\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:35\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:596:58\n    |\n596 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:19\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:58\n    |\n600 |     let literal = Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' };\n    |                                                          ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:603:17\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:34\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:603:58\n    |\n603 |     let flags = SetFlags { span: Span::new(0, 4), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:22\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:40\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:63\n    |\n606 |     let class_perl = ClassPerl { span: Span::new(0, 2), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:609:25\n    |\n609 |     let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:46\n    |\n609 |     let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:609:85\n    |\n609 |     let class_unicode = ClassUnicode { span: Span::new(0, 2), negated: false, kind: ClassUnicodeKind::OneLetter('b') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:612:27\n    |\n612 |     let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:50\n    |\n612 |     let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:612:88\n    |\n612 |     let class_bracketed = ClassBracketed { span: Span::new(0, 3), negated: true, kind: ClassSet::Normal };\n    |                                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:613:26\n    |\n613 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Dot(Span::new(0, 1));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_flags).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_literal).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_assertion).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_class_perl).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_class_unicode).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_class_bracketed).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_repetition).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast_group), Ok(()));"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_alternation).is_ok());"
                ],
                [
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_concat).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_flags).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_literal).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_assertion).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_class_perl).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_class_unicode).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_class_bracketed).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_repetition).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast_group), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_alternation).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    writer.visit_post(&ast);",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert!(writer.visit_post(&ast_concat).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `ast_alternation` in this scope\n   --> regex-syntax/src/ast/print.rs:608:32\n    |\n608 |     assert!(writer.visit_post(&ast_alternation).is_ok());\n    |                                ^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `ast_assertion`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 38 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:24\n    |\n596 |     let ast = Ast::Dot(Span::new(0, 1));\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:598:32\n    |\n598 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:599:32\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:49\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:599:73\n    |\n599 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::default() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:600:36\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:52\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:600:75\n    |\n600 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:28\n    |\n601 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:40\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:58\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:81\n    |\n602 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:603:37\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:603:49\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:67\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:603:90\n    |\n603 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:604:55\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:76\n    |\n604 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:604:115\n    |\n604 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:42\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:59\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:82\n    |\n605 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Union(v...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:605:121\n    |\n605 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:606:42\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:61\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:606:82\n    |\n606 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(As...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:606:149\n    |\n606 | ...roOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:165\n    |\n606 | ... true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:606:188\n    |\n606 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:607:32\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:46\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:607:69\n    |\n607 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::...\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:607:116\n    |\n607 | ...nd: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                       ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:132\n    |\n607 | ...pture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:607:155\n    |\n607 | ...ral(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0425]: cannot find value `ast_concat` in this scope\n   --> regex-syntax/src/ast/print.rs:608:32\n    |\n608 |     assert!(writer.visit_post(&ast_concat).is_ok());\n    |                                ^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 38 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
                  "    let ast = Ast::Concat(Concat { span: Span::new(0, 1), elements: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'd' })] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    let ast = Ast::Empty(Span::new(0, 1));",
                  "    let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});",
                  "    let ast = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::new(0, 1));",
                  "    let ast = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: true, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' })) });",
                  "    let ast = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Capture, ast: Box::new(Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'b' })) });",
                  "    let ast = Ast::Alternation(Alternation { span: Span::new(0, 1), branches: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'c' })] });",
                  "    let ast = Ast::Concat(Concat { span: Span::new(0, 1), elements: vec![Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'd' })] });",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:26\n    |\n599 |     let ast = Ast::Empty(Span::new(0, 1));\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/ast/print.rs:600:35\n    |\n600 |     let ast = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags {});\n    |                         -         ^ unclosed delimiter                    ^ mismatched closing delimiter\n    |                         |\n    |                         closing delimiter possibly meant for this\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    assert_eq!(writer.wtr, r\"\\p{a}\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"]\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"(?)\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    assert_eq!(writer.wtr, r\"\\p{a}\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"(?)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
                  "    let ast = Ast::Class(Class::Unicode(class_unicode));",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:25\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:46\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:25\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:46\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:603:27\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:50\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:603:89\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:25\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:46\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:603:27\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:50\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:603:89\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:606:58\n    |\n606 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:596:25\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:46\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:596:85\n    |\n596 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:601:25\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:46\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:601:85\n    |\n601 |     let class_unicode = ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('a') };\n    |                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Unicode(class_unicode));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:603:27\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:50\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:603:89\n    |\n603 |     let class_bracketed = ClassBracketed { span: Span::new(0, 2), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:606:17\n    |\n606 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:34\n    |\n606 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:606:58\n    |\n606 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::default() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:609:22\n    |\n609 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 20 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    assert_eq!(writer.wtr, \"]\");"
                ],
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"(? )\");"
                ],
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ],
                [
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"^\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"(? )\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    writer.visit_post(&ast);",
                  "    let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };",
                  "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast = Ast::Flags(flags);",
                  "    writer.visit_post(&ast);",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast);",
                  "    assert_eq!(writer.wtr, \"^\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:50\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:599:89\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:50\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:599:89\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:58\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:50\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:599:89\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:58\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:604:22\n    |\n604 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:604:63\n    |\n604 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:50\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:596:89\n    |\n596 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:599:27\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:50\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:599:89\n    |\n599 |     let class_bracketed = ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal };\n    |                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(class_bracketed));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:34\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:58\n    |\n601 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:604:22\n    |\n604 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:40\n    |\n604 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:604:63\n    |\n604 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:607:21\n    |\n607 |     let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:39\n    |\n607 |     let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };\n    |                                       ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:607:62\n    |\n607 |     let assertion = Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine };\n    |                                                              ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 19 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                "    let ast = Ast::Class(Class::Perl(class_perl));",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    writer.visit_post(&ast_flags).unwrap();",
                  "    assert_eq!(writer.wtr, \"(? )\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };",
                  "    let ast = Ast::Class(Class::Perl(class_perl));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };",
                  "    let ast_flags = Ast::Flags(flags);",
                  "    writer.visit_post(&ast_flags).unwrap();",
                  "    assert_eq!(writer.wtr, \"(? )\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:40\n    |\n596 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:596:63\n    |\n596 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:601:22\n    |\n601 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:40\n    |\n601 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:601:63\n    |\n601 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:40\n    |\n596 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:596:63\n    |\n596 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:597:26\n    |\n597 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:601:22\n    |\n601 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:40\n    |\n601 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:601:63\n    |\n601 |     let class_perl = ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false };\n    |                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Class(Class::Perl(class_perl));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:604:17\n    |\n604 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                 ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:34\n    |\n604 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:604:58\n    |\n604 |     let flags = SetFlags { span: Span::new(0, 3), flags: Flags::new() };\n    |                                                          ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                "    let ast = Ast::Repetition(repetition);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_literal), writer.fmt_literal(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_assertion), writer.fmt_assertion(&Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_class_perl), writer.fmt_class_perl(&ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_class_unicode), writer.fmt_class_unicode(&ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_class_bracketed), writer.fmt_class_bracketed_post(&ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_repetition), writer.fmt_repetition(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_group), writer.fmt_group_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) }));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_repetition), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_empty), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_literal), writer.fmt_literal(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_dot), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_assertion), writer.fmt_assertion(&Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_class_perl), writer.fmt_class_perl(&ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_class_unicode), writer.fmt_class_unicode(&ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_class_bracketed), writer.fmt_class_bracketed_post(&ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_repetition), writer.fmt_repetition(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_group), writer.fmt_group_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) }));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast_empty = Ast::Empty(Span::new(0, 0));",
                  "    let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });",
                  "    let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast_dot = Ast::Dot(Span::new(0, 1));",
                  "    let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });",
                  "    let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));",
                  "    let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) });",
                  "    let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });",
                  "    assert_eq!(writer.visit_post(&ast_repetition), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:611:69\n    |\n611 |     assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));\n    |                                                                     ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:86\n    |\n611 |     assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));\n    |                                                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:611:110\n    |\n611 |     assert_eq!(writer.visit_post(&ast_flags), writer.fmt_set_flags(&SetFlags { span: Span::new(0, 1), flags: Flags::new() }));\n    |                                                                                                              ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:611:69\n    |\n611 |     assert_eq!(writer.visit_post(&ast_literal), writer.fmt_literal(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                     ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:85\n    |\n611 |     assert_eq!(writer.visit_post(&ast_literal), writer.fmt_literal(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' ...\n    |                                                                                     ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:611:108\n    |\n611 | ...al(&Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' }));\n    |                                               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:611:73\n    |\n611 |     assert_eq!(writer.visit_post(&ast_assertion), writer.fmt_assertion(&Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine...\n    |                                                                         ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:91\n    |\n611 |     assert_eq!(writer.visit_post(&ast_assertion), writer.fmt_assertion(&Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine...\n    |                                                                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:611:114\n    |\n611 | ...Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine }));\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:611:75\n    |\n611 |     assert_eq!(writer.visit_post(&ast_class_perl), writer.fmt_class_perl(&ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, ...\n    |                                                                           ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:93\n    |\n611 |     assert_eq!(writer.visit_post(&ast_class_perl), writer.fmt_class_perl(&ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, ...\n    |                                                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:611:116\n    |\n611 | ...ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:611:81\n    |\n611 |     assert_eq!(writer.visit_post(&ast_class_unicode), writer.fmt_class_unicode(&ClassUnicode { span: Span::new(0, 1), negated: false, kin...\n    |                                                                                 ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:102\n    |\n611 | ...), writer.fmt_class_unicode(&ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:611:141\n    |\n611 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:611:90\n    |\n611 |     assert_eq!(writer.visit_post(&ast_class_bracketed), writer.fmt_class_bracketed_post(&ClassBracketed { span: Span::new(0, 1), negated:...\n    |                                                                                          ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:113\n    |\n611 | ....fmt_class_bracketed_post(&ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:611:152\n    |\n611 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:611:75\n    |\n611 |     assert_eq!(writer.visit_post(&ast_repetition), writer.fmt_repetition(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMor...\n    |                                                                           ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:94\n    |\n611 |     assert_eq!(writer.visit_post(&ast_repetition), writer.fmt_repetition(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMor...\n    |                                                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:611:115\n    |\n611 | ...(&Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(ast_empty) }));\n    |                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:611:70\n    |\n611 |     assert_eq!(writer.visit_post(&ast_group), writer.fmt_group_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::ne...\n    |                                                                      ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:611:84\n    |\n611 |     assert_eq!(writer.visit_post(&ast_group), writer.fmt_group_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::ne...\n    |                                                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:611:107\n    |\n611 | ...p_post(&Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) }));\n    |                                                 ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 37 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:596:22\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:41\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                         ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:596:62\n    |\n596 |     let repetition = Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0...\n    |                                                              ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:127\n    |\n596 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:32\n    |\n601 |     let ast_empty = Ast::Empty(Span::new(0, 0));\n    |                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:32\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:49\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                 ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:73\n    |\n602 |     let ast_flags = Ast::Flags(SetFlags { span: Span::new(0, 1), flags: Flags::new() });\n    |                                                                         ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:603:36\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                    ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:52\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                    ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:603:75\n    |\n603 |     let ast_literal = Ast::Literal(Literal { span: Span::new(0, 1), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast_dot = Ast::Dot(Span::new(0, 1));\n    |                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:605:40\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                        ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:58\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:605:81\n    |\n605 |     let ast_assertion = Ast::Assertion(Assertion { span: Span::new(0, 1), kind: AssertionKind::StartLine });\n    |                                                                                 ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:37\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                     ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:606:49\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                 ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:67\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                   ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:606:90\n    |\n606 |     let ast_class_perl = Ast::Class(Class::Perl(ClassPerl { span: Span::new(0, 1), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                                          ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:40\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                        ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:607:55\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                       ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:76\n    |\n607 |     let ast_class_unicode = Ast::Class(Class::Unicode(ClassUnicode { span: Span::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLe...\n    |                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:607:115\n    |\n607 | ...pan::new(0, 1), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                          ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:608:42\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:608:59\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:82\n    |\n608 |     let ast_class_bracketed = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::new(0, 1), negated: false, kind: ClassSet::Normal ...\n    |                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:121\n    |\n608 | ... span: Span::new(0, 1), negated: false, kind: ClassSet::Normal }));\n    |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:609:42\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                          ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:61\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                             ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:609:82\n    |\n609 |     let ast_repetition = Ast::Repetition(Repetition { span: Span::new(0, 1), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(as...\n    |                                                                                  ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:46\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:610:69\n    |\n610 |     let ast_group = Ast::Group(Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(ast_empty) });\n    |                                                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                "    let ast = Ast::Group(group);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Group(group);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Group(group);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };",
                  "    let ast = Ast::Group(group);",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:596:17\n    |\n596 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:31\n    |\n596 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:596:54\n    |\n596 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:596:98\n    |\n596 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:601:17\n    |\n601 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:31\n    |\n601 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                               ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:601:54\n    |\n601 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                      ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:98\n    |\n601 |     let group = Group { span: Span::new(0, 1), kind: GroupKind::Normal, ast: Box::new(Ast::Empty(Span::new(0, 0))) };\n    |                                                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Alternation(vec![]);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"(?)\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"a\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \".\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"^\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\d\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\pA\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"]\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"*\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \")\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"(?)\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"a\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \".\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"^\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\d\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\pA\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"*\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \")\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Dot(Span::default());",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:101\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 21 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:101\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:105\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 25 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:101\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:105\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:71\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:136\n    |\n616 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 29 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:101\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:105\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:71\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:136\n    |\n616 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:40\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:618:63\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:108\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 33 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:101\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:105\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:71\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:136\n    |\n616 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:40\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:618:63\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:108\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:620:32\n    |\n620 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:602:26\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:43\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:604:28\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:44\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:604:67\n    |\n604 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:24\n    |\n606 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:608:30\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:48\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:610:38\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:610:56\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:610:79\n    |\n610 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:612:26\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:612:41\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:612:62\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:101\n    |\n612 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:614:26\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:614:43\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:614:66\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:614:105\n    |\n614 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:616:31\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:50\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:616:71\n    |\n616 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:616:136\n    |\n616 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:40\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:618:63\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:618:108\n    |\n618 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:32\n    |\n596 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:620:32\n    |\n620 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:622:27\n    |\n622 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let ast = Ast::Concat(vec![]);",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&SetFlags::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&Literal::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&Assertion::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&ClassPerl::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&ClassUnicode::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&ClassBracketed::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&Repetition::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&Group::default()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    let ast = Ast::Concat(vec![]);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&SetFlags::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&Literal::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&Assertion::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&ClassPerl::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&ClassUnicode::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&ClassBracketed::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&Repetition::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&Group::default()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Concat(vec![]);",
                  "    writer.visit_post(&ast);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let ast = Ast::Empty(Span::default());",
                  "    let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });",
                  "    let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });",
                  "    let ast = Ast::Dot(Span::default());",
                  "    let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });",
                  "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));",
                  "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
                  "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
                  "    let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });",
                  "    let ast = Ast::Alternation(vec![]);",
                  "    let ast = Ast::Concat(vec![]);",
                  "    assert_eq!(writer.visit_post(&ast), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `SetFlags`\n   --> regex-syntax/src/ast/print.rs:602:63\n    |\n602 |     assert_eq!(writer.visit_post(&ast), writer.fmt_set_flags(&SetFlags::default()));\n    |                                                               ^^^^^^^^ use of undeclared type `SetFlags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Literal`\n   --> regex-syntax/src/ast/print.rs:603:61\n    |\n603 |     assert_eq!(writer.visit_post(&ast), writer.fmt_literal(&Literal::default()));\n    |                                                             ^^^^^^^ use of undeclared type `Literal`\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::Literal;\n    |\n589 +    use hir::literal::Literal;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nerror[E0599]: no method named `write_str` found for struct `String` in the current scope\n   --> regex-syntax/src/ast/print.rs:604:52\n    |\n604 |     assert_eq!(writer.visit_post(&ast), writer.wtr.write_str(\".\"));\n    |                                                    ^^^^^^^^^\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/fmt/mod.rs:150:8\n    |\n    = note: the method is available for `String` here\n    |\n    = help: items from traits can only be used if the trait is in scope\nhelp: trait `Write` which provides `write_str` is implemented but not in scope; perhaps you want to import it\n    |\n589 +    use std::fmt::Write;\n    |\nhelp: there is a method `write_char` with a similar name\n    |\n604 |     assert_eq!(writer.visit_post(&ast), writer.wtr.write_char(\".\"));\n    |                                                    ~~~~~~~~~~\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Assertion`\n   --> regex-syntax/src/ast/print.rs:605:63\n    |\n605 |     assert_eq!(writer.visit_post(&ast), writer.fmt_assertion(&Assertion::default()));\n    |                                                               ^^^^^^^^^ use of undeclared type `Assertion`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Assertion;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerl`\n   --> regex-syntax/src/ast/print.rs:606:64\n    |\n606 |     assert_eq!(writer.visit_post(&ast), writer.fmt_class_perl(&ClassPerl::default()));\n    |                                                                ^^^^^^^^^ use of undeclared type `ClassPerl`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 18 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n   --> regex-syntax/src/ast/print.rs:607:67\n    |\n607 |     assert_eq!(writer.visit_post(&ast), writer.fmt_class_unicode(&ClassUnicode::default()));\n    |                                                                   ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 22 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBracketed`\n   --> regex-syntax/src/ast/print.rs:608:74\n    |\n608 |     assert_eq!(writer.visit_post(&ast), writer.fmt_class_bracketed_post(&ClassBracketed::default()));\n    |                                                                          ^^^^^^^^^^^^^^ use of undeclared type `ClassBracketed`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 26 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Repetition`\n   --> regex-syntax/src/ast/print.rs:609:64\n    |\n609 |     assert_eq!(writer.visit_post(&ast), writer.fmt_repetition(&Repetition::default()));\n    |                                                                ^^^^^^^^^^ use of undeclared type `Repetition`\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 30 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:609:26\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:108\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Group`\n   --> regex-syntax/src/ast/print.rs:610:64\n    |\n610 |     assert_eq!(writer.visit_post(&ast), writer.fmt_group_post(&Group::default()));\n    |                                                                ^^^^^ use of undeclared type `Group`\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:609:26\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:108\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 34 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Empty(Span::default());\n    |                          ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `SetFlags` in this scope\n   --> regex-syntax/src/ast/print.rs:601:26\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                          ^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::SetFlags;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:43\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                           ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Flags`\n   --> regex-syntax/src/ast/print.rs:601:67\n    |\n601 |     let ast = Ast::Flags(SetFlags { span: Span::default(), flags: Flags::default() });\n    |                                                                   ^^^^^ use of undeclared type `Flags`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Flags;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:28\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                            ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:602:44\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:67\n    |\n602 |     let ast = Ast::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' });\n    |                                                                   ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:603:24\n    |\n603 |     let ast = Ast::Dot(Span::default());\n    |                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:604:30\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                              ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:48\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:604:71\n    |\n604 |     let ast = Ast::Assertion(Assertion { span: Span::default(), kind: AssertionKind::StartLine });\n    |                                                                       ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:605:26\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:605:38\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:605:56\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:605:79\n    |\n605 |     let ast = Ast::Class(Class::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false }));\n    |                                                                               ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:606:26\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:606:41\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:606:62\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                              ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:606:101\n    |\n606 |     let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('a') }));\n    |                                                                                                     ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:607:26\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:607:43\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:66\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:607:105\n    |\n607 |     let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));\n    |                                                                                                         ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:608:31\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                               ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:50\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                  ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:608:71\n    |\n608 |     let ast = Ast::Repetition(Repetition { span: Span::default(), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Sp...\n    |                                                                       ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:136\n    |\n608 | ...eroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                      ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:609:26\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                          ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:40\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                        ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:609:63\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                               ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:609:108\n    |\n609 |     let ast = Ast::Group(Group { span: Span::default(), kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span::default())) });\n    |                                                                                                            ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:596:27\n    |\n596 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:610:32\n    |\n610 |     let ast = Ast::Alternation(vec![]);\n    |               ---------------- ^^^^^^ expected `Alternation`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Alternation`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:497:5\n    |\n497 |     Alternation(Alternation),\n    |     ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:611:27\n    |\n611 |     let ast = Ast::Concat(vec![]);\n    |               ----------- ^^^^^^ expected `Concat`, found `Vec<_>`\n    |               |\n    |               arguments to this enum variant are incorrect\n    |\n    = note: expected struct `ast::Concat`\n               found struct `Vec<_>`\nnote: tuple variant defined here\n   --> regex-syntax/src/ast/mod.rs:499:5\n    |\n499 |     Concat(Concat),\n    |     ^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 35 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Class(Class::Unicode(ref x)) or Ast::Class(Class::Bracketed(ref x)) or Ast::Class(Class::Perl(ref x)) is true\n",
        "// constraint: *ast matches Ast::Empty(_) is true\n",
        "// constraint: *ast matches Ast::Class(Class::Unicode(ref x)) is true\n"
      ],
      "input_infer": "test input ranges: Ast::Class(Class::Unicode(ref x)) where x.kind in {OneLetter(c), NamedValue { op: Equal, ref name, ref value }}, Ast::Class(Class::Bracketed(ref x)), Ast::Empty(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Assuming Span has a default implementation",
                "    let ast = Ast::Empty(span);",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.wtr, \"\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let ast = Ast::Empty(span);",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:599:16\n    |\n599 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Assuming Span has a default implementation",
                "    let unicode_class = ClassUnicode {",
                "        span,",
                "        negated: false,",
                "        kind: ClassUnicodeKind::OneLetter('a'),",
                "    };",
                "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ],
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let empty_ast = Ast::Empty(span);",
                  "    writer.visit_post(&empty_ast).unwrap();",
                  "    let expected_empty_output = \"\";",
                  "    assert_eq!(writer.wtr, expected_empty_output);"
                ],
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let empty_ast = Ast::Empty(span);",
                  "    writer.visit_post(&empty_ast).unwrap();",
                  "    let expected_empty_output = \"\";",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    writer.visit_post(&ast_bracketed).unwrap();",
                  "    let expected_bracketed_output = \"]\";",
                  "    assert_eq!(writer.wtr, expected_bracketed_output);"
                ],
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let empty_ast = Ast::Empty(span);",
                  "    writer.visit_post(&empty_ast).unwrap();",
                  "    let expected_empty_output = \"\";",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    writer.visit_post(&ast_bracketed).unwrap();",
                  "    let expected_bracketed_output = \"]\";",
                  "    let perl_class = ClassPerl {",
                  "    span,",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: true,",
                  "    };",
                  "    let ast_perl = Ast::Class(Class::Perl(perl_class));",
                  "    writer.visit_post(&ast_perl).unwrap();",
                  "    let expected_perl_output = r\"\\D\";",
                  "    assert_eq!(writer.wtr, expected_perl_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let empty_ast = Ast::Empty(span);",
                  "    writer.visit_post(&empty_ast).unwrap();",
                  "    let expected_empty_output = \"\";",
                  "    assert_eq!(writer.wtr, expected_empty_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let empty_ast = Ast::Empty(span);",
                  "    writer.visit_post(&empty_ast).unwrap();",
                  "    let expected_empty_output = \"\";",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    writer.visit_post(&ast_bracketed).unwrap();",
                  "    let expected_bracketed_output = \"]\";",
                  "    assert_eq!(writer.wtr, expected_bracketed_output);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'),",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let expected_output = r\"\\p{a}\";",
                  "    let empty_ast = Ast::Empty(span);",
                  "    writer.visit_post(&empty_ast).unwrap();",
                  "    let expected_empty_output = \"\";",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: true,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    writer.visit_post(&ast_bracketed).unwrap();",
                  "    let expected_bracketed_output = \"]\";",
                  "    let perl_class = ClassPerl {",
                  "    span,",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: true,",
                  "    };",
                  "    let ast_perl = Ast::Class(Class::Perl(perl_class));",
                  "    writer.visit_post(&ast_perl).unwrap();",
                  "    let expected_perl_output = r\"\\D\";",
                  "    assert_eq!(writer.wtr, expected_perl_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::OneLetter('a'),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassUnicodeKind::OneLetter('a'),\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::OneLetter('a'),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassUnicodeKind::OneLetter('a'),\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::OneLetter('a'),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassUnicodeKind::OneLetter('a'),\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:616:27\n    |\n616 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:619:11\n    |\n619 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:36\n    |\n621 |     let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::OneLetter('a'),\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:605:25\n    |\n605 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassUnicodeKind::OneLetter('a'),\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:616:27\n    |\n616 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:619:11\n    |\n619 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:621:36\n    |\n621 |     let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:624:22\n    |\n624 |     let perl_class = ClassPerl {\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:626:11\n    |\n626 |     kind: ClassPerlKind::Digit,\n    |           ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:629:31\n    |\n629 |     let ast_perl = Ast::Class(Class::Perl(perl_class));\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Assuming Span has a default implementation",
                "    let unicode_class = ClassUnicode {",
                "        span,",
                "        negated: false,",
                "        kind: ClassUnicodeKind::NamedValue {",
                "            op: ast::ClassUnicodeOpKind::Equal,",
                "            name: String::from(\"name\"),",
                "            value: String::from(\"value\"),",
                "        },",
                "    };",
                "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\p{name=value}\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut empty_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    empty_writer.visit_post(&empty_ast).unwrap();",
                  "    assert_eq!(empty_writer.wtr, \"\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut empty_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    empty_writer.visit_post(&empty_ast).unwrap();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut bracketed_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    bracketed_writer.visit_post(&ast_bracketed).unwrap();",
                  "    assert_eq!(bracketed_writer.wtr, \"]\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut empty_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    empty_writer.visit_post(&empty_ast).unwrap();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut bracketed_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    bracketed_writer.visit_post(&ast_bracketed).unwrap();",
                  "    let perl_class = ClassPerl {",
                  "    span,",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(Class::Perl(perl_class));",
                  "    let mut perl_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    perl_writer.visit_post(&ast_perl).unwrap();",
                  "    assert_eq!(perl_writer.wtr, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            op: ast::ClassUnicodeOpKind::Equal,",
                  "            name: String::from(\"name\"),",
                  "            value: String::from(\"value\"),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\p{name=value}\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            op: ast::ClassUnicodeOpKind::Equal,",
                  "            name: String::from(\"name\"),",
                  "            value: String::from(\"value\"),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut empty_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    empty_writer.visit_post(&empty_ast).unwrap();",
                  "    assert_eq!(empty_writer.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            op: ast::ClassUnicodeOpKind::Equal,",
                  "            name: String::from(\"name\"),",
                  "            value: String::from(\"value\"),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut empty_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    empty_writer.visit_post(&empty_ast).unwrap();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut bracketed_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    bracketed_writer.visit_post(&ast_bracketed).unwrap();",
                  "    assert_eq!(bracketed_writer.wtr, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let unicode_class = ClassUnicode {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassUnicodeKind::NamedValue {",
                  "            op: ast::ClassUnicodeOpKind::Equal,",
                  "            name: String::from(\"name\"),",
                  "            value: String::from(\"value\"),",
                  "        },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::NamedValue {",
                  "    op: ast::ClassUnicodeOpKind::Equal,",
                  "    name: String::from(\"name\"),",
                  "    value: String::from(\"value\"),",
                  "    },",
                  "    };",
                  "    let ast = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut empty_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    empty_writer.visit_post(&empty_ast).unwrap();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut bracketed_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    bracketed_writer.visit_post(&ast_bracketed).unwrap();",
                  "    let perl_class = ClassPerl {",
                  "    span,",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(Class::Perl(perl_class));",
                  "    let mut perl_writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    perl_writer.visit_post(&ast_perl).unwrap();",
                  "    assert_eq!(perl_writer.wtr, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::NamedValue {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:16\n    |\n608 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:609:25\n    |\n609 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:11\n    |\n612 |     kind: ClassUnicodeKind::NamedValue {\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::NamedValue {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:16\n    |\n608 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:609:25\n    |\n609 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:11\n    |\n612 |     kind: ClassUnicodeKind::NamedValue {\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::NamedValue {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:16\n    |\n608 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:609:25\n    |\n609 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:11\n    |\n612 |     kind: ClassUnicodeKind::NamedValue {\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:625:27\n    |\n625 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:628:11\n    |\n628 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:630:36\n    |\n630 |     let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:595:25\n    |\n595 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassUnicodeKind::NamedValue {\n    |               ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:604:26\n    |\n604 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:608:16\n    |\n608 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:609:25\n    |\n609 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:612:11\n    |\n612 |     kind: ClassUnicodeKind::NamedValue {\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:618:26\n    |\n618 |     let ast = Ast::Class(Class::Unicode(unicode_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:625:27\n    |\n625 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:628:11\n    |\n628 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:630:36\n    |\n630 |     let ast_bracketed = Ast::Class(Class::Bracketed(bracketed_class));\n    |                                    ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:633:22\n    |\n633 |     let perl_class = ClassPerl {\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:635:11\n    |\n635 |     kind: ClassPerlKind::Digit,\n    |           ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:638:31\n    |\n638 |     let ast_perl = Ast::Class(Class::Perl(perl_class));\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::default(); // Assuming Span has a default implementation",
                "    let bracketed_class = ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder",
                "    };",
                "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"]\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut writer_empty = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_empty.visit_post(&empty_ast).unwrap();",
                  "    assert_eq!(writer_empty.wtr, \"\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut writer_empty = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_empty.visit_post(&empty_ast).unwrap();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'), // Assuming this variant exists",
                  "    };",
                  "    let ast_unicode = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut writer_unicode = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_unicode.visit_post(&ast_unicode).unwrap();",
                  "    assert_eq!(writer_unicode.wtr, r\"\\pa\");"
                ],
                [
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut writer_empty = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_empty.visit_post(&empty_ast).unwrap();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'), // Assuming this variant exists",
                  "    };",
                  "    let ast_unicode = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut writer_unicode = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_unicode.visit_post(&ast_unicode).unwrap();",
                  "    let perl_class = ClassPerl {",
                  "    span,",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(Class::Perl(perl_class));",
                  "    let mut writer_perl = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_perl.visit_post(&ast_perl).unwrap();",
                  "    assert_eq!(writer_perl.wtr, r\"\\d\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let bracketed_class = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"]\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let bracketed_class = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut writer_empty = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_empty.visit_post(&empty_ast).unwrap();",
                  "    assert_eq!(writer_empty.wtr, \"\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let bracketed_class = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut writer_empty = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_empty.visit_post(&empty_ast).unwrap();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'), // Assuming this variant exists",
                  "    };",
                  "    let ast_unicode = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut writer_unicode = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_unicode.visit_post(&ast_unicode).unwrap();",
                  "    assert_eq!(writer_unicode.wtr, r\"\\pa\");",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::default(); // Assuming Span has a default implementation",
                  "    let bracketed_class = ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast);",
                  "    let span = Span::default();",
                  "    let bracketed_class = ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    };",
                  "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let empty_ast = Ast::Empty(span);",
                  "    let mut writer_empty = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_empty.visit_post(&empty_ast).unwrap();",
                  "    let unicode_class = ClassUnicode {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassUnicodeKind::OneLetter('a'), // Assuming this variant exists",
                  "    };",
                  "    let ast_unicode = Ast::Class(Class::Unicode(unicode_class));",
                  "    let mut writer_unicode = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_unicode.visit_post(&ast_unicode).unwrap();",
                  "    let perl_class = ClassPerl {",
                  "    span,",
                  "    kind: ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let ast_perl = Ast::Class(Class::Perl(perl_class));",
                  "    let mut writer_perl = Writer { printer: &mut printer, wtr: String::new() };",
                  "    writer_perl.visit_post(&ast_perl).unwrap();",
                  "    assert_eq!(writer_perl.wtr, r\"\\d\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:27\n    |\n595 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:27\n    |\n605 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:27\n    |\n595 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:27\n    |\n605 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:27\n    |\n595 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:27\n    |\n605 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:617:25\n    |\n617 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:11\n    |\n620 |     kind: ClassUnicodeKind::OneLetter('a'), // Assuming this variant exists\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:622:34\n    |\n622 |     let ast_unicode = Ast::Class(Class::Unicode(unicode_class));\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::default(); // Assuming Span has a default implementation\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:595:27\n    |\n595 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:598:15\n    |\n598 |         kind: ClassSet::Normal, // Assuming ClassSet has variants, using a placeholder\n    |               ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:600:26\n    |\n600 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:604:16\n    |\n604 |     let span = Span::default();\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassBracketed` in this scope\n   --> regex-syntax/src/ast/print.rs:605:27\n    |\n605 |     let bracketed_class = ClassBracketed {\n    |                           ^^^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassBracketed;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n   --> regex-syntax/src/ast/print.rs:608:11\n    |\n608 |     kind: ClassSet::Normal,\n    |           ^^^^^^^^ use of undeclared type `ClassSet`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassSet;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:610:26\n    |\n610 |     let ast = Ast::Class(Class::Bracketed(bracketed_class));\n    |                          ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassUnicode` in this scope\n   --> regex-syntax/src/ast/print.rs:617:25\n    |\n617 |     let unicode_class = ClassUnicode {\n    |                         ^^^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these structs\n    |\n589 +    use ast::ClassUnicode;\n    |\n589 +    use hir::ClassUnicode;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicodeKind`\n   --> regex-syntax/src/ast/print.rs:620:11\n    |\n620 |     kind: ClassUnicodeKind::OneLetter('a'), // Assuming this variant exists\n    |           ^^^^^^^^^^^^^^^^ use of undeclared type `ClassUnicodeKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassUnicodeKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:622:34\n    |\n622 |     let ast_unicode = Ast::Class(Class::Unicode(unicode_class));\n    |                                  ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `ClassPerl` in this scope\n   --> regex-syntax/src/ast/print.rs:625:22\n    |\n625 |     let perl_class = ClassPerl {\n    |                      ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::ClassPerl;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassPerlKind`\n   --> regex-syntax/src/ast/print.rs:627:11\n    |\n627 |     kind: ClassPerlKind::Digit,\n    |           ^^^^^^^^^^^^^ use of undeclared type `ClassPerlKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::ClassPerlKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Class`\n   --> regex-syntax/src/ast/print.rs:630:31\n    |\n630 |     let ast_perl = Ast::Class(Class::Perl(perl_class));\n    |                               ^^^^^ use of undeclared type `Class`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::Class;\n    |\n589 +    use hir::Class;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Assertion(ref x) is true\n",
        "// constraint: *ast matches Ast::Assertion(ref x) is true\n"
      ],
      "input_infer": "Ast::Assertion(loc) where loc spans various valid unicode characters, location starts at 0 and ends at a maximum of 100 (inclusive) while ensuring the kind of AssertionKind is one of the valid values.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"^\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, \"^\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:73\n    |\n596 |     let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };\n    |                                                                         ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:73\n    |\n601 |     let assertion = Assertion { span: Span { start: 0, end: 10 }, kind: AssertionKind::StartLine };\n    |                                                                         ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let expected_output = r\"$\";",
                  "    assert_eq!(writer.wtr, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let expected_output = r\"$\";",
                  "    assert_eq!(writer.wtr, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:74\n    |\n596 |     let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:599:21\n    |\n599 |     let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:599:39\n    |\n599 |     let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:599:74\n    |\n599 |     let assertion = Assertion { span: Span { start: 20, end: 30 }, kind: AssertionKind::EndLine };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\A\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\A\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:74\n    |\n596 |     let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:74\n    |\n601 |     let assertion = Assertion { span: Span { start: 40, end: 50 }, kind: AssertionKind::StartText };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(writer.visit_post(&ast).unwrap(), fmt::Result::Ok);"
                ],
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(writer.wtr, r\"\\z\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(writer.visit_post(&ast).unwrap(), fmt::Result::Ok);",
                  "}"
                ],
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    assert_eq!(writer.wtr, r\"\\z\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:74\n    |\n596 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:74\n    |\n601 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0308]: mismatched types\n   --> regex-syntax/src/ast/print.rs:603:50\n    |\n603 |     assert_eq!(writer.visit_post(&ast).unwrap(), fmt::Result::Ok);\n    |                                                  ^^^^^^^^^^^^^^^ expected `()`, found enum constructor\n    |\n    = note:     expected unit type `()`\n            found enum constructor `fn(()) -> std::result::Result<(), std::fmt::Error> {std::result::Result::<(), std::fmt::Error>::Ok}`\n\nerror[E0277]: `fn(()) -> std::result::Result<(), std::fmt::Error> {std::result::Result::<(), std::fmt::Error>::Ok}` doesn't implement `Debug`\n   --> regex-syntax/src/ast/print.rs:603:5\n    |\n603 |     assert_eq!(writer.visit_post(&ast).unwrap(), fmt::Result::Ok);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `fn(()) -> std::result::Result<(), std::fmt::Error> {std::result::Result::<(), std::fmt::Error>::Ok}` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n    |\n    = help: the trait `Debug` is not implemented for fn item `fn(()) -> std::result::Result<(), std::fmt::Error> {std::result::Result::<(), std::fmt::Error>::Ok}`\n    = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0308, E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:74\n    |\n596 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:74\n    |\n601 |     let assertion = Assertion { span: Span { start: 60, end: 70 }, kind: AssertionKind::EndText };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\b\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\b\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:74\n    |\n596 |     let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:74\n    |\n601 |     let assertion = Assertion { span: Span { start: 80, end: 90 }, kind: AssertionKind::WordBoundary };\n    |                                                                          ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut printer = Printer { _priv: () };",
                "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                "    let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };",
                "    let ast = Ast::Assertion(assertion);",
                "    writer.visit_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\B\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    let mut printer = Printer { _priv: () };",
                  "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
                  "    let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    writer.visit_post(&ast).unwrap();",
                  "    assert_eq!(writer.wtr, r\"\\B\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:596:21\n    |\n596 |     let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:596:39\n    |\n596 |     let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:596:75\n    |\n596 |     let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };\n    |                                                                           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:601:21\n    |\n601 |     let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Span` in this scope\n   --> regex-syntax/src/ast/print.rs:601:39\n    |\n601 |     let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };\n    |                                       ^^^^ not found in this scope\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:601:75\n    |\n601 |     let assertion = Assertion { span: Span { start: 90, end: 100 }, kind: AssertionKind::NotWordBoundary };\n    |                                                                           ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches Ast::Dot(_) is true\n",
        "// constraint: *ast matches Ast::Dot(_) is true\n"
      ],
      "input_infer": "test input ranges: 1 to 1 (for Ast::Dot)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1); // Assuming Span::new takes two usize parameters",
                "    let ast = Ast::Dot(span);",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "    ",
                "    let result = writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \".\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1); // Assuming Span::new takes two usize parameters",
                  "    let ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    ",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1); // Assuming Span::new takes two usize parameters",
                  "    let ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    ",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \".\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1); // Assuming Span::new takes two usize parameters\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1); // Assuming Span::new takes two usize parameters\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1);",
                "    let ast = Ast::Empty(span);",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "",
                "    let result = writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let ast = Ast::Empty(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \"\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:600:16\n    |\n600 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1);",
                "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                "    let ast = Ast::Literal(literal);",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "",
                "    let result = writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 1);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };",
                  "    let ast = Ast::Literal(literal);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \"a\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:595:19\n    |\n595 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:19\n    |\n602 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:41\n    |\n602 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:595:19\n    |\n595 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:595:41\n    |\n595 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n   --> regex-syntax/src/ast/print.rs:602:19\n    |\n602 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                   ^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Literal;\n    |\n589 +    use ast::ClassSetItem::Literal;\n    |\n589 +    use ast::Literal;\n    |\n589 +    use hir::HirKind::Literal;\n    |\n      and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n   --> regex-syntax/src/ast/print.rs:602:41\n    |\n602 |     let literal = Literal { span, kind: LiteralKind::Verbatim, c: 'a' };\n    |                                         ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::LiteralKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1);",
                "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                "    let ast = Ast::Assertion(assertion);",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "",
                "    let result = writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let dot_ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&dot_ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let dot_ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&dot_ast);",
                  "    assert_eq!(output, \".\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let dot_ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&dot_ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let assertion = Assertion { span, kind: AssertionKind::StartLine };",
                  "    let ast = Ast::Assertion(assertion);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let dot_ast = Ast::Dot(span);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&dot_ast);",
                  "    assert_eq!(output, \".\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:21\n    |\n595 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:45\n    |\n595 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:21\n    |\n602 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:45\n    |\n602 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:21\n    |\n595 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:45\n    |\n595 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:21\n    |\n602 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:45\n    |\n602 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:595:21\n    |\n595 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:595:45\n    |\n595 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Assertion` in this scope\n   --> regex-syntax/src/ast/print.rs:602:21\n    |\n602 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                     ^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Assertion;\n    |\n589 +    use ast::Ast::Assertion;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `AssertionKind`\n   --> regex-syntax/src/ast/print.rs:602:45\n    |\n602 |     let assertion = Assertion { span, kind: AssertionKind::StartLine };\n    |                                             ^^^^^^^^^^^^^ use of undeclared type `AssertionKind`\n    |\nhelp: consider importing this enum\n    |\n589 +    use ast::AssertionKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:607:16\n    |\n607 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1);",
                "    let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };",
                "    let ast = Ast::Repetition(repetition);",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "",
                "    let result = writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    output.push_str(\".\");",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    output.push_str(\".\");",
                  "    assert_eq!(output, \".\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    output.push_str(\".\");",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Repetition(repetition);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    output.push_str(\".\");",
                  "    assert_eq!(output, \".\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:595:22\n    |\n595 |     let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:595:45\n    |\n595 |     let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };\n    |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Repetition` in this scope\n   --> regex-syntax/src/ast/print.rs:595:22\n    |\n595 |     let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };\n    |                      ^^^^^^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Repetition;\n    |\n589 +    use ast::Repetition;\n    |\n589 +    use hir::HirKind::Repetition;\n    |\n589 +    use hir::Repetition;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `RepetitionOp`\n   --> regex-syntax/src/ast/print.rs:595:45\n    |\n595 |     let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(span)) };\n    |                                             ^^^^^^^^^^^^ use of undeclared type `RepetitionOp`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::RepetitionOp;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span::new(1, 1);",
                "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                "    let ast = Ast::Group(group);",
                "    let mut output = String::new();",
                "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                "",
                "    let result = writer.visit_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span::new(1, 1);",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span::new(1, 1);",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span::new(1, 1);",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "",
                  "    let result = writer.visit_post(&ast);",
                  "    let span = Span::new(1, 1);",
                  "    let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };",
                  "    let ast = Ast::Group(group);",
                  "    let mut output = String::new();",
                  "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
                  "    let result = writer.visit_post(&ast);",
                  "    assert_eq!(output, \")\");",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:595:17\n    |\n595 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:595:37\n    |\n595 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:602:17\n    |\n602 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:602:37\n    |\n602 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/ast/print.rs:590:8\n    |\n590 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:594:16\n    |\n594 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:595:17\n    |\n595 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:595:37\n    |\n595 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `Span`\n   --> regex-syntax/src/ast/print.rs:601:16\n    |\n601 |     let span = Span::new(1, 1);\n    |                ^^^^ use of undeclared type `Span`\n    |\nhelp: consider importing this struct\n    |\n589 +    use ast::Span;\n    |\n\nerror[E0422]: cannot find struct, variant or union type `Group` in this scope\n   --> regex-syntax/src/ast/print.rs:602:17\n    |\n602 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                 ^^^^^ not found in this scope\n    |\nhelp: consider importing one of these items\n    |\n589 +    use ast::Ast::Group;\n    |\n589 +    use ast::Group;\n    |\n589 +    use hir::Group;\n    |\n589 +    use hir::HirKind::Group;\n    |\n\nerror[E0433]: failed to resolve: use of undeclared type `GroupKind`\n   --> regex-syntax/src/ast/print.rs:602:37\n    |\n602 |     let group = Group { span, kind: GroupKind::Normal, ast: Box::new(Ast::Dot(span)) };\n    |                                     ^^^^^^^^^ use of undeclared type `GroupKind`\n    |\nhelp: consider importing one of these enums\n    |\n589 +    use ast::GroupKind;\n    |\n589 +    use hir::GroupKind;\n    |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}