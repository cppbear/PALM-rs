[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = vec![0xC2, 0xA0]; // Non-breaking space (U+00A0)",
          "    let result = escape_unicode(&bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = vec![0xC2, 0xA0];",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\u{00a0}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes = vec![0xC2, 0xA0]; // Non-breaking space (U+00A0)",
            "    let result = escape_unicode(&bytes);",
            "    let bytes = vec![0xC2, 0xA0];",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\u{00a0}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = vec![0xE2, 0x80, 0xA8]; // Pop directional formatting (U+2028)",
          "    let result = escape_unicode(&bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = vec![0xE2, 0x80, 0xA8]; // Pop directional formatting (U+2028)",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\u{2028}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes = vec![0xE2, 0x80, 0xA8]; // Pop directional formatting (U+2028)",
            "    let result = escape_unicode(&bytes);",
            "    let bytes = vec![0xE2, 0x80, 0xA8]; // Pop directional formatting (U+2028)",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\u{2028}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = vec![0xF0, 0x9F, 0xA6, 0x9D]; // U+1F913 (NERDY FACE emoji)",
          "    let result = escape_unicode(&bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = vec![0xF0, 0x9F, 0xA6, 0x9D];",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\U{1f913}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes = vec![0xF0, 0x9F, 0xA6, 0x9D]; // U+1F913 (NERDY FACE emoji)",
            "    let result = escape_unicode(&bytes);",
            "    let bytes = vec![0xF0, 0x9F, 0xA6, 0x9D];",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\U{1f913}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = vec![0x61, 0x62, 0x63]; // 'abc'",
          "    let result = escape_unicode(&bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = vec![0x61, 0x62, 0x63]; // 'abc'",
            "    let expected = \"abc\";",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes = vec![0x61, 0x62, 0x63]; // 'abc'",
            "    let result = escape_unicode(&bytes);",
            "    let bytes = vec![0x61, 0x62, 0x63]; // 'abc'",
            "    let expected = \"abc\";",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = vec![0x20, 0xC2, 0xA0, 0x20]; // \" \" (non-breaking space)",
          "    let result = escape_unicode(&bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = vec![0x20, 0xC2, 0xA0, 0x20]; // \" \" (non-breaking space)",
            "    assert_eq!(result, r\"\\u{00a0}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes = vec![0x20, 0xC2, 0xA0, 0x20]; // \" \" (non-breaking space)",
            "    let result = escape_unicode(&bytes);",
            "    let bytes = vec![0x20, 0xC2, 0xA0, 0x20]; // \" \" (non-breaking space)",
            "    assert_eq!(result, r\"\\u{00a0}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes = vec![0xF4, 0x8F, 0xBF, 0xBF]; // U+10FFFF (maximum valid Unicode code point)",
          "    let result = escape_unicode(&bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes = vec![0xF4, 0x8F, 0xBF, 0xBF];",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\U{10ffff}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes = vec![0xF4, 0x8F, 0xBF, 0xBF]; // U+10FFFF (maximum valid Unicode code point)",
            "    let result = escape_unicode(&bytes);",
            "    let bytes = vec![0xF4, 0x8F, 0xBF, 0xBF];",
            "    let result = escape_unicode(&bytes);",
            "    assert_eq!(result, r\"\\U{10ffff}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]