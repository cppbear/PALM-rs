[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let limit_size = 512;",
          "    let limit_class = 5;",
          "    ",
          "    let mut lits = Literals {",
          "        lits: vec![Literal::new(vec![1, 2, 3])],",
          "        limit_size,",
          "        limit_class,",
          "    };",
          "    ",
          "    let expr = Hir {",
          "        kind: HirKind::SomeKind,",
          "        info: HirInfo::default(),",
          "    };",
          "",
          "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
          "        lits3.add(Literal::new(vec![4, 5, 6]));",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_size(), limit_size);"
          ],
          [
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_class(), limit_class);"
          ],
          [
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert!(!lits.is_empty());"
          ],
          [
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals().len(), 1);"
          ],
          [
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals()[0].v, vec![1, 2, 3]);"
          ],
          [
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert!(lits.literals()[0].is_cut() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    ",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![1, 2, 3])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "    ",
            "    let expr = Hir {",
            "        kind: HirKind::SomeKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![4, 5, 6]));",
            "    });",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_size(), limit_size);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    ",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![1, 2, 3])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "    ",
            "    let expr = Hir {",
            "        kind: HirKind::SomeKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![4, 5, 6]));",
            "    });",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_class(), limit_class);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    ",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![1, 2, 3])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "    ",
            "    let expr = Hir {",
            "        kind: HirKind::SomeKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![4, 5, 6]));",
            "    });",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert!(!lits.is_empty());",
            "}"
          ],
          [
            "{",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    ",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![1, 2, 3])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "    ",
            "    let expr = Hir {",
            "        kind: HirKind::SomeKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![4, 5, 6]));",
            "    });",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    ",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![1, 2, 3])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "    ",
            "    let expr = Hir {",
            "        kind: HirKind::SomeKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![4, 5, 6]));",
            "    });",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals()[0].v, vec![1, 2, 3]);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    ",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![1, 2, 3])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "    ",
            "    let expr = Hir {",
            "        kind: HirKind::SomeKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![4, 5, 6]));",
            "    });",
            "    let limit_size = 512;",
            "    let limit_class = 5;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![1, 2, 3])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
            "    assert!(lits.literals()[0].is_cut() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let limit_size = 256;",
          "    let limit_class = 3;",
          "",
          "    let mut lits = Literals {",
          "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
          "        limit_size,",
          "        limit_class,",
          "    };",
          "",
          "    let expr = Hir {",
          "        kind: HirKind::AnotherKind,",
          "        info: HirInfo::default(),",
          "    };",
          "",
          "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
          "        lits3.add(Literal::new(vec![12, 13]));",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_size(), limit_size);"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_class, limit_class);"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals().len(), 2);"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals()[0].v, vec![7, 8, 9]);"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals()[1].v, vec![10, 11]);"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert!(!lits.is_empty());"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert!(lits.any_complete());"
          ],
          [
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert!(!lits.all_complete());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_size(), limit_size);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.limit_class, limit_class);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals().len(), 2);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals()[0].v, vec![7, 8, 9]);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert_eq!(lits.literals()[1].v, vec![10, 11]);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert!(!lits.is_empty());",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert!(lits.any_complete());",
            "}"
          ],
          [
            "{",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::AnotherKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![12, 13]));",
            "    });",
            "    let limit_size = 256;",
            "    let limit_class = 3;",
            "    let mut lits = Literals { lits: vec![Literal::new(vec![7, 8, 9]), Literal::new(vec![10, 11])], limit_size, limit_class };",
            "    let expr = Hir { kind: HirKind::AnotherKind, info: HirInfo::default() };",
            "    assert!(!lits.all_complete());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let limit_size = 1024;",
          "    let limit_class = 10;",
          "",
          "    let mut lits = Literals {",
          "        lits: vec![Literal::new(vec![14, 15])],",
          "        limit_size,",
          "        limit_class,",
          "    };",
          "",
          "    let expr = Hir {",
          "        kind: HirKind::DifferentKind,",
          "        info: HirInfo::default(),",
          "    };",
          "",
          "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
          "        lits3.add(Literal::new(vec![16]));",
          "        lits3.add(Literal::new(vec![17, 18]));",
          "    });",
          "}"
        ],
        "oracles": [
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(lits3.limit_size() == limit_size / 2);"
          ],
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(lits.lits.len() == 1);"
          ],
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(lits.lits[0].v == vec![14, 15]);"
          ],
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(!lits3.is_empty());"
          ],
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    let result_cross_product = lits.cross_product(&lits3);",
            "    assert!(result_cross_product);"
          ],
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    let result_cross_product = lits.cross_product(&lits3);",
            "    let result_union = lits.union(lits.clone());",
            "    assert!(result_union);"
          ],
          [
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    let result_cross_product = lits.cross_product(&lits3);",
            "    let result_union = lits.union(lits.clone());",
            "    assert!(lits.lits.len() > 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(lits3.limit_size() == limit_size / 2);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(lits.lits.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(lits.lits[0].v == vec![14, 15]);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    assert!(!lits3.is_empty());",
            "}"
          ],
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    let result_cross_product = lits.cross_product(&lits3);",
            "    assert!(result_cross_product);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    let result_cross_product = lits.cross_product(&lits3);",
            "    let result_union = lits.union(lits.clone());",
            "    assert!(result_union);",
            "}"
          ],
          [
            "{",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "",
            "    let mut lits = Literals {",
            "        lits: vec![Literal::new(vec![14, 15])],",
            "        limit_size,",
            "        limit_class,",
            "    };",
            "",
            "    let expr = Hir {",
            "        kind: HirKind::DifferentKind,",
            "        info: HirInfo::default(),",
            "    };",
            "",
            "    repeat_zero_or_one_literals(&expr, &mut lits, |e, lits3| {",
            "        lits3.add(Literal::new(vec![16]));",
            "        lits3.add(Literal::new(vec![17, 18]));",
            "    });",
            "    let limit_size = 1024;",
            "    let limit_class = 10;",
            "    let mut lits = Literals {",
            "    lits: vec![Literal::new(vec![14, 15])],",
            "    limit_size,",
            "    limit_class,",
            "    };",
            "    let expr = Hir {",
            "    kind: HirKind::DifferentKind,",
            "    info: HirInfo::default(),",
            "    };",
            "    let lits3 = lits.to_empty();",
            "    let result_cross_product = lits.cross_product(&lits3);",
            "    let result_union = lits.union(lits.clone());",
            "    assert!(lits.lits.len() > 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]