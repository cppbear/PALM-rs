[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 0 };",
          "    let ast = Ast::Empty(span);",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 0 };",
            "    let ast = Ast::Empty(span);",
            "    let mut formatter = String::new();",
            "    assert!(formatter.is_empty());"
          ],
          [
            "    let span = Span { start: 0, end: 0 };",
            "    let ast = Ast::Empty(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 0 };",
            "    let ast = Ast::Empty(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 0 };",
            "    let ast = Ast::Empty(span);",
            "    let mut formatter = String::new();",
            "    assert!(formatter.is_empty());",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 0 };",
            "    let ast = Ast::Empty(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 0 };",
            "    let ast = Ast::Empty(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let literal = Literal::Unicode('a');",
          "    let ast = Ast::Literal(Literal { span, kind: literal, c: 'a' });",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = Literal::Unicode('a');",
            "    let ast = Ast::Literal(Literal { span, kind: literal, c: 'a' });",
            "    let expected_output = \"a\"; // Expect the output to be the character 'a'",
            "    assert_eq!(formatter, expected_output);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = Literal::Unicode('a');",
            "    let ast = Ast::Literal(Literal { span, kind: literal, c: 'a' });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = Literal::Unicode('a');",
            "    let ast = Ast::Literal(Literal { span, kind: literal, c: 'a' });",
            "    let expected_output = \"a\"; // Expect the output to be the character 'a'",
            "    assert_eq!(formatter, expected_output);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let ast = Ast::Dot(span);",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert!(!formatter.is_empty());"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"expected_output_for_dot_ast\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert!(!formatter.is_empty());",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 1 };",
            "    let ast = Ast::Dot(span);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"expected_output_for_dot_ast\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let assertion = Assertion { span, kind: AssertionKind::StartOfLine };",
          "    let ast = Ast::Assertion(assertion);",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let assertion = Assertion { span, kind: AssertionKind::StartOfLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"<expected output for StartOfLine assertion>\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let assertion = Assertion { span, kind: AssertionKind::StartOfLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 1 };",
            "    let assertion = Assertion { span, kind: AssertionKind::StartOfLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"<expected output for StartOfLine assertion>\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let literal_a = Literal { v: vec![97], cut: false }; // 'a'",
          "    let literal_b = Literal { v: vec![98], cut: false }; // 'b'",
          "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
          "    let ast = Ast::Concat(Concat { span, asts });",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Concat(Concat { span, asts });",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"ab\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false }; // 'a'",
            "    let literal_b = Literal { v: vec![98], cut: false }; // 'b'",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Concat(Concat { span, asts });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Concat(Concat { span, asts });",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"ab\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
          "    let ast = Ast::Repetition(Repetition {",
          "        kind: RepetitionKind::ZeroOrMore,",
          "        greedy: true,",
          "        hir: Box::new(Ast::Literal(literal)),",
          "    });",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false };",
            "    let ast = Ast::Repetition(Repetition {",
            "    kind: RepetitionKind::ZeroOrMore,",
            "    greedy: true,",
            "    hir: Box::new(Ast::Literal(literal)),",
            "    });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"a*\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
            "    let ast = Ast::Repetition(Repetition {",
            "        kind: RepetitionKind::ZeroOrMore,",
            "        greedy: true,",
            "        hir: Box::new(Ast::Literal(literal)),",
            "    });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false };",
            "    let ast = Ast::Repetition(Repetition {",
            "    kind: RepetitionKind::ZeroOrMore,",
            "    greedy: true,",
            "    hir: Box::new(Ast::Literal(literal)),",
            "    });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"a*\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
          "    let ast = Ast::Repetition(Repetition {",
          "        kind: RepetitionKind::ZeroOrMore,",
          "        greedy: false,",
          "        hir: Box::new(Ast::Literal(literal)),",
          "    });",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
            "    let ast = Ast::Repetition(Repetition {",
            "    kind: RepetitionKind::ZeroOrMore,",
            "    greedy: false,",
            "    hir: Box::new(Ast::Literal(literal)),",
            "    });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"a*\");  // Assuming representation of zero or more of 'a' is \"a*\""
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
            "    let ast = Ast::Repetition(Repetition {",
            "        kind: RepetitionKind::ZeroOrMore,",
            "        greedy: false,",
            "        hir: Box::new(Ast::Literal(literal)),",
            "    });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
            "    let ast = Ast::Repetition(Repetition {",
            "    kind: RepetitionKind::ZeroOrMore,",
            "    greedy: false,",
            "    hir: Box::new(Ast::Literal(literal)),",
            "    });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, \"a*\");  // Assuming representation of zero or more of 'a' is \"a*\"",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let literal_a = Literal { v: vec![97], cut: false }; // 'a'",
          "    let literal_b = Literal { v: vec![98], cut: false }; // 'b'",
          "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
          "    let ast = Ast::Alternation(Alternation { span, asts });",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"\");"
          ],
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    assert!(ast.fmt(&mut formatter).is_ok());"
          ],
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"a|b\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false }; // 'a'",
            "    let literal_b = Literal { v: vec![98], cut: false }; // 'b'",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false }; // 'a'",
            "    let literal_b = Literal { v: vec![98], cut: false }; // 'b'",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    assert!(ast.fmt(&mut formatter).is_ok());",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false }; // 'a'",
            "    let literal_b = Literal { v: vec![98], cut: false }; // 'b'",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal_a = Literal { v: vec![97], cut: false };",
            "    let literal_b = Literal { v: vec![98], cut: false };",
            "    let asts = vec![Ast::Literal(literal_a), Ast::Literal(literal_b)];",
            "    let ast = Ast::Alternation(Alternation { span, asts });",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter, \"a|b\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
          "    let group = Group {",
          "        span,",
          "        kind: GroupKind::Capturing(0),",
          "        ast: Box::new(Ast::Literal(literal)),",
          "    };",
          "    let ast = Ast::Group(group);",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false };",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(0),",
            "    ast: Box::new(Ast::Literal(literal)),",
            "    };",
            "    let ast = Ast::Group(group);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, expected_output);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false }; // 'a'",
            "    let group = Group {",
            "        span,",
            "        kind: GroupKind::Capturing(0),",
            "        ast: Box::new(Ast::Literal(literal)),",
            "    };",
            "    let ast = Ast::Group(group);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let literal = Literal { v: vec![97], cut: false };",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(0),",
            "    ast: Box::new(Ast::Literal(literal)),",
            "    };",
            "    let ast = Ast::Group(group);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter, expected_output);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 3 };",
          "    let class = Class::Unicode(ClassUnicode::Latin);",
          "    let ast = Ast::Class(class);",
          "    let mut formatter = String::new();",
          "    ast.fmt(&mut formatter).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter.len(), 0);"
          ],
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(formatter.is_empty());"
          ],
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(ast.fmt(&mut formatter).is_ok());"
          ],
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(!formatter.is_empty());"
          ],
          [
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(formatter.contains(\"Unicode\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert_eq!(formatter.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(formatter.is_empty());",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(ast.fmt(&mut formatter).is_ok());",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(!formatter.is_empty());",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    ast.fmt(&mut formatter).unwrap();",
            "    let span = Span { start: 0, end: 3 };",
            "    let class = Class::Unicode(ClassUnicode::Latin);",
            "    let ast = Ast::Class(class);",
            "    let mut formatter = String::new();",
            "    assert!(formatter.contains(\"Unicode\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]