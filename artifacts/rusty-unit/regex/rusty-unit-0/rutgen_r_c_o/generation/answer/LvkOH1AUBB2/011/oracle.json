[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let spans = Spans {",
          "        pattern: \"abc\",",
          "        line_number_width: 0,",
          "        by_line: vec![vec![",
          "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }",
          "        ]],",
          "        multi_line: vec![],",
          "    };",
          "    let result = spans.notate_line(0);",
          "}"
        ],
        "oracles": [
          [
            "    let spans = Spans {",
            "    pattern: \"abc\",",
            "    line_number_width: 0,",
            "    by_line: vec![vec![",
            "    ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }",
            "    ]],",
            "    multi_line: vec![],",
            "    };",
            "    assert_eq!(result, Some(\"  ^\".to_string()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\",",
            "        line_number_width: 0,",
            "        by_line: vec![vec![",
            "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }",
            "        ]],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(0);",
            "    let spans = Spans {",
            "    pattern: \"abc\",",
            "    line_number_width: 0,",
            "    by_line: vec![vec![",
            "    ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }",
            "    ]],",
            "    multi_line: vec![],",
            "    };",
            "    assert_eq!(result, Some(\"  ^\".to_string()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let spans = Spans {",
          "        pattern: \"abcd\",",
          "        line_number_width: 0,",
          "        by_line: vec![vec![",
          "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } },",
          "            ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }",
          "        ]],",
          "        multi_line: vec![],",
          "    };",
          "    let result = spans.notate_line(0);",
          "}"
        ],
        "oracles": [
          [
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert_eq!(result, Some(\"  ^ ^\".to_string()));"
          ],
          [
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert!(result.is_some());"
          ],
          [
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert!(result.as_ref().unwrap().len() > 0);"
          ],
          [
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert!(result.as_ref().unwrap().chars().nth(0).unwrap() == ' ');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abcd\",",
            "        line_number_width: 0,",
            "        by_line: vec![vec![",
            "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } },",
            "            ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }",
            "        ]],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(0);",
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert_eq!(result, Some(\"  ^ ^\".to_string()));",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abcd\",",
            "        line_number_width: 0,",
            "        by_line: vec![vec![",
            "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } },",
            "            ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }",
            "        ]],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(0);",
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abcd\",",
            "        line_number_width: 0,",
            "        by_line: vec![vec![",
            "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } },",
            "            ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }",
            "        ]],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(0);",
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert!(result.as_ref().unwrap().len() > 0);",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abcd\",",
            "        line_number_width: 0,",
            "        by_line: vec![vec![",
            "            ast::Span { start: Position { column: 2 }, end: Position { column: 3 } },",
            "            ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }",
            "        ]],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(0);",
            "    let spans = Spans { pattern: \"abcd\", line_number_width: 0, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }, ast::Span { start: Position { column: 4 }, end: Position { column: 5 } }]], multi_line: vec![] };",
            "    assert!(result.as_ref().unwrap().chars().nth(0).unwrap() == ' ');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let spans = Spans {",
          "        pattern: \"abcd\\nefgh\",",
          "        line_number_width: 2,",
          "        by_line: vec![",
          "            vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
          "            vec![],",
          "        ],",
          "        multi_line: vec![],",
          "    };",
          "    let result = spans.notate_line(0);",
          "}"
        ],
        "oracles": [
          [
            "    let spans = Spans {",
            "    pattern: \"abcd\\nefgh\",",
            "    line_number_width: 2,",
            "    by_line: vec![",
            "    vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
            "    vec![],",
            "    ],",
            "    multi_line: vec![],",
            "    };",
            "    assert_eq!(result, Some(\"  ^\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abcd\\nefgh\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
            "            vec![],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(0);",
            "    let spans = Spans {",
            "    pattern: \"abcd\\nefgh\",",
            "    line_number_width: 2,",
            "    by_line: vec![",
            "    vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
            "    vec![],",
            "    ],",
            "    multi_line: vec![],",
            "    };",
            "    assert_eq!(result, Some(\"  ^\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let spans = Spans {",
          "        pattern: \"abc\\ndefg\",",
          "        line_number_width: 2,",
          "        by_line: vec![",
          "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
          "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
          "        ],",
          "        multi_line: vec![],",
          "    };",
          "    let result = spans.notate_line(1);",
          "}"
        ],
        "oracles": [
          [
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert_eq!(result, Some(\"  ^^^\".to_string()));"
          ],
          [
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.is_some());"
          ],
          [
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().len() > 0);"
          ],
          [
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().contains(\"^\"));"
          ],
          [
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().chars().nth(0).unwrap() == ' ');"
          ],
          [
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().chars().nth(1).unwrap() == ' ');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\\ndefg\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert_eq!(result, Some(\"  ^^^\".to_string()));",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\\ndefg\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\\ndefg\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().len() > 0);",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\\ndefg\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().contains(\"^\"));",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\\ndefg\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().chars().nth(0).unwrap() == ' ');",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"abc\\ndefg\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"abc\\ndefg\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 2 }, end: Position { column: 3 } }], vec![ast::Span { start: Position { column: 1 }, end: Position { column: 4 } }], ], multi_line: vec![], };",
            "    assert!(result.unwrap().chars().nth(1).unwrap() == ' ');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let spans = Spans {",
          "        pattern: \"xyz\\nuvw\",",
          "        line_number_width: 2,",
          "        by_line: vec![",
          "            vec![],",
          "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
          "        ],",
          "        multi_line: vec![],",
          "    };",
          "    let result = spans.notate_line(1);",
          "}"
        ],
        "oracles": [
          [
            "    let spans = Spans {",
            "    pattern: \"xyz\\nuvw\",",
            "    line_number_width: 2,",
            "    by_line: vec![",
            "    vec![],",
            "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
            "    ],",
            "    multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    assert!(result.is_some());"
          ],
          [
            "    let spans = Spans {",
            "    pattern: \"xyz\\nuvw\",",
            "    line_number_width: 2,",
            "    by_line: vec![",
            "    vec![],",
            "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
            "    ],",
            "    multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    assert_eq!(result, Some(\"  ^\".to_string()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"xyz\\nuvw\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans {",
            "    pattern: \"xyz\\nuvw\",",
            "    line_number_width: 2,",
            "    by_line: vec![",
            "    vec![],",
            "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
            "    ],",
            "    multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"xyz\\nuvw\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![],",
            "            vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans {",
            "    pattern: \"xyz\\nuvw\",",
            "    line_number_width: 2,",
            "    by_line: vec![",
            "    vec![],",
            "    vec![ast::Span { start: Position { column: 1 }, end: Position { column: 1 } }],",
            "    ],",
            "    multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    assert_eq!(result, Some(\"  ^\".to_string()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let spans = Spans {",
          "        pattern: \"line1\\nline2\\nline3\",",
          "        line_number_width: 2,",
          "        by_line: vec![",
          "            vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
          "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }],",
          "            vec![],",
          "        ],",
          "        multi_line: vec![],",
          "    };",
          "    let result = spans.notate_line(1);",
          "}"
        ],
        "oracles": [
          [
            "    let spans = Spans { pattern: \"line1\\nline2\\nline3\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }], vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }], vec![]], multi_line: vec![] };",
            "    let result = spans.notate_line(1);",
            "    assert!(result.is_some());"
          ],
          [
            "    let spans = Spans { pattern: \"line1\\nline2\\nline3\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }], vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }], vec![]], multi_line: vec![] };",
            "    let result = spans.notate_line(1);",
            "    assert_eq!(result.unwrap(), \"  ^^^^^\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"line1\\nline2\\nline3\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }],",
            "            vec![],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"line1\\nline2\\nline3\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }], vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }], vec![]], multi_line: vec![] };",
            "    let result = spans.notate_line(1);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let spans = Spans {",
            "        pattern: \"line1\\nline2\\nline3\",",
            "        line_number_width: 2,",
            "        by_line: vec![",
            "            vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }],",
            "            vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }],",
            "            vec![],",
            "        ],",
            "        multi_line: vec![],",
            "    };",
            "    let result = spans.notate_line(1);",
            "    let spans = Spans { pattern: \"line1\\nline2\\nline3\", line_number_width: 2, by_line: vec![vec![ast::Span { start: Position { column: 3 }, end: Position { column: 4 } }], vec![ast::Span { start: Position { column: 2 }, end: Position { column: 7 } }], vec![]], multi_line: vec![] };",
            "    let result = spans.notate_line(1);",
            "    assert_eq!(result.unwrap(), \"  ^^^^^\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]