[
  {
    "uses": [
      "use ast::Repetition;",
      "use ast::Ast;",
      "use ast::RepetitionOp;",
      "use ast::Group;",
      "use ast::Span;",
      "use ast::GroupKind;",
      "use ast::Literal;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
          "",
          "    let group = Group {",
          "        span: Span::new(0, 1),",
          "        kind: GroupKind::Capturing,",
          "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
          "    };",
          "",
          "    let repetition = Repetition {",
          "        span: Span::new(1, 2),",
          "        op: RepetitionOp::ZeroOrMore,",
          "        greedy: true,",
          "        ast: Box::new(Ast::Dot(Span::new(2, 3))),",
          "    };",
          "",
          "    let alternation_frame = Frame::Alternation {",
          "        head: Box::new(Ast::Group(group)),",
          "        tail: &[Ast::Repetition(repetition)],",
          "    };",
          "",
          "    let _result = alternation_frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
            "    let repetition = Repetition { span: Span::new(1, 2), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span::new(2, 3))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(group)), tail: &[Ast::Repetition(repetition)] };",
            "    assert_eq!(alteration_frame.child(), &Ast::Group(group));"
          ]
        ],
        "codes": [
          [
            "{",
            "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
            "",
            "    let group = Group {",
            "        span: Span::new(0, 1),",
            "        kind: GroupKind::Capturing,",
            "        ast: Box::new(Ast::Literal(Literal::Char('a'))),",
            "    };",
            "",
            "    let repetition = Repetition {",
            "        span: Span::new(1, 2),",
            "        op: RepetitionOp::ZeroOrMore,",
            "        greedy: true,",
            "        ast: Box::new(Ast::Dot(Span::new(2, 3))),",
            "    };",
            "",
            "    let alternation_frame = Frame::Alternation {",
            "        head: Box::new(Ast::Group(group)),",
            "        tail: &[Ast::Repetition(repetition)],",
            "    };",
            "",
            "    let _result = alternation_frame.child();",
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('a'))) };",
            "    let repetition = Repetition { span: Span::new(1, 2), op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span::new(2, 3))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(group)), tail: &[Ast::Repetition(repetition)] };",
            "    assert_eq!(alteration_frame.child(), &Ast::Group(group));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
          "",
          "    let group = Group {",
          "        span: Span::new(0, 1),",
          "        kind: GroupKind::Capturing,",
          "        ast: Box::new(Ast::Literal(Literal::Char('b'))),",
          "    };",
          "",
          "    let alternation_frame = Frame::Alternation {",
          "        head: Box::new(Ast::Group(group)),",
          "        tail: &[],",
          "    };",
          "",
          "    let _result = alternation_frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('b'))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(group)), tail: &[] };",
            "    let expected_result = &Ast::Group(group);",
            "    assert_eq!(_result, expected_result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
            "",
            "    let group = Group {",
            "        span: Span::new(0, 1),",
            "        kind: GroupKind::Capturing,",
            "        ast: Box::new(Ast::Literal(Literal::Char('b'))),",
            "    };",
            "",
            "    let alternation_frame = Frame::Alternation {",
            "        head: Box::new(Ast::Group(group)),",
            "        tail: &[],",
            "    };",
            "",
            "    let _result = alternation_frame.child();",
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('b'))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(group)), tail: &[] };",
            "    let expected_result = &Ast::Group(group);",
            "    assert_eq!(_result, expected_result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
          "",
          "    let group = Group {",
          "        span: Span::new(0, 1),",
          "        kind: GroupKind::Capturing,",
          "        ast: Box::new(Ast::Literal(Literal::Char('c'))),",
          "    };",
          "",
          "    let repetition1 = Repetition {",
          "        span: Span::new(1, 2),",
          "        op: RepetitionOp::OneOrMore,",
          "        greedy: true,",
          "        ast: Box::new(Ast::Dot(Span::new(2, 3))),",
          "    };",
          "",
          "    let repetition2 = Repetition {",
          "        span: Span::new(2, 3),",
          "        op: RepetitionOp::ZeroOrMore,",
          "        greedy: false,",
          "        ast: Box::new(Ast::Literal(Literal::Char('d'))),",
          "    };",
          "",
          "    let alternation_frame = Frame::Alternation {",
          "        head: Box::new(Ast::Group(group)),",
          "        tail: &[Ast::Repetition(repetition1), Ast::Repetition(repetition2)],",
          "    };",
          "",
          "    let _result = alternation_frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('c'))) };",
            "    let repetition1 = Repetition { span: Span::new(1, 2), op: RepetitionOp::OneOrMore, greedy: true, ast: Box::new(Ast::Dot(Span::new(2, 3))) };",
            "    let repetition2 = Repetition { span: Span::new(2, 3), op: RepetitionOp::ZeroOrMore, greedy: false, ast: Box::new(Ast::Literal(Literal::Char('d'))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(group)), tail: &[Ast::Repetition(repetition1), Ast::Repetition(repetition2)] };",
            "    let result = alternation_frame.child();",
            "    assert_eq!(result, &Ast::Group(group));"
          ]
        ],
        "codes": [
          [
            "{",
            "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
            "",
            "    let group = Group {",
            "        span: Span::new(0, 1),",
            "        kind: GroupKind::Capturing,",
            "        ast: Box::new(Ast::Literal(Literal::Char('c'))),",
            "    };",
            "",
            "    let repetition1 = Repetition {",
            "        span: Span::new(1, 2),",
            "        op: RepetitionOp::OneOrMore,",
            "        greedy: true,",
            "        ast: Box::new(Ast::Dot(Span::new(2, 3))),",
            "    };",
            "",
            "    let repetition2 = Repetition {",
            "        span: Span::new(2, 3),",
            "        op: RepetitionOp::ZeroOrMore,",
            "        greedy: false,",
            "        ast: Box::new(Ast::Literal(Literal::Char('d'))),",
            "    };",
            "",
            "    let alternation_frame = Frame::Alternation {",
            "        head: Box::new(Ast::Group(group)),",
            "        tail: &[Ast::Repetition(repetition1), Ast::Repetition(repetition2)],",
            "    };",
            "",
            "    let _result = alternation_frame.child();",
            "    let group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('c'))) };",
            "    let repetition1 = Repetition { span: Span::new(1, 2), op: RepetitionOp::OneOrMore, greedy: true, ast: Box::new(Ast::Dot(Span::new(2, 3))) };",
            "    let repetition2 = Repetition { span: Span::new(2, 3), op: RepetitionOp::ZeroOrMore, greedy: false, ast: Box::new(Ast::Literal(Literal::Char('d'))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(group)), tail: &[Ast::Repetition(repetition1), Ast::Repetition(repetition2)] };",
            "    let result = alternation_frame.child();",
            "    assert_eq!(result, &Ast::Group(group));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
          "",
          "    let capturing_group = Group {",
          "        span: Span::new(0, 1),",
          "        kind: GroupKind::Capturing,",
          "        ast: Box::new(Ast::Literal(Literal::Char('e'))),",
          "    };",
          "",
          "    let non_capturing_group = Group {",
          "        span: Span::new(1, 2),",
          "        kind: GroupKind::NonCapturing,",
          "        ast: Box::new(Ast::Literal(Literal::Char('f'))),",
          "    };",
          "",
          "    let alternation_frame = Frame::Alternation {",
          "        head: Box::new(Ast::Group(capturing_group)),",
          "        tail: &[Ast::Group(non_capturing_group)],",
          "    };",
          "",
          "    let _result = alternation_frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let capturing_group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('e'))) };",
            "    let non_capturing_group = Group { span: Span::new(1, 2), kind: GroupKind::NonCapturing, ast: Box::new(Ast::Literal(Literal::Char('f'))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(capturing_group)), tail: &[Ast::Group(non_capturing_group)] };",
            "    let result = alternation_frame.child();",
            "    assert_eq!(result, &Ast::Group(capturing_group));"
          ]
        ],
        "codes": [
          [
            "{",
            "    use ast::{Ast, Group, Repetition, Span, Literal, GroupKind, RepetitionOp};",
            "",
            "    let capturing_group = Group {",
            "        span: Span::new(0, 1),",
            "        kind: GroupKind::Capturing,",
            "        ast: Box::new(Ast::Literal(Literal::Char('e'))),",
            "    };",
            "",
            "    let non_capturing_group = Group {",
            "        span: Span::new(1, 2),",
            "        kind: GroupKind::NonCapturing,",
            "        ast: Box::new(Ast::Literal(Literal::Char('f'))),",
            "    };",
            "",
            "    let alternation_frame = Frame::Alternation {",
            "        head: Box::new(Ast::Group(capturing_group)),",
            "        tail: &[Ast::Group(non_capturing_group)],",
            "    };",
            "",
            "    let _result = alternation_frame.child();",
            "    let capturing_group = Group { span: Span::new(0, 1), kind: GroupKind::Capturing, ast: Box::new(Ast::Literal(Literal::Char('e'))) };",
            "    let non_capturing_group = Group { span: Span::new(1, 2), kind: GroupKind::NonCapturing, ast: Box::new(Ast::Literal(Literal::Char('f'))) };",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Group(capturing_group)), tail: &[Ast::Group(non_capturing_group)] };",
            "    let result = alternation_frame.child();",
            "    assert_eq!(result, &Ast::Group(capturing_group));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    // This test is designed to panic. Frame::Alternation expects head and tail to be valid",
          "    let alternation_frame = Frame::Alternation {",
          "        head: Box::new(Ast::Empty(Span::new(0, 0))),",
          "        tail: &[],",
          "    };",
          "",
          "    let _result = alternation_frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Empty(Span::new(0, 0))), tail: &[] };",
            "    let result = alternation_frame.child();",
            "    assert_eq!(result, &Ast::Empty(Span::new(0, 0)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    // This test is designed to panic. Frame::Alternation expects head and tail to be valid",
            "    let alternation_frame = Frame::Alternation {",
            "        head: Box::new(Ast::Empty(Span::new(0, 0))),",
            "        tail: &[],",
            "    };",
            "",
            "    let _result = alternation_frame.child();",
            "    let alternation_frame = Frame::Alternation { head: Box::new(Ast::Empty(Span::new(0, 0))), tail: &[] };",
            "    let result = alternation_frame.child();",
            "    assert_eq!(result, &Ast::Empty(Span::new(0, 0)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]