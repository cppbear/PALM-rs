[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span::new(0, 10);",
          "    let literal = Literal::from('a');",
          "    let group = Group {",
          "        span,",
          "        kind: GroupKind::Capturing(0, None),",
          "        ast: Box::new(Ast::Literal(literal)),",
          "    };",
          "    let frame = Frame::Group(&group);",
          "    let result = frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span::new(0, 10);",
            "    let literal = Literal::from('a');",
            "    let group = Group { span, kind: GroupKind::Capturing(0, None), ast: Box::new(Ast::Literal(literal)), };",
            "    let frame = Frame::Group(&group);",
            "    let expected_result = &group.ast;",
            "    assert_eq!(result, expected_result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span::new(0, 10);",
            "    let literal = Literal::from('a');",
            "    let group = Group {",
            "        span,",
            "        kind: GroupKind::Capturing(0, None),",
            "        ast: Box::new(Ast::Literal(literal)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    let span = Span::new(0, 10);",
            "    let literal = Literal::from('a');",
            "    let group = Group { span, kind: GroupKind::Capturing(0, None), ast: Box::new(Ast::Literal(literal)), };",
            "    let frame = Frame::Group(&group);",
            "    let expected_result = &group.ast;",
            "    assert_eq!(result, expected_result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span::new(0, 5);",
          "    let group = Group {",
          "        span,",
          "        kind: GroupKind::Capturing(1, None),",
          "        ast: Box::new(Ast::Empty(span)),",
          "    };",
          "    let frame = Frame::Group(&group);",
          "    let result = frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span::new(0, 5);",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(1, None),",
            "    ast: Box::new(Ast::Empty(span)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    assert_eq!(result, &Ast::Empty(span));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span::new(0, 5);",
            "    let group = Group {",
            "        span,",
            "        kind: GroupKind::Capturing(1, None),",
            "        ast: Box::new(Ast::Empty(span)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    let span = Span::new(0, 5);",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(1, None),",
            "    ast: Box::new(Ast::Empty(span)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    assert_eq!(result, &Ast::Empty(span));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span::new(3, 8);",
          "    let class = Class::new(vec!['a', 'b', 'c']);",
          "    let group = Group {",
          "        span,",
          "        kind: GroupKind::Capturing(2, None),",
          "        ast: Box::new(Ast::Class(class)),",
          "    };",
          "    let frame = Frame::Group(&group);",
          "    let result = frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span::new(3, 8);",
            "    let class = Class::new(vec!['a', 'b', 'c']);",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(2, None),",
            "    ast: Box::new(Ast::Class(class)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    assert_eq!(result, &Ast::Class(class));"
          ],
          [
            "    let span = Span::new(3, 8);",
            "    let class = Class::new(vec!['a', 'b', 'c']);",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(2, None),",
            "    ast: Box::new(Ast::Class(class)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    assert_eq!(result, &group.ast);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span::new(3, 8);",
            "    let class = Class::new(vec!['a', 'b', 'c']);",
            "    let group = Group {",
            "        span,",
            "        kind: GroupKind::Capturing(2, None),",
            "        ast: Box::new(Ast::Class(class)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    let span = Span::new(3, 8);",
            "    let class = Class::new(vec!['a', 'b', 'c']);",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(2, None),",
            "    ast: Box::new(Ast::Class(class)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    assert_eq!(result, &Ast::Class(class));",
            "}"
          ],
          [
            "{",
            "    let span = Span::new(3, 8);",
            "    let class = Class::new(vec!['a', 'b', 'c']);",
            "    let group = Group {",
            "        span,",
            "        kind: GroupKind::Capturing(2, None),",
            "        ast: Box::new(Ast::Class(class)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    let span = Span::new(3, 8);",
            "    let class = Class::new(vec!['a', 'b', 'c']);",
            "    let group = Group {",
            "    span,",
            "    kind: GroupKind::Capturing(2, None),",
            "    ast: Box::new(Ast::Class(class)),",
            "    };",
            "    let frame = Frame::Group(&group);",
            "    let result = frame.child();",
            "    assert_eq!(result, &group.ast);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span::new(0, 15);",
          "    let literal = Literal::from('b');",
          "    let repetition = Repetition {",
          "        span,",
          "        op: RepetitionOp::ZeroOrMore,",
          "        greedy: true,",
          "        ast: Box::new(Ast::Literal(literal)),",
          "    };",
          "    let frame = Frame::Repetition(&repetition);",
          "    let result = frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span::new(0, 15);",
            "    let literal = Literal::from('b');",
            "    let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let frame = Frame::Repetition(&repetition);",
            "    let result = frame.child();",
            "    assert_eq!(result, &Ast::Literal(literal));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span::new(0, 15);",
            "    let literal = Literal::from('b');",
            "    let repetition = Repetition {",
            "        span,",
            "        op: RepetitionOp::ZeroOrMore,",
            "        greedy: true,",
            "        ast: Box::new(Ast::Literal(literal)),",
            "    };",
            "    let frame = Frame::Repetition(&repetition);",
            "    let result = frame.child();",
            "    let span = Span::new(0, 15);",
            "    let literal = Literal::from('b');",
            "    let repetition = Repetition { span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let frame = Frame::Repetition(&repetition);",
            "    let result = frame.child();",
            "    assert_eq!(result, &Ast::Literal(literal));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span::new(1, 11);",
          "    let ast1 = Ast::Literal(Literal::from('x'));",
          "    let ast2 = Ast::Literal(Literal::from('y'));",
          "    let concat = Concat {",
          "        span,",
          "        ops: vec![ast1.clone(), ast2],",
          "    };",
          "    let frame = Frame::Concat { head: &ast1, tail: &[] };",
          "    let result = frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span::new(1, 11);",
            "    let ast1 = Ast::Literal(Literal::from('x'));",
            "    let ast2 = Ast::Literal(Literal::from('y'));",
            "    let concat = Concat {",
            "    span,",
            "    ops: vec![ast1.clone(), ast2],",
            "    };",
            "    let frame = Frame::Concat { head: &ast1, tail: &[] };",
            "    assert_eq!(result, &ast1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span::new(1, 11);",
            "    let ast1 = Ast::Literal(Literal::from('x'));",
            "    let ast2 = Ast::Literal(Literal::from('y'));",
            "    let concat = Concat {",
            "        span,",
            "        ops: vec![ast1.clone(), ast2],",
            "    };",
            "    let frame = Frame::Concat { head: &ast1, tail: &[] };",
            "    let result = frame.child();",
            "    let span = Span::new(1, 11);",
            "    let ast1 = Ast::Literal(Literal::from('x'));",
            "    let ast2 = Ast::Literal(Literal::from('y'));",
            "    let concat = Concat {",
            "    span,",
            "    ops: vec![ast1.clone(), ast2],",
            "    };",
            "    let frame = Frame::Concat { head: &ast1, tail: &[] };",
            "    assert_eq!(result, &ast1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span::new(0, 20);",
          "    let ast1 = Ast::Class(Class::new(vec!['d', 'e', 'f']));",
          "    let ast2 = Ast::Literal(Literal::from('z'));",
          "    let alternation = Alternation {",
          "        span,",
          "        ops: vec![ast1.clone(), ast2],",
          "    };",
          "    let frame = Frame::Alternation { head: &ast1, tail: &[] };",
          "    let result = frame.child();",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span::new(0, 20);",
            "    let ast1 = Ast::Class(Class::new(vec!['d', 'e', 'f']));",
            "    let ast2 = Ast::Literal(Literal::from('z'));",
            "    let alternation = Alternation { span, ops: vec![ast1.clone(), ast2] };",
            "    let frame = Frame::Alternation { head: &ast1, tail: &[] };",
            "    assert_eq!(result, &ast1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span::new(0, 20);",
            "    let ast1 = Ast::Class(Class::new(vec!['d', 'e', 'f']));",
            "    let ast2 = Ast::Literal(Literal::from('z'));",
            "    let alternation = Alternation {",
            "        span,",
            "        ops: vec![ast1.clone(), ast2],",
            "    };",
            "    let frame = Frame::Alternation { head: &ast1, tail: &[] };",
            "    let result = frame.child();",
            "    let span = Span::new(0, 20);",
            "    let ast1 = Ast::Class(Class::new(vec!['d', 'e', 'f']));",
            "    let ast2 = Ast::Literal(Literal::from('z'));",
            "    let alternation = Alternation { span, ops: vec![ast1.clone(), ast2] };",
            "    let frame = Frame::Alternation { head: &ast1, tail: &[] };",
            "    assert_eq!(result, &ast1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]