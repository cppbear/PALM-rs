[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let h = Hir {",
          "        kind: HirKind::Empty,",
          "        info: HirInfo { bools: 0 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let h = Hir { kind: HirKind::Empty, info: HirInfo { bools: 0 } };",
            "    let expected_output = \"\";",
            "    assert_eq!(buf, expected_output);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Empty,",
            "        info: HirInfo { bools: 0 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Empty, info: HirInfo { bools: 0 } };",
            "    let expected_output = \"\";",
            "    assert_eq!(buf, expected_output);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let h = Hir {",
          "        kind: HirKind::Literal(Literal::from('a')),",
          "        info: HirInfo { bools: 1 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let h = Hir {",
            "    kind: HirKind::Literal(Literal::from('a')),",
            "    info: HirInfo { bools: 1 },",
            "    };",
            "    assert_eq!(buf, \"a\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Literal(Literal::from('a')),",
            "        info: HirInfo { bools: 1 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir {",
            "    kind: HirKind::Literal(Literal::from('a')),",
            "    info: HirInfo { bools: 1 },",
            "    };",
            "    assert_eq!(buf, \"a\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let h = Hir {",
          "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
          "        info: HirInfo { bools: 15 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let h = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), info: HirInfo { bools: 15 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let h = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), info: HirInfo { bools: 15 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.len(), expected_length);"
          ],
          [
            "    let h = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), info: HirInfo { bools: 15 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.contains(\"abc\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
            "        info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), info: HirInfo { bools: 15 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
            "        info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), info: HirInfo { bools: 15 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.len(), expected_length);",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])),",
            "        info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Class(Class::new(vec!['a', 'b', 'c'])), info: HirInfo { bools: 15 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.contains(\"abc\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let h = Hir {",
          "        kind: HirKind::Anchor(Anchor::new()),",
          "        info: HirInfo { bools: 128 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let h = Hir { kind: HirKind::Anchor(Anchor::new()), info: HirInfo { bools: 128 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(result.is_ok(), true);"
          ],
          [
            "    let h = Hir { kind: HirKind::Anchor(Anchor::new()), info: HirInfo { bools: 128 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.is_empty(), false);"
          ],
          [
            "    let h = Hir { kind: HirKind::Anchor(Anchor::new()), info: HirInfo { bools: 128 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.len() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Anchor(Anchor::new()),",
            "        info: HirInfo { bools: 128 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Anchor(Anchor::new()), info: HirInfo { bools: 128 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(result.is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Anchor(Anchor::new()),",
            "        info: HirInfo { bools: 128 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Anchor(Anchor::new()), info: HirInfo { bools: 128 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.is_empty(), false);",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Anchor(Anchor::new()),",
            "        info: HirInfo { bools: 128 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Anchor(Anchor::new()), info: HirInfo { bools: 128 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.len() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let h = Hir {",
          "        kind: HirKind::WordBoundary(WordBoundary::new()),",
          "        info: HirInfo { bools: 255 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let h = Hir { kind: HirKind::WordBoundary(WordBoundary::new()), info: HirInfo { bools: 255 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let h = Hir { kind: HirKind::WordBoundary(WordBoundary::new()), info: HirInfo { bools: 255 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf, \"expected_output\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::WordBoundary(WordBoundary::new()),",
            "        info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::WordBoundary(WordBoundary::new()), info: HirInfo { bools: 255 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::WordBoundary(WordBoundary::new()),",
            "        info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::WordBoundary(WordBoundary::new()), info: HirInfo { bools: 255 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf, \"expected_output\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let h = Hir {",
          "        kind: HirKind::Repetition(Repetition::new(2, 5)),",
          "        info: HirInfo { bools: 2 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let h = Hir { kind: HirKind::Repetition(Repetition::new(2, 5)), info: HirInfo { bools: 2 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let h = Hir { kind: HirKind::Repetition(Repetition::new(2, 5)), info: HirInfo { bools: 2 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.len(), expected_length);"
          ],
          [
            "    let h = Hir { kind: HirKind::Repetition(Repetition::new(2, 5)), info: HirInfo { bools: 2 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.contains(expected_substring));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Repetition(Repetition::new(2, 5)),",
            "        info: HirInfo { bools: 2 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Repetition(Repetition::new(2, 5)), info: HirInfo { bools: 2 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Repetition(Repetition::new(2, 5)),",
            "        info: HirInfo { bools: 2 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Repetition(Repetition::new(2, 5)), info: HirInfo { bools: 2 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.len(), expected_length);",
            "}"
          ],
          [
            "{",
            "    let h = Hir {",
            "        kind: HirKind::Repetition(Repetition::new(2, 5)),",
            "        info: HirInfo { bools: 2 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let h = Hir { kind: HirKind::Repetition(Repetition::new(2, 5)), info: HirInfo { bools: 2 } };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.contains(expected_substring));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let child_hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal::from('x')),",
          "            info: HirInfo { bools: 4 },",
          "        },",
          "    ];",
          "    let h = Hir {",
          "        kind: HirKind::Group(Group::new(child_hirs)),",
          "        info: HirInfo { bools: 0 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let child_hirs = vec![Hir { kind: HirKind::Literal(Literal::from('x')), info: HirInfo { bools: 4 }}];",
            "    let h = Hir { kind: HirKind::Group(Group::new(child_hirs)), info: HirInfo { bools: 0 }};",
            "    let mut buf = String::new();",
            "    let expected_result = \"expected_output_based_on_h\";",
            "    assert_eq!(write!(&mut buf, \"{}\", h), Ok(()));"
          ],
          [
            "    let child_hirs = vec![Hir { kind: HirKind::Literal(Literal::from('x')), info: HirInfo { bools: 4 }}];",
            "    let h = Hir { kind: HirKind::Group(Group::new(child_hirs)), info: HirInfo { bools: 0 }};",
            "    let mut buf = String::new();",
            "    let expected_result = \"expected_output_based_on_h\";",
            "    assert_eq!(buf, expected_result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 4 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Group(Group::new(child_hirs)),",
            "        info: HirInfo { bools: 0 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![Hir { kind: HirKind::Literal(Literal::from('x')), info: HirInfo { bools: 4 }}];",
            "    let h = Hir { kind: HirKind::Group(Group::new(child_hirs)), info: HirInfo { bools: 0 }};",
            "    let mut buf = String::new();",
            "    let expected_result = \"expected_output_based_on_h\";",
            "    assert_eq!(write!(&mut buf, \"{}\", h), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 4 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Group(Group::new(child_hirs)),",
            "        info: HirInfo { bools: 0 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![Hir { kind: HirKind::Literal(Literal::from('x')), info: HirInfo { bools: 4 }}];",
            "    let h = Hir { kind: HirKind::Group(Group::new(child_hirs)), info: HirInfo { bools: 0 }};",
            "    let mut buf = String::new();",
            "    let expected_result = \"expected_output_based_on_h\";",
            "    assert_eq!(buf, expected_result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let child_hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal::from('x')),",
          "            info: HirInfo { bools: 1 },",
          "        },",
          "        Hir {",
          "            kind: HirKind::Literal(Literal::from('y')),",
          "            info: HirInfo { bools: 1 },",
          "        },",
          "    ];",
          "    let h = Hir {",
          "        kind: HirKind::Concat(child_hirs),",
          "        info: HirInfo { bools: 255 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Concat(child_hirs),",
            "    info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Concat(child_hirs),",
            "    info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf, \"xy\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('y')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Concat(child_hirs),",
            "        info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Concat(child_hirs),",
            "    info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('y')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Concat(child_hirs),",
            "        info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Concat(child_hirs),",
            "    info: HirInfo { bools: 255 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf, \"xy\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let child_hirs = vec![",
          "        Hir {",
          "            kind: HirKind::Literal(Literal::from('x')),",
          "            info: HirInfo { bools: 1 },",
          "        },",
          "        Hir {",
          "            kind: HirKind::Literal(Literal::from('y')),",
          "            info: HirInfo { bools: 2 },",
          "        },",
          "    ];",
          "    let h = Hir {",
          "        kind: HirKind::Alternation(child_hirs),",
          "        info: HirInfo { bools: 15 },",
          "    };",
          "    let mut buf = String::new();",
          "    let _ = write!(&mut buf, \"{}\", h);",
          "}"
        ],
        "oracles": [
          [
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 2 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Alternation(child_hirs),",
            "    info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(result.is_ok(), true);"
          ],
          [
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 2 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Alternation(child_hirs),",
            "    info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.is_empty(), false);"
          ],
          [
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 2 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Alternation(child_hirs),",
            "    info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.contains(\"x\") || buf.contains(\"y\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('y')),",
            "            info: HirInfo { bools: 2 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Alternation(child_hirs),",
            "        info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 2 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Alternation(child_hirs),",
            "    info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(result.is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('y')),",
            "            info: HirInfo { bools: 2 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Alternation(child_hirs),",
            "        info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 2 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Alternation(child_hirs),",
            "    info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert_eq!(buf.is_empty(), false);",
            "}"
          ],
          [
            "{",
            "    let child_hirs = vec![",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('x')),",
            "            info: HirInfo { bools: 1 },",
            "        },",
            "        Hir {",
            "            kind: HirKind::Literal(Literal::from('y')),",
            "            info: HirInfo { bools: 2 },",
            "        },",
            "    ];",
            "    let h = Hir {",
            "        kind: HirKind::Alternation(child_hirs),",
            "        info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let _ = write!(&mut buf, \"{}\", h);",
            "    let child_hirs = vec![",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('x')),",
            "    info: HirInfo { bools: 1 },",
            "    },",
            "    Hir {",
            "    kind: HirKind::Literal(Literal::from('y')),",
            "    info: HirInfo { bools: 2 },",
            "    },",
            "    ];",
            "    let h = Hir {",
            "    kind: HirKind::Alternation(child_hirs),",
            "    info: HirInfo { bools: 15 },",
            "    };",
            "    let mut buf = String::new();",
            "    let result = write!(&mut buf, \"{}\", h);",
            "    assert!(buf.contains(\"x\") || buf.contains(\"y\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]