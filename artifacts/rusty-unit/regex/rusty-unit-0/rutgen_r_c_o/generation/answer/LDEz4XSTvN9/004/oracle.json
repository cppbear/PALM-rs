[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [
      "#[derive(Clone, Debug, Eq, PartialEq)]",
      "struct IntBound {",
      "    value: i32,",
      "}",
      "",
      "impl IntBound {",
      "    fn min_value() -> Self {",
      "        IntBound { value: i32::MIN }",
      "    }",
      "    ",
      "    fn max_value() -> Self {",
      "        IntBound { value: i32::MAX }",
      "    }",
      "    ",
      "    fn decrement(&self) -> Self {",
      "        IntBound { value: self.value - 1 }",
      "    }",
      "    ",
      "    fn increment(&self) -> Self {",
      "        IntBound { value: self.value + 1 }",
      "    }",
      "}",
      "",
      "impl PartialOrd for IntBound {",
      "    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {",
      "        self.value.partial_cmp(&other.value)",
      "    }",
      "}",
      "",
      "impl Ord for IntBound {",
      "    fn cmp(&self, other: &Self) -> std::cmp::Ordering {",
      "        self.value.cmp(&other.value)",
      "    }",
      "}",
      "",
      "impl Default for IntBound {",
      "    fn default() -> Self {",
      "        IntBound { value: 0 }",
      "    }",
      "}",
      "",
      "impl Eq for IntBound {}",
      "",
      "#[derive(Clone, Debug, Eq, PartialEq)]",
      "struct TestInterval {",
      "    lower_bound: IntBound,",
      "    upper_bound: IntBound,",
      "}",
      "",
      "impl Interval for TestInterval {",
      "    type Bound = IntBound;",
      "",
      "    fn lower(&self) -> Self::Bound {",
      "        self.lower_bound.clone()",
      "    }",
      "    ",
      "    fn upper(&self) -> Self::Bound {",
      "        self.upper_bound.clone()",
      "    }",
      "    ",
      "    fn set_lower(&mut self, bound: Self::Bound) {",
      "        self.lower_bound = bound;",
      "    }",
      "    ",
      "    fn set_upper(&mut self, bound: Self::Bound) {",
      "        self.upper_bound = bound;",
      "    }",
      "    ",
      "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
      "",
      "    fn is_contiguous(&self, other: &Self) -> bool {",
      "        self.upper() >= other.lower() && self.lower() <= other.upper()",
      "    }",
      "    ",
      "    fn is_intersection_empty(&self, other: &Self) -> bool {",
      "        self.upper() < other.lower() || self.lower() > other.upper()",
      "    }",
      "    ",
      "    fn is_subset(&self, other: &Self) -> bool {",
      "        self.lower() >= other.lower() && self.upper() <= other.upper()",
      "    }",
      "}"
    ],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut interval_set = IntervalSet::new(vec![",
          "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
          "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
          "    ]);",
          "    interval_set.negate();",
          "}"
        ],
        "oracles": [
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.ranges.len(), 1);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.ranges[0].lower(), IntBound::min_value());"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.ranges[0].upper(), IntBound { value: 0 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges.len(), 3);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[0].lower(), IntBound::min_value());"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[0].upper(), IntBound { value: 0 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[1].lower(), IntBound { value: 11 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[1].upper(), IntBound { value: 19 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[2].lower(), IntBound { value: 31 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[2].upper(), IntBound::max_value());"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert!(interval_set.ranges.iter().all(|interval| {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.ranges.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.ranges[0].lower(), IntBound::min_value());",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    assert_eq!(interval_set.ranges[0].upper(), IntBound { value: 0 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[0].lower(), IntBound::min_value());",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[0].upper(), IntBound { value: 0 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[1].lower(), IntBound { value: 11 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[1].upper(), IntBound { value: 19 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[2].lower(), IntBound { value: 31 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert_eq!(interval_set.ranges[2].upper(), IntBound::max_value());",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![]);",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 1 }, upper_bound: IntBound { value: 10 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 30 } },",
            "    ]);",
            "    interval_set.negate();",
            "    assert!(interval_set.ranges.iter().all(|interval| {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut interval_set = IntervalSet::new(vec![",
          "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
          "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
          "    ]);",
          "    interval_set.negate();",
          "}"
        ],
        "oracles": [
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals().len(), 3);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[0].lower(), IntBound::min_value());"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[0].upper(), IntBound { value: 4 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[1].lower(), IntBound { value: 16 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[1].upper(), IntBound { value: 19 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[2].lower(), IntBound { value: 26 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[2].upper(), IntBound::max_value());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals().len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[0].lower(), IntBound::min_value());",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[0].upper(), IntBound { value: 4 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[1].lower(), IntBound { value: 16 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[1].upper(), IntBound { value: 19 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[2].lower(), IntBound { value: 26 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "        TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![",
            "    TestInterval { lower_bound: IntBound { value: 5 }, upper_bound: IntBound { value: 15 } },",
            "    TestInterval { lower_bound: IntBound { value: 20 }, upper_bound: IntBound { value: 25 } },",
            "    ]);",
            "    assert_eq!(interval_set.intervals()[2].upper(), IntBound::max_value());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut interval_set = IntervalSet::new(vec![",
          "        TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
          "        TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } },",
          "    ]);",
          "    interval_set.negate();",
          "}"
        ],
        "oracles": [
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(!interval_set.intervals().iter().any(|i| i.lower() >= IntBound::min_value() && i.upper() <= IntBound::max_value()));"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals().iter().all(|i| i.lower() <= IntBound::min_value() || i.upper() >= IntBound::max_value()));"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals().len() == 3);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals()[0].lower() == IntBound::min_value());"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals()[2].upper() == IntBound::max_value());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "        TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(!interval_set.intervals().iter().any(|i| i.lower() >= IntBound::min_value() && i.upper() <= IntBound::max_value()));",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "        TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals().iter().all(|i| i.lower() <= IntBound::min_value() || i.upper() >= IntBound::max_value()));",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "        TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals().len() == 3);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "        TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals()[0].lower() == IntBound::min_value());",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "        TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: IntBound::min_value().value + 1 }, upper_bound: IntBound { value: IntBound::max_value().value - 1 } }, TestInterval { lower_bound: IntBound { value: IntBound::max_value().value - 5 }, upper_bound: IntBound { value: IntBound::max_value().value - 2 } }]);",
            "    assert!(interval_set.intervals()[2].upper() == IntBound::max_value());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut interval_set = IntervalSet::new(vec![",
          "        TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } },",
          "    ]);",
          "    interval_set.negate();",
          "}"
        ],
        "oracles": [
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals().len(), 2);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[0].lower().value, i32::MIN);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[0].upper().value, 2);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[1].lower().value, 6);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[1].upper().value, i32::MAX);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals().len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[0].lower().value, i32::MIN);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[0].upper().value, 2);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[1].lower().value, 6);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound { value: 3 }, upper_bound: IntBound { value: 5 } }]);",
            "    assert_eq!(interval_set.intervals()[1].upper().value, i32::MAX);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut interval_set = IntervalSet::new(vec![",
          "        TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
          "    ]);",
          "    interval_set.negate();",
          "}"
        ],
        "oracles": [
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals().len(), 2);"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[0].lower(), IntBound::max_value());"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[0].upper(), IntBound { value: IntBound::min_value().value + 1 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[1].lower(), IntBound { value: IntBound::max_value().value - 1 });"
          ],
          [
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[1].upper(), IntBound::min_value());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals().len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[0].lower(), IntBound::max_value());",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[0].upper(), IntBound { value: IntBound::min_value().value + 1 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[1].lower(), IntBound { value: IntBound::max_value().value - 1 });",
            "}"
          ],
          [
            "{",
            "    let mut interval_set = IntervalSet::new(vec![",
            "        TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 } },",
            "    ]);",
            "    interval_set.negate();",
            "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: IntBound::min_value(), upper_bound: IntBound { value: IntBound::max_value().value - 1 }}]);",
            "    assert_eq!(interval_set.intervals()[1].upper(), IntBound::min_value());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]