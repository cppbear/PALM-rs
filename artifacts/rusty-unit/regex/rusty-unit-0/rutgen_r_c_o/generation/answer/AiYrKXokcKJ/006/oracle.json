[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals::empty();",
          "    literals.set_limit_size(100);",
          "    literals.set_limit_class(50);",
          "    ",
          "    let mut lit1 = Literal::empty();",
          "    lit1.push(97); // 'a'",
          "    literals.add(lit1);",
          "    ",
          "    let mut lit2 = Literal::empty();",
          "    lit2.push(98); // 'b'",
          "    literals.add(lit2);",
          "    ",
          "    let range = ClassBytesRange { start: 200, end: 210 }; // Valid range",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    ",
          "    let result = literals.add_byte_class(&class_bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(result, true);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.limit_size() <= 100);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.limit_class() <= 50);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(!literals.is_empty());"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.literals().len(), 3);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97); // 'a'",
            "    literals.add(lit1);",
            "    ",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98); // 'b'",
            "    literals.add(lit2);",
            "    ",
            "    let range = ClassBytesRange { start: 200, end: 210 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(result, true);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97); // 'a'",
            "    literals.add(lit1);",
            "    ",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98); // 'b'",
            "    literals.add(lit2);",
            "    ",
            "    let range = ClassBytesRange { start: 200, end: 210 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.limit_size() <= 100);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97); // 'a'",
            "    literals.add(lit1);",
            "    ",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98); // 'b'",
            "    literals.add(lit2);",
            "    ",
            "    let range = ClassBytesRange { start: 200, end: 210 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.limit_class() <= 50);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97); // 'a'",
            "    literals.add(lit1);",
            "    ",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98); // 'b'",
            "    literals.add(lit2);",
            "    ",
            "    let range = ClassBytesRange { start: 200, end: 210 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(!literals.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97); // 'a'",
            "    literals.add(lit1);",
            "    ",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98); // 'b'",
            "    literals.add(lit2);",
            "    ",
            "    let range = ClassBytesRange { start: 200, end: 210 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(97);",
            "    literals.add(lit1);",
            "    let mut lit2 = Literal::empty();",
            "    lit2.push(98);",
            "    literals.add(lit2);",
            "    let range = ClassBytesRange { start: 200, end: 210 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.literals().len(), 3);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals::empty();",
          "    literals.set_limit_size(100);",
          "    literals.set_limit_class(50);",
          "    ",
          "    let mut lit1 = Literal::empty();",
          "    lit1.push(100); // 'd'",
          "    literals.add(lit1);",
          "    ",
          "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    ",
          "    let result = literals.add_byte_class(&class_bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    assert!(literals.add(lit1));"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(result);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_size(), 100);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_class(), 50);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(!literals.is_empty());"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.num_bytes() <= literals.limit_size());"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(!literals.class_exceeds_limits(cls_byte_count(&class_bytes)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    assert!(literals.add(lit1));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(result);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_size(), 100);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_class(), 50);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(!literals.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.num_bytes() <= literals.limit_size());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100); // 'd'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 100, end: 110 }; // Valid range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(100);",
            "    let range = ClassBytesRange { start: 100, end: 110 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(!literals.class_exceeds_limits(cls_byte_count(&class_bytes)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals::empty();",
          "    literals.set_limit_size(100);",
          "    literals.set_limit_class(50);",
          "    ",
          "    let mut lit1 = Literal::empty();",
          "    lit1.push(120); // 'x'",
          "    literals.add(lit1);",
          "    ",
          "    let range = ClassBytesRange { start: 1, end: 2 }; // Small range",
          "    let class_bytes = ClassBytes::new(vec![range]);",
          "    ",
          "    let result = literals.add_byte_class(&class_bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(120);",
            "    literals.add(lit1);",
            "    let range = ClassBytesRange { start: 1, end: 2 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(120); // 'x'",
            "    literals.add(lit1);",
            "    ",
            "    let range = ClassBytesRange { start: 1, end: 2 }; // Small range",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(50);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(120);",
            "    literals.add(lit1);",
            "    let range = ClassBytesRange { start: 1, end: 2 };",
            "    let class_bytes = ClassBytes::new(vec![range]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals::empty();",
          "    literals.set_limit_size(10);",
          "    literals.set_limit_class(5);",
          "    ",
          "    let mut lit1 = Literal::empty();",
          "    lit1.push(65); // 'A'",
          "    literals.add(lit1);",
          "    ",
          "    let range1 = ClassBytesRange { start: 0, end: 255 }; // Too large",
          "    let class_bytes = ClassBytes::new(vec![range1]);",
          "    ",
          "    let result = literals.add_byte_class(&class_bytes); // Should return false",
          "}"
        ],
        "oracles": [
          [
            "    literals.set_limit_size(10);",
            "    literals.set_limit_class(5);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(65);",
            "    literals.add(lit1);",
            "    let range1 = ClassBytesRange { start: 0, end: 255 };",
            "    let class_bytes = ClassBytes::new(vec![range1]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(result, false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(10);",
            "    literals.set_limit_class(5);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(65); // 'A'",
            "    literals.add(lit1);",
            "    ",
            "    let range1 = ClassBytesRange { start: 0, end: 255 }; // Too large",
            "    let class_bytes = ClassBytes::new(vec![range1]);",
            "    ",
            "    let result = literals.add_byte_class(&class_bytes); // Should return false",
            "    literals.set_limit_size(10);",
            "    literals.set_limit_class(5);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(65);",
            "    literals.add(lit1);",
            "    let range1 = ClassBytesRange { start: 0, end: 255 };",
            "    let class_bytes = ClassBytes::new(vec![range1]);",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(result, false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals::empty();",
          "    literals.set_limit_size(100);",
          "    literals.set_limit_class(10);",
          "    ",
          "    let mut lit1 = Literal::empty();",
          "    lit1.push(99); // 'c'",
          "    literals.add(lit1);",
          "    ",
          "    let class_bytes = ClassBytes::empty(); // No ranges",
          "    let result = literals.add_byte_class(&class_bytes); // Should return true",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(result, true);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_size(), 100);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_class(), 10);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.literals().len(), 1);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.literals()[0].is_cut() == false);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.num_bytes(), 1);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.contains_empty(), false);"
          ],
          [
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.is_empty(), false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(result, true);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_size(), 100);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.limit_class(), 10);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.literals().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert!(literals.literals()[0].is_cut() == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.num_bytes(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.contains_empty(), false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    ",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99); // 'c'",
            "    literals.add(lit1);",
            "    ",
            "    let class_bytes = ClassBytes::empty(); // No ranges",
            "    let result = literals.add_byte_class(&class_bytes); // Should return true",
            "    let mut literals = Literals::empty();",
            "    literals.set_limit_size(100);",
            "    literals.set_limit_class(10);",
            "    let mut lit1 = Literal::empty();",
            "    lit1.push(99);",
            "    literals.add(lit1);",
            "    let class_bytes = ClassBytes::empty();",
            "    let result = literals.add_byte_class(&class_bytes);",
            "    assert_eq!(literals.is_empty(), false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]