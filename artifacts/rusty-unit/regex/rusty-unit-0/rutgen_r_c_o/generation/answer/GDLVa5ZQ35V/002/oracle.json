[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let ast = Ast::Empty(Span);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    assert!(output.contains(\"(?\"));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \".\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"^\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\d\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\pa\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"*\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \")\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    assert!(output.contains(\"(?\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \".\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"^\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\pa\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"*\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \")\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet::Normal }));",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'b' })) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) });",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Alternation(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'c' })]);",
            "    writer.visit_post(&ast);",
            "    let ast = Ast::Concat(vec![Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'd' })]);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let flags = SetFlags { span: Span, flags: Flags };",
          "    let ast = Ast::Flags(flags);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    assert_eq!(output, \"(?flags)\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    assert_eq!(output, \".\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    assert_eq!(output, \"^\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    assert_eq!(output, r\"\\d\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    assert_eq!(output, r\"\\pc\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    assert_eq!(output, \"]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    assert_eq!(output, \"*\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    assert_eq!(output, \")\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(Vec::new());",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(Vec::new());",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    assert_eq!(output, \"(?flags)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    assert_eq!(output, \".\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    assert_eq!(output, \"^\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    assert_eq!(output, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    assert_eq!(output, r\"\\pc\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    assert_eq!(output, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    assert_eq!(output, \"*\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    assert_eq!(output, \")\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(Vec::new());",
            "    assert_eq!(writer.visit_post(&ast), Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let perl_class = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(perl_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let unicode_class = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(unicode_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let bracketed_class = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(bracketed_class));",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Vec::new());",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(Vec::new());",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
          "    let ast = Ast::Literal(literal);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"(?...)\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"^\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\d\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \")\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"*\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\Pc\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \".\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"(?...)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"^\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \")\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"*\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\Pc\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \".\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capturing, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: true, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let ast = Ast::Dot(Span);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"(flags)\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"^\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\d\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\pa\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"*\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \")\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Alternation);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Alternation);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(Concat);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"(flags)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"^\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, r\"\\pa\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"*\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \")\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Alternation);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Empty(Span);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Flags(SetFlags { span: Span, flags: Flags });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Literal(Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Assertion(Assertion { span: Span, kind: AssertionKind::StartLine });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Perl(ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Unicode(ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Class(Class::Bracketed(ClassBracketed { span: Span, negated: true, kind: ClassSet }));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Repetition(Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Group(Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Dot(Span)) });",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(Alternation);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(Concat);",
            "    writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
          "    let ast = Ast::Assertion(assertion);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"^\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"(?)\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \".\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"\\d\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"\\pb\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"*\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \")\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(vec![Ast::Literal(literal)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"^\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"(?)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \".\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"\\pb\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"*\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \")\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let assertion = Assertion { span: Span, kind: AssertionKind::StartLine };",
            "    let ast = Ast::Assertion(assertion);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let flags = SetFlags { span: Span, flags: Flags };",
            "    let ast = Ast::Flags(flags);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let literal = Literal { span: Span, kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = Ast::Literal(literal);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Dot(Span);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('b') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Normal, ast: Box::new(Ast::Literal(literal)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Literal(literal)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(vec![Ast::Literal(literal)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
          "    let ast = Ast::Class(Class::Perl(class_perl));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"\\d\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_perl = ClassPerl { span: Span, kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = Ast::Class(Class::Perl(class_perl));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, r\"\\d\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
          "    let ast = Ast::Class(Class::Unicode(class_unicode));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).expect(\"Expected result to be Ok(())\");",
            "    assert_eq!(output, r\"\\pa\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_unicode = ClassUnicode { span: Span, negated: false, kind: ClassUnicodeKind::OneLetter('a') };",
            "    let ast = Ast::Class(Class::Unicode(class_unicode));",
            "    writer.visit_post(&ast).expect(\"Expected result to be Ok(())\");",
            "    assert_eq!(output, r\"\\pa\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
          "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let class_bracketed = ClassBracketed { span: Span, negated: false, kind: ClassSet::Normal };",
            "    let ast = Ast::Class(Class::Bracketed(class_bracketed));",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
          "    let ast = Ast::Repetition(repetition);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"*\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let repetition = Repetition { span: Span, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Repetition(repetition);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"*\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
          "    let ast = Ast::Group(group);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(...);",
            "    let result = writer.visit_post(&ast);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(...);",
            "    let result = writer.visit_post(&ast);",
            "    assert!(output.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(...);",
            "    let result = writer.visit_post(&ast);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let group = Group { span: Span, kind: GroupKind::Capture, ast: Box::new(Ast::Empty(Span)) };",
            "    let ast = Ast::Group(group);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(...);",
            "    let result = writer.visit_post(&ast);",
            "    assert!(output.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    writer.visit_post(&ast).unwrap();",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
          "    let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
          "    writer.visit_post(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    let result = writer.visit_post(&ast);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    let result = writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    let result = writer.visit_post(&ast);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Concat(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    writer.visit_post(&ast);",
            "    let mut output = String::new();",
            "    let mut writer = Writer { printer: &mut Printer { _priv: () }, wtr: &mut output };",
            "    let ast = Ast::Alternation(vec![Ast::Empty(Span), Ast::Empty(Span)]);",
            "    let result = writer.visit_post(&ast);",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]