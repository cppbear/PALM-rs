[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
          "    compiler.c_class_bytes(&ranges);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[0], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[1], false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[0], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(0, 0)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[1], false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let ranges = vec![",
          "        hir::ClassBytesRange::new(1, 1),",
          "        hir::ClassBytesRange::new(2, 2),",
          "    ];",
          "    compiler.c_class_bytes(&ranges);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(1, 1), hir::ClassBytesRange::new(2, 2)];",
            "    assert!(compiler.c_class_bytes(&ranges).is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(1, 1), hir::ClassBytesRange::new(2, 2)];",
            "    let patch = compiler.c_class_bytes(&ranges).unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(1, 1), hir::ClassBytesRange::new(2, 2)];",
            "    let patch = compiler.c_class_bytes(&ranges).unwrap();",
            "    assert_eq!(patch.entry, 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(1, 1),",
            "        hir::ClassBytesRange::new(2, 2),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(1, 1), hir::ClassBytesRange::new(2, 2)];",
            "    assert!(compiler.c_class_bytes(&ranges).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(1, 1),",
            "        hir::ClassBytesRange::new(2, 2),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(1, 1), hir::ClassBytesRange::new(2, 2)];",
            "    let patch = compiler.c_class_bytes(&ranges).unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(1, 1),",
            "        hir::ClassBytesRange::new(2, 2),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(1, 1), hir::ClassBytesRange::new(2, 2)];",
            "    let patch = compiler.c_class_bytes(&ranges).unwrap();",
            "    assert_eq!(patch.entry, 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let ranges = vec![",
          "        hir::ClassBytesRange::new(4, 5),",
          "        hir::ClassBytesRange::new(6, 7),",
          "    ];",
          "    compiler.c_class_bytes(&ranges);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[4 as usize], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[5 as usize], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[6 as usize], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[7 as usize], true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[4 as usize], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[5 as usize], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[6 as usize], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(6, 7),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(4, 5), hir::ClassBytesRange::new(6, 7)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[7 as usize], true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let ranges = vec![",
          "        hir::ClassBytesRange::new(8, 9),",
          "        hir::ClassBytesRange::new(10, 15),",
          "        hir::ClassBytesRange::new(16, 31),",
          "    ];",
          "    compiler.c_class_bytes(&ranges);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[8], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[9], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[10], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[15], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[16], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[31], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[7], false);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[32], false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[8], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[9], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[10], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[15], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[16], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[31], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[7], false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(8, 9),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(8, 9),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(16, 31),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[32], false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let ranges = vec![",
          "        hir::ClassBytesRange::new(32, 255),",
          "    ];",
          "    compiler.c_class_bytes(&ranges);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[32], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[255], true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[32], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![hir::ClassBytesRange::new(32, 255)];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[255], true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let ranges = vec![",
          "        hir::ClassBytesRange::new(0, 0),",
          "        hir::ClassBytesRange::new(2, 2),",
          "        hir::ClassBytesRange::new(4, 5),",
          "        hir::ClassBytesRange::new(10, 15),",
          "        hir::ClassBytesRange::new(32, 255),",
          "    ];",
          "    compiler.c_class_bytes(&ranges);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[0], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[2], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[4], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[5], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[10], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[11], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[12], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[13], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[14], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[15], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[32], true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[255], true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert!(matches!(patch.hole, Hole::Many(_)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[0], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[2], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[4], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[5], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[10], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[11], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[12], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[13], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[14], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[15], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[32], true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "        hir::ClassBytesRange::new(0, 0),",
            "        hir::ClassBytesRange::new(2, 2),",
            "        hir::ClassBytesRange::new(4, 5),",
            "        hir::ClassBytesRange::new(10, 15),",
            "        hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    compiler.c_class_bytes(&ranges);",
            "    let mut compiler = Compiler::new();",
            "    let ranges = vec![",
            "    hir::ClassBytesRange::new(0, 0),",
            "    hir::ClassBytesRange::new(2, 2),",
            "    hir::ClassBytesRange::new(4, 5),",
            "    hir::ClassBytesRange::new(10, 15),",
            "    hir::ClassBytesRange::new(32, 255),",
            "    ];",
            "    let result = compiler.c_class_bytes(&ranges);",
            "    let patch = result.unwrap();",
            "    assert_eq!(compiler.byte_classes.0[255], true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]