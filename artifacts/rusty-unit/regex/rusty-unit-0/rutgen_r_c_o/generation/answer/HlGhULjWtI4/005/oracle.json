[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 0, end: 1 };",
          "    let item = ast::ClassSetItem::Empty(span);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Bracketed)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Empty)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Literal)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Range)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Ascii)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Unicode)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Perl)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Union)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Intersection)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(SymmetricDifference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Bracketed)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Empty)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Literal)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Range)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Ascii)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Unicode)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Perl)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    assert_eq!(format!(\"{:?}\", induct), \"Item(Union)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Intersection)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 0, end: 1 };",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { /* fields */ }));",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Empty(span);",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Literal(Literal { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Range(ClassSetRange { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Ascii(ClassAscii { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Unicode(ClassUnicode { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Perl(ClassPerl { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let item = ast::ClassSetItem::Union(ClassSetUnion { /* fields */ });",
            "    let induct = ClassInduct::Item(&item);",
            "    let binary_op = ClassInduct::BinaryOp(&ast::ClassSetBinaryOp { /* fields */ });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(SymmetricDifference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 2, end: 3 };",
          "    let literal = Literal::from('a');",
          "    let item = ast::ClassSetItem::Literal(literal);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Literal)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    assert_eq!(result_empty, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Empty)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    assert_eq!(result_range, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Range)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    assert_eq!(result_ascii, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    assert_eq!(result_unicode, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    assert_eq!(result_perl, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Perl)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    assert_eq!(result_bracketed, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    assert_eq!(result_union, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    assert_eq!(result_binary_op_intersection, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"BinaryOp(Intersection)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    assert_eq!(result_binary_op_difference, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"BinaryOp(Difference)\");"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
            "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
            "    assert_eq!(result_binary_op_sym_difference, Ok(()));"
          ],
          [
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
            "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"BinaryOp(SymmetricDifference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Literal)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    assert_eq!(result_empty, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Empty)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    assert_eq!(result_range, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Range)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    assert_eq!(result_ascii, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Ascii)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    assert_eq!(result_unicode, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    assert_eq!(result_perl, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Perl)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    assert_eq!(result_bracketed, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    assert_eq!(result_union, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    assert_eq!(result_binary_op_intersection, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"BinaryOp(Intersection)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    assert_eq!(result_binary_op_difference, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"BinaryOp(Difference)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
            "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
            "    assert_eq!(result_binary_op_sym_difference, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 2, end: 3 };",
            "    let literal = Literal::from('a');",
            "    let item = ast::ClassSetItem::Literal(literal);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    let result_empty = induct_empty.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    let result_range = induct_range.fmt(&mut formatter);",
            "    let item_ascii = ast::ClassSetItem::Ascii(ClassAscii::Alnum);",
            "    let induct_ascii = ClassInduct::Item(&item_ascii);",
            "    let result_ascii = induct_ascii.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::L);",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    let result_unicode = induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    let result_perl = induct_perl.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new()));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    let result_bracketed = induct_bracketed.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new());",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    let result_union = induct_union.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    let result_binary_op_intersection = induct_binary_op_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    let result_binary_op_difference = induct_binary_op_difference.fmt(&mut formatter);",
            "    let binary_op_sym_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_op_sym_difference = ClassInduct::BinaryOp(&binary_op_sym_difference);",
            "    let result_binary_op_sym_difference = induct_binary_op_sym_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"BinaryOp(SymmetricDifference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 4, end: 5 };",
          "    let range = ClassSetRange::new('a', 'z');",
          "    let item = ast::ClassSetItem::Range(range);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 4, end: 5 };",
            "    let range = ClassSetRange::new('a', 'z');",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    assert_eq!(induct.fmt(&mut formatter).is_ok(), true);"
          ],
          [
            "    let span = Span { start: 4, end: 5 };",
            "    let range = ClassSetRange::new('a', 'z');",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 4, end: 5 };",
            "    let range = ClassSetRange::new('a', 'z');",
            "    let item = ast::ClassSetItem::Range(range);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 4, end: 5 };",
            "    let range = ClassSetRange::new('a', 'z');",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    assert_eq!(induct.fmt(&mut formatter).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 4, end: 5 };",
            "    let range = ClassSetRange::new('a', 'z');",
            "    let item = ast::ClassSetItem::Range(range);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 4, end: 5 };",
            "    let range = ClassSetRange::new('a', 'z');",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![item])));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 6, end: 7 };",
          "    let ascii = ClassAscii::Alphanumeric;",
          "    let item = ast::ClassSetItem::Ascii(ascii);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Ascii)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Empty)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Literal)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Range)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Unicode)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Perl)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Union)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Bracketed)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    induct_binary_intersection.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"BinaryOp(Intersection)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    induct_binary_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    induct_binary_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"BinaryOp(Difference)\");"
          ],
          [
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    induct_binary_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    induct_binary_difference.fmt(&mut formatter);",
            "    let binary_op_symmetric_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_symmetric_difference = ClassInduct::BinaryOp(&binary_op_symmetric_difference);",
            "    induct_binary_symmetric_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"BinaryOp(SymmetricDifference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Ascii)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Empty)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Literal)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Range)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Unicode)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Perl)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Union)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"Item(Bracketed)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    induct_binary_intersection.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"BinaryOp(Intersection)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    induct_binary_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    induct_binary_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"BinaryOp(Difference)\");",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 6, end: 7 };",
            "    let ascii = ClassAscii::Alphanumeric;",
            "    let item = ast::ClassSetItem::Ascii(ascii);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let item_empty = ast::ClassSetItem::Empty(span);",
            "    let induct_empty = ClassInduct::Item(&item_empty);",
            "    induct_empty.fmt(&mut formatter);",
            "    let item_literal = ast::ClassSetItem::Literal(Literal::from('a'));",
            "    let induct_literal = ClassInduct::Item(&item_literal);",
            "    induct_literal.fmt(&mut formatter);",
            "    let item_range = ast::ClassSetItem::Range(ClassSetRange::new('a', 'z'));",
            "    let induct_range = ClassInduct::Item(&item_range);",
            "    induct_range.fmt(&mut formatter);",
            "    let item_unicode = ast::ClassSetItem::Unicode(ClassUnicode::new(\"L\"));",
            "    let induct_unicode = ClassInduct::Item(&item_unicode);",
            "    induct_unicode.fmt(&mut formatter);",
            "    let item_perl = ast::ClassSetItem::Perl(ClassPerl::Digit);",
            "    let induct_perl = ClassInduct::Item(&item_perl);",
            "    induct_perl.fmt(&mut formatter);",
            "    let item_union = ast::ClassSetItem::Union(ClassSetUnion::new(vec![]));",
            "    let induct_union = ClassInduct::Item(&item_union);",
            "    induct_union.fmt(&mut formatter);",
            "    let item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed::new(vec![])));",
            "    let induct_bracketed = ClassInduct::Item(&item_bracketed);",
            "    induct_bracketed.fmt(&mut formatter);",
            "    let binary_op_intersection = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Intersection, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_intersection = ClassInduct::BinaryOp(&binary_op_intersection);",
            "    induct_binary_intersection.fmt(&mut formatter);",
            "    let binary_op_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::Difference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_difference = ClassInduct::BinaryOp(&binary_op_difference);",
            "    induct_binary_difference.fmt(&mut formatter);",
            "    let binary_op_symmetric_difference = ast::ClassSetBinaryOp { span, kind: ast::ClassSetBinaryOpKind::SymmetricDifference, lhs: Box::new(ClassSet::new()), rhs: Box::new(ClassSet::new()) };",
            "    let induct_binary_symmetric_difference = ClassInduct::BinaryOp(&binary_op_symmetric_difference);",
            "    induct_binary_symmetric_difference.fmt(&mut formatter);",
            "    assert_eq!(formatter.output(), \"BinaryOp(SymmetricDifference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 8, end: 9 };",
          "    let unicode = ClassUnicode::new(\"L\");",
          "    let item = ast::ClassSetItem::Unicode(unicode);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 8, end: 9 };",
            "    let unicode = ClassUnicode::new(\"L\");",
            "    let item = ast::ClassSetItem::Unicode(unicode);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let span = Span { start: 8, end: 9 };",
            "    let unicode = ClassUnicode::new(\"L\");",
            "    let item = ast::ClassSetItem::Unicode(unicode);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 8, end: 9 };",
            "    let unicode = ClassUnicode::new(\"L\");",
            "    let item = ast::ClassSetItem::Unicode(unicode);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 8, end: 9 };",
            "    let unicode = ClassUnicode::new(\"L\");",
            "    let item = ast::ClassSetItem::Unicode(unicode);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 8, end: 9 };",
            "    let unicode = ClassUnicode::new(\"L\");",
            "    let item = ast::ClassSetItem::Unicode(unicode);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 8, end: 9 };",
            "    let unicode = ClassUnicode::new(\"L\");",
            "    let item = ast::ClassSetItem::Unicode(unicode);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Unicode)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 10, end: 11 };",
          "    let perl = ClassPerl::Digit;",
          "    let item = ast::ClassSetItem::Perl(perl);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 10, end: 11 };",
            "    let perl = ClassPerl::Digit;",
            "    let item = ast::ClassSetItem::Perl(perl);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter.to_string(), \"Item(Perl)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 10, end: 11 };",
            "    let perl = ClassPerl::Digit;",
            "    let item = ast::ClassSetItem::Perl(perl);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 10, end: 11 };",
            "    let perl = ClassPerl::Digit;",
            "    let item = ast::ClassSetItem::Perl(perl);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter).unwrap();",
            "    assert_eq!(formatter.to_string(), \"Item(Perl)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 12, end: 13 };",
          "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
          "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 12, end: 13 };",
            "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 12, end: 13 };",
            "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 12, end: 13 };",
            "    let bracketed = ClassBracketed::new(vec![ast::ClassSetItem::Literal(Literal::from('b'))]);",
            "    let item = ast::ClassSetItem::Bracketed(Box::new(bracketed));",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Bracketed)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span = Span { start: 14, end: 15 };",
          "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
          "    let item = ast::ClassSetItem::Union(union);",
          "    let induct = ClassInduct::Item(&item);",
          "    let mut formatter = std::fmt::Formatter::new();",
          "    induct.fmt(&mut formatter);",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 14, end: 15 };",
            "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
            "    let item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(result, Ok(()));"
          ],
          [
            "    let span = Span { start: 14, end: 15 };",
            "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
            "    let item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Union)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span = Span { start: 14, end: 15 };",
            "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
            "    let item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 14, end: 15 };",
            "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
            "    let item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(result, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let span = Span { start: 14, end: 15 };",
            "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
            "    let item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    induct.fmt(&mut formatter);",
            "    let span = Span { start: 14, end: 15 };",
            "    let union = ClassSetUnion::new(vec![ast::ClassSetItem::Literal(Literal::from('c'))]);",
            "    let item = ast::ClassSetItem::Union(union);",
            "    let induct = ClassInduct::Item(&item);",
            "    let mut formatter = std::fmt::Formatter::new();",
            "    let result = induct.fmt(&mut formatter);",
            "    assert_eq!(formatter.to_string(), \"Item(Union)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]