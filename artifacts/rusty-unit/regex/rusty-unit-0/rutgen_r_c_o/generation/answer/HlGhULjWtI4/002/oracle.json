[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })],",
          "    });",
          "    let rhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })],",
          "    });",
          "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
          "        span: Span { start: 0, end: 1 },",
          "        kind: ClassSetBinaryOpKind::Difference,",
          "        lhs,",
          "        rhs,",
          "    });",
          "    let _ = format!(\"{:?}\", binary_op);",
          "}"
        ],
        "oracles": [
          [
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })],",
            "    });",
            "    let rhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })],",
            "    });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
            "        span: Span { start: 0, end: 1 },",
            "        kind: ClassSetBinaryOpKind::Difference,",
            "        lhs,",
            "        rhs,",
            "    });",
            "    let _ = format!(\"{:?}\", binary_op);",
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 0, end: 0 })] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Empty(Span { start: 1, end: 1 })] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 1 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Literal(Literal::new('a'))],",
          "    });",
          "    let rhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Literal(Literal::new('b'))],",
          "    });",
          "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
          "        span: Span { start: 0, end: 2 },",
          "        kind: ClassSetBinaryOpKind::Difference,",
          "        lhs,",
          "        rhs,",
          "    });",
          "    let _ = format!(\"{:?}\", binary_op);",
          "}"
        ],
        "oracles": [
          [
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('a'))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('b'))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 2 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Literal(Literal::new('a'))],",
            "    });",
            "    let rhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Literal(Literal::new('b'))],",
            "    });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
            "        span: Span { start: 0, end: 2 },",
            "        kind: ClassSetBinaryOpKind::Difference,",
            "        lhs,",
            "        rhs,",
            "    });",
            "    let _ = format!(\"{:?}\", binary_op);",
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('a'))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Literal(Literal::new('b'))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 2 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))],",
          "    });",
          "    let rhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))],",
          "    });",
          "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
          "        span: Span { start: 0, end: 3 },",
          "        kind: ClassSetBinaryOpKind::Difference,",
          "        lhs,",
          "        rhs,",
          "    });",
          "    let _ = format!(\"{:?}\", binary_op);",
          "}"
        ],
        "oracles": [
          [
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))],",
            "    });",
            "    let rhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))],",
            "    });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
            "        span: Span { start: 0, end: 3 },",
            "        kind: ClassSetBinaryOpKind::Difference,",
            "        lhs,",
            "        rhs,",
            "    });",
            "    let _ = format!(\"{:?}\", binary_op);",
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('a', 'c'))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Range(ClassSetRange::new('b', 'd'))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 3 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))],",
          "    });",
          "    let rhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))],",
          "    });",
          "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
          "        span: Span { start: 0, end: 5 },",
          "        kind: ClassSetBinaryOpKind::Difference,",
          "        lhs,",
          "        rhs,",
          "    });",
          "    let _ = format!(\"{:?}\", binary_op);",
          "}"
        ],
        "oracles": [
          [
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 5 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))],",
            "    });",
            "    let rhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))],",
            "    });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
            "        span: Span { start: 0, end: 5 },",
            "        kind: ClassSetBinaryOpKind::Difference,",
            "        lhs,",
            "        rhs,",
            "    });",
            "    let _ = format!(\"{:?}\", binary_op);",
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alnum:]\"))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Ascii(ClassAscii::new(\"[:alpha:]\"))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 5 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))],",
          "    });",
          "    let rhs = Box::new(ClassSet {",
          "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))],",
          "    });",
          "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
          "        span: Span { start: 0, end: 6 },",
          "        kind: ClassSetBinaryOpKind::Difference,",
          "        lhs,",
          "        rhs,",
          "    });",
          "    let _ = format!(\"{:?}\", binary_op);",
          "}"
        ],
        "oracles": [
          [
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 6 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))],",
            "    });",
            "    let rhs = Box::new(ClassSet {",
            "        items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))],",
            "    });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp {",
            "        span: Span { start: 0, end: 6 },",
            "        kind: ClassSetBinaryOpKind::Difference,",
            "        lhs,",
            "        rhs,",
            "    });",
            "    let _ = format!(\"{:?}\", binary_op);",
            "    let lhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('x'))]))] });",
            "    let rhs = Box::new(ClassSet { items: vec![ClassSetItem::Union(ClassSetUnion::new(vec![ClassSetItem::Literal(Literal::new('y'))]))] });",
            "    let binary_op = ClassInduct::BinaryOp(ClassSetBinaryOp { span: Span { start: 0, end: 6 }, kind: ClassSetBinaryOpKind::Difference, lhs, rhs });",
            "    assert_eq!(format!(\"{:?}\", binary_op), \"BinaryOp(Difference)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]