[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
          "    escape_unicode(bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert_eq!(show, \"\\x00\\x00\\n\");"
          ],
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.contains(r\"\\u{000A}\"));"
          ],
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.len() > show.len());"
          ],
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.chars().any(|c| c.is_whitespace()));"
          ],
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.chars().all(|c| c.is_whitespace() || c as u32 > 0x7F));"
          ],
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(!space_escaped.contains(\"\\\\U\"));"
          ],
          [
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.contains(r\"\\u{0000}\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert_eq!(show, \"\\x00\\x00\\n\");",
            "}"
          ],
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.contains(r\"\\u{000A}\"));",
            "}"
          ],
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.len() > show.len());",
            "}"
          ],
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.chars().any(|c| c.is_whitespace()));",
            "}"
          ],
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.chars().all(|c| c.is_whitespace() || c as u32 > 0x7F));",
            "}"
          ],
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(!space_escaped.contains(\"\\\\U\"));",
            "}"
          ],
          [
            "{",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00]; // Valid UTF-8 with newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0x00, 0x00, 0x0A, 0x00];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert!(space_escaped.contains(r\"\\u{0000}\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes: &[u8] = &[0xF0, 0x9F, 0x98, 0x81]; // Valid UTF-8 for üòÅ",
          "    escape_unicode(bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes: &[u8] = &[0xF0, 0x9F, 0x98, 0x81];",
            "    let result = escape_unicode(bytes);",
            "    assert_eq!(result, r\"\\U{1f601}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes: &[u8] = &[0xF0, 0x9F, 0x98, 0x81]; // Valid UTF-8 for üòÅ",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0xF0, 0x9F, 0x98, 0x81];",
            "    let result = escape_unicode(bytes);",
            "    assert_eq!(result, r\"\\U{1f601}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes: &[u8] = &[0xC4, 0x80, 0x0A, 0xDF]; // Valid UTF-8 and includes newline",
          "    escape_unicode(bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes: &[u8] = &[0xC4, 0x80, 0x0A, 0xDF];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert_eq!(space_escaped, r\"\\u{00c4}\\u{0080}\\n\\u{00df}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes: &[u8] = &[0xC4, 0x80, 0x0A, 0xDF]; // Valid UTF-8 and includes newline",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0xC4, 0x80, 0x0A, 0xDF];",
            "    let show = ::std::str::from_utf8(bytes).unwrap();",
            "    let space_escaped = escape_unicode(bytes);",
            "    assert_eq!(space_escaped, r\"\\u{00c4}\\u{0080}\\n\\u{00df}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let bytes: &[u8] = &[0xED, 0x9F, 0xBF, 0x0A]; // Valid UTF-8 for U+FFFF",
          "    escape_unicode(bytes);",
          "}"
        ],
        "oracles": [
          [
            "    let bytes: &[u8] = &[0xED, 0x9F, 0xBF, 0x0A];",
            "    let result = escape_unicode(bytes);",
            "    assert_eq!(result, \"\\u{ffff}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let bytes: &[u8] = &[0xED, 0x9F, 0xBF, 0x0A]; // Valid UTF-8 for U+FFFF",
            "    escape_unicode(bytes);",
            "    let bytes: &[u8] = &[0xED, 0x9F, 0xBF, 0x0A];",
            "    let result = escape_unicode(bytes);",
            "    assert_eq!(result, \"\\u{ffff}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]