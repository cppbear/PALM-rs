[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockTranslator {",
          "        flags: Cell<Flags>,",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        allow_invalid_utf8: bool,",
          "    }",
          "",
          "    impl MockTranslator {",
          "        fn new() -> Self {",
          "            Self {",
          "                flags: Cell::new(Flags {",
          "                    unicode: Some(true),",
          "                    ..Default::default()",
          "                }),",
          "                stack: RefCell::new(Vec::new()),",
          "                allow_invalid_utf8: false,",
          "            }",
          "        }",
          "    }",
          "",
          "    let translator = MockTranslator::new();",
          "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let span = Span { start: 0, end: 1 };",
          "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
          "        span,",
          "        negated: true,",
          "        kind: ast::ClassSet::Normal,",
          "    });",
          "",
          "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
          "",
          "    let ast = Ast::Class(class_bracketed);",
          "    ",
          "    let result = translator_i.visit_post(&ast);",
          "",
          "    // Test expects an error of kind EmptyClassNotAllowed.",
          "}"
        ],
        "oracles": [
          [
            "    let mut flags = Flags::default();",
            "    flags.unicode = Some(true);",
            "    let mut stack = Vec::new();",
            "    let mut translator = MockTranslator {",
            "    flags: Cell::new(flags),",
            "    stack: RefCell::new(stack),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "    let span = Span { start: 0, end: 1 };",
            "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: true,",
            "    kind: ast::ClassSet::Normal,",
            "    });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
            "    let ast = Ast::Class(class_bracketed);",
            "    let result = translator_i.visit_post(&ast);",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut flags = Flags::default();",
            "    flags.unicode = Some(true);",
            "    let mut stack = Vec::new();",
            "    let mut translator = MockTranslator {",
            "    flags: Cell::new(flags),",
            "    stack: RefCell::new(stack),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "    let span = Span { start: 0, end: 1 };",
            "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: true,",
            "    kind: ast::ClassSet::Normal,",
            "    });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
            "    let ast = Ast::Class(class_bracketed);",
            "    let result = translator_i.visit_post(&ast);",
            "    let error = result.err().unwrap();",
            "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
            "        span,",
            "        negated: true,",
            "        kind: ast::ClassSet::Normal,",
            "    });",
            "",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
            "",
            "    let ast = Ast::Class(class_bracketed);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Test expects an error of kind EmptyClassNotAllowed.",
            "    let mut flags = Flags::default();",
            "    flags.unicode = Some(true);",
            "    let mut stack = Vec::new();",
            "    let mut translator = MockTranslator {",
            "    flags: Cell::new(flags),",
            "    stack: RefCell::new(stack),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "    let span = Span { start: 0, end: 1 };",
            "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: true,",
            "    kind: ast::ClassSet::Normal,",
            "    });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
            "    let ast = Ast::Class(class_bracketed);",
            "    let result = translator_i.visit_post(&ast);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
            "        span,",
            "        negated: true,",
            "        kind: ast::ClassSet::Normal,",
            "    });",
            "",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
            "",
            "    let ast = Ast::Class(class_bracketed);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Test expects an error of kind EmptyClassNotAllowed.",
            "    let mut flags = Flags::default();",
            "    flags.unicode = Some(true);",
            "    let mut stack = Vec::new();",
            "    let mut translator = MockTranslator {",
            "    flags: Cell::new(flags),",
            "    stack: RefCell::new(stack),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "    let span = Span { start: 0, end: 1 };",
            "    let class_bracketed = ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: true,",
            "    kind: ast::ClassSet::Normal,",
            "    });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
            "    let ast = Ast::Class(class_bracketed);",
            "    let result = translator_i.visit_post(&ast);",
            "    let error = result.err().unwrap();",
            "    assert_eq!(error.kind, ErrorKind::EmptyClassNotAllowed);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockTranslator {",
          "        flags: Cell<Flags>,",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        allow_invalid_utf8: bool,",
          "    }",
          "",
          "    impl MockTranslator {",
          "        fn new() -> Self {",
          "            Self {",
          "                flags: Cell::new(Flags {",
          "                    unicode: Some(true),",
          "                    ..Default::default()",
          "                }),",
          "                stack: RefCell::new(Vec::new()),",
          "                allow_invalid_utf8: false,",
          "            }",
          "        }",
          "    }",
          "",
          "    let translator = MockTranslator::new();",
          "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let span = Span { start: 0, end: 1 };",
          "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode {",
          "        span,",
          "        kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()),",
          "        negated: false,",
          "    });",
          "",
          "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
          "",
          "    let ast = Ast::Class(unicode_class);",
          "    ",
          "    let result = translator_i.visit_post(&ast);",
          "",
          "    // Test expects an error of kind EmptyClassNotAllowed.",
          "}"
        ],
        "oracles": [
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
            "    let ast = Ast::Class(unicode_class);",
            "    let result = translator_i.visit_post(&ast);",
            "    assert!(result.is_err());"
          ],
          [
            "    let span = Span { start: 0, end: 1 };",
            "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
            "    let ast = Ast::Class(unicode_class);",
            "    let result = translator_i.visit_post(&ast);",
            "    assert_eq!(result.unwrap_err().kind, ErrorKind::EmptyClassNotAllowed);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode {",
            "        span,",
            "        kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()),",
            "        negated: false,",
            "    });",
            "",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
            "",
            "    let ast = Ast::Class(unicode_class);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Test expects an error of kind EmptyClassNotAllowed.",
            "    let span = Span { start: 0, end: 1 };",
            "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
            "    let ast = Ast::Class(unicode_class);",
            "    let result = translator_i.visit_post(&ast);",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode {",
            "        span,",
            "        kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()),",
            "        negated: false,",
            "    });",
            "",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
            "",
            "    let ast = Ast::Class(unicode_class);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Test expects an error of kind EmptyClassNotAllowed.",
            "    let span = Span { start: 0, end: 1 };",
            "    let unicode_class = ast::Class::Unicode(ast::ClassUnicode { span, kind: ast::ClassUnicodeKind::Named(\"Property\".to_string()), negated: false });",
            "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
            "    let ast = Ast::Class(unicode_class);",
            "    let result = translator_i.visit_post(&ast);",
            "    assert_eq!(result.unwrap_err().kind, ErrorKind::EmptyClassNotAllowed);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockTranslator {",
          "        flags: Cell<Flags>,",
          "        stack: RefCell<Vec<HirFrame>>,",
          "        allow_invalid_utf8: bool,",
          "    }",
          "",
          "    impl MockTranslator {",
          "        fn new() -> Self {",
          "            Self {",
          "                flags: Cell::new(Flags {",
          "                    unicode: Some(true),",
          "                    ..Default::default()",
          "                }),",
          "                stack: RefCell::new(Vec::new()),",
          "                allow_invalid_utf8: false,",
          "            }",
          "        }",
          "    }",
          "",
          "    let translator = MockTranslator::new();",
          "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
          "",
          "    let span = Span { start: 0, end: 1 };",
          "    let literal = ast::Literal {",
          "        span,",
          "        c: 'a',",
          "        kind: ast::LiteralKind::Normal,",
          "    };",
          "",
          "    let ast = Ast::Literal(literal);",
          "    ",
          "    let result = translator_i.visit_post(&ast);",
          "",
          "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
          "}"
        ],
        "oracles": [
          [
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    assert!(result.is_ok());"
          ],
          [
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    assert_eq!(expr.kind(), &HirKind::Literal(literal.clone()));"
          ],
          [
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    assert!(class_bracketed_result.is_err());"
          ],
          [
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
            "    assert!(empty_class.iter().next().is_none());"
          ],
          [
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
            "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
            "    }));",
            "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
            "    assert!(class_unicode_result.is_err());"
          ],
          [
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
            "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
            "    }));",
            "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
            "    let class_perl_ast = Ast::Class(ast::Class::Perl(ast::ClassPerl {",
            "    span,",
            "    kind: ast::ClassPerlKind::Digit,",
            "    negated: false,",
            "    }));",
            "    let class_perl_result = translator_i.visit_post(&class_perl_ast);",
            "    assert!(class_perl_result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = ast::Literal {",
            "        span,",
            "        c: 'a',",
            "        kind: ast::LiteralKind::Normal,",
            "    };",
            "",
            "    let ast = Ast::Literal(literal);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = ast::Literal {",
            "        span,",
            "        c: 'a',",
            "        kind: ast::LiteralKind::Normal,",
            "    };",
            "",
            "    let ast = Ast::Literal(literal);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    assert_eq!(expr.kind(), &HirKind::Literal(literal.clone()));",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = ast::Literal {",
            "        span,",
            "        c: 'a',",
            "        kind: ast::LiteralKind::Normal,",
            "    };",
            "",
            "    let ast = Ast::Literal(literal);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    assert!(class_bracketed_result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = ast::Literal {",
            "        span,",
            "        c: 'a',",
            "        kind: ast::LiteralKind::Normal,",
            "    };",
            "",
            "    let ast = Ast::Literal(literal);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
            "    assert!(empty_class.iter().next().is_none());",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = ast::Literal {",
            "        span,",
            "        c: 'a',",
            "        kind: ast::LiteralKind::Normal,",
            "    };",
            "",
            "    let ast = Ast::Literal(literal);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
            "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
            "    }));",
            "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
            "    assert!(class_unicode_result.is_err());",
            "}"
          ],
          [
            "{",
            "    struct MockTranslator {",
            "        flags: Cell<Flags>,",
            "        stack: RefCell<Vec<HirFrame>>,",
            "        allow_invalid_utf8: bool,",
            "    }",
            "",
            "    impl MockTranslator {",
            "        fn new() -> Self {",
            "            Self {",
            "                flags: Cell::new(Flags {",
            "                    unicode: Some(true),",
            "                    ..Default::default()",
            "                }),",
            "                stack: RefCell::new(Vec::new()),",
            "                allow_invalid_utf8: false,",
            "            }",
            "        }",
            "    }",
            "",
            "    let translator = MockTranslator::new();",
            "    let mut translator_i = TranslatorI::new(&translator, \"test_pattern\");",
            "",
            "    let span = Span { start: 0, end: 1 };",
            "    let literal = ast::Literal {",
            "        span,",
            "        c: 'a',",
            "        kind: ast::LiteralKind::Normal,",
            "    };",
            "",
            "    let ast = Ast::Literal(literal);",
            "    ",
            "    let result = translator_i.visit_post(&ast);",
            "",
            "    // Here, we expect to successfully push a Literal onto the stack, so no error is expected.",
            "    translator_i.push(HirFrame::Expr(Hir::literal(literal)));",
            "    translator_i.pop();  // Assuming we pushed a HirFrame::Expr with a literal",
            "    let expr = translator_i.pop().unwrap().unwrap_expr();",
            "    let class_bracketed_ast = Ast::Class(ast::Class::Bracketed(ast::ClassBracketed {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassSet::Normal,",
            "    }));",
            "    let class_bracketed_result = translator_i.visit_post(&class_bracketed_ast);",
            "    let empty_class = translator_i.pop().unwrap().unwrap_class_unicode();",
            "    let class_unicode_ast = Ast::Class(ast::Class::Unicode(ast::ClassUnicode {",
            "    span,",
            "    negated: false,",
            "    kind: ast::ClassUnicodeKind::OneLetter('L'),",
            "    }));",
            "    let class_unicode_result = translator_i.visit_post(&class_unicode_ast);",
            "    let class_perl_ast = Ast::Class(ast::Class::Perl(ast::ClassPerl {",
            "    span,",
            "    kind: ast::ClassPerlKind::Digit,",
            "    negated: false,",
            "    }));",
            "    let class_perl_result = translator_i.visit_post(&class_perl_ast);",
            "    assert!(class_perl_result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]