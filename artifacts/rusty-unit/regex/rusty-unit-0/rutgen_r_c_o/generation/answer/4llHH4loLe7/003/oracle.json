[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span_empty = Span { start: 0, end: 0 };",
          "    let span_literal = Span { start: 0, end: 1 };",
          "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
          "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
          "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
          "    translator.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.push(HirFrame::Expr(Hir::empty()));",
            "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
            "    let expr = translator.pop().unwrap().unwrap_expr();",
            "    assert!(expr.kind().is_empty());"
          ],
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.push(HirFrame::Expr(Hir::empty()));",
            "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
            "    let expr = translator.pop().unwrap().unwrap_expr();",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    assert!(translator.pop().is_some());"
          ],
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.push(HirFrame::Expr(Hir::empty()));",
            "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
            "    let expr = translator.pop().unwrap().unwrap_expr();",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    assert!(translator.visit_post(&ast).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.push(HirFrame::Expr(Hir::empty()));",
            "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
            "    let expr = translator.pop().unwrap().unwrap_expr();",
            "    assert!(expr.kind().is_empty());",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.push(HirFrame::Expr(Hir::empty()));",
            "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
            "    let expr = translator.pop().unwrap().unwrap_expr();",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    assert!(translator.pop().is_some());",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_literal = Span { start: 0, end: 1 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'a' };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.push(HirFrame::Expr(Hir::empty()));",
            "    translator.push(HirFrame::Expr(Hir::literal(lit)));",
            "    let expr = translator.pop().unwrap().unwrap_expr();",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    assert!(translator.visit_post(&ast).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span_empty = Span { start: 0, end: 0 };",
          "    let span_repetition = Span { start: 0, end: 0 };",
          "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
          "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
          "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
          "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
          "    translator.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    assert_eq!(translator.pop().is_some(), true);"
          ],
          [
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    assert_eq!(frame.is_none(), false);"
          ],
          [
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    let expr = frame.unwrap().unwrap_expr();",
            "    assert_eq!(expr.kind().is_empty(), true);"
          ],
          [
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    let expr = frame.unwrap().unwrap_expr();",
            "    assert_eq!(translator.pop().is_some(), true);"
          ],
          [
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    let expr = frame.unwrap().unwrap_expr();",
            "    assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_repetition = Span { start: 0, end: 0 };",
            "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
            "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    assert_eq!(translator.pop().is_some(), true);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_repetition = Span { start: 0, end: 0 };",
            "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
            "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    assert_eq!(frame.is_none(), false);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_repetition = Span { start: 0, end: 0 };",
            "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
            "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    let expr = frame.unwrap().unwrap_expr();",
            "    assert_eq!(expr.kind().is_empty(), true);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_repetition = Span { start: 0, end: 0 };",
            "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
            "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    let expr = frame.unwrap().unwrap_expr();",
            "    assert_eq!(translator.pop().is_some(), true);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let span_repetition = Span { start: 0, end: 0 };",
            "    let lit = Literal { span: Span { start: 0, end: 1 }, kind: LiteralKind::Character, c: 'b' };",
            "    let rep = Repetition { span: span_repetition, op: RepetitionOp::ZeroOrMore, greedy: true, ast: Box::new(Ast::Literal(lit)) };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty), Ast::Repetition(rep)]);",
            "    let exprs = vec![Hir::empty()];",
            "    translator.push(HirFrame::Expr(Hir::concat(exprs)));",
            "    let frame = translator.pop();",
            "    let expr = frame.unwrap().unwrap_expr();",
            "    assert_eq!(translator.visit_post(&ast).unwrap(), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span_empty = Span { start: 0, end: 0 };",
          "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
          "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
          "    translator.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert_eq!(translator.pop().is_none(), false);"
          ],
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert_eq!(translator.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);"
          ],
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert_eq!(translator.pop().is_none(), true);"
          ],
          [
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert!(translator.visit_post(&ast).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert_eq!(translator.pop().is_none(), false);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert_eq!(translator.pop().unwrap().unwrap_expr().kind(), &HirKind::Empty);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert_eq!(translator.pop().is_none(), true);",
            "}"
          ],
          [
            "{",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_empty = Span { start: 0, end: 0 };",
            "    let ast = Ast::Concat(vec![Ast::Empty(span_empty)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    assert!(translator.visit_post(&ast).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span_literal = Span { start: 1, end: 2 };",
          "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
          "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
          "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
          "    translator.visit_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.pop().is_some());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.pop().is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.pop().is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert_eq!(translator.trans().stack.borrow().len(), 1);"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(matches!(translator.trans().stack.borrow().last(), Some(HirFrame::Expr(_))));"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().case_insensitive.is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().multi_line.is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().dot_matches_new_line.is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().swap_greed.is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().unicode.is_none());"
          ],
          [
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(matches!(translator.pop(), None));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.pop().is_some());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.pop().is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.pop().is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert_eq!(translator.trans().stack.borrow().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(matches!(translator.trans().stack.borrow().last(), Some(HirFrame::Expr(_))));",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().case_insensitive.is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().multi_line.is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().dot_matches_new_line.is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().swap_greed.is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(translator.trans().flags.get().unicode.is_none());",
            "}"
          ],
          [
            "{",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    let span_literal = Span { start: 1, end: 2 };",
            "    let lit = Literal { span: span_literal, kind: LiteralKind::Character, c: 'c' };",
            "    let ast = Ast::Concat(vec![Ast::Literal(lit)]);",
            "    let mut translator = TranslatorI::new(&Translator::default(), \"\");",
            "    translator.visit_post(&ast).unwrap();",
            "    assert!(matches!(translator.pop(), None));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]