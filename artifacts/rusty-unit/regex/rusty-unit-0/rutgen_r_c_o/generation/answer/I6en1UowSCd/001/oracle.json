[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let translator = Translator {",
          "        stack: RefCell::new(vec![]),",
          "        flags: Cell::new(Flags::enabled()),",
          "        allow_invalid_utf8: false,",
          "    };",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    let result = translator_i.pop();",
          "}"
        ],
        "oracles": [
          [
            "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result, None);"
          ],
          [
            "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![HirFrame::Expr(hir::Hir::SomeValue)]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());"
          ],
          [
            "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![HirFrame::Expr(hir::Hir::SomeValue)]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![HirFrame::Expr(hir::Hir::SomeValue), HirFrame::Concat]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result, Some(HirFrame::Concat));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let translator = Translator {",
            "        stack: RefCell::new(vec![]),",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result, None);",
            "}"
          ],
          [
            "{",
            "    let translator = Translator {",
            "        stack: RefCell::new(vec![]),",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![HirFrame::Expr(hir::Hir::SomeValue)]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let translator = Translator {",
            "        stack: RefCell::new(vec![]),",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![HirFrame::Expr(hir::Hir::SomeValue)]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let translator = Translator { stack: RefCell::new(vec![HirFrame::Expr(hir::Hir::SomeValue), HirFrame::Concat]), flags: Cell::new(Flags::enabled()), allow_invalid_utf8: false };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result, Some(HirFrame::Concat));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack = RefCell::new(vec![]);",
          "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
          "    let translator = Translator {",
          "        stack,",
          "        flags: Cell::new(Flags::enabled()),",
          "        allow_invalid_utf8: false,",
          "    };",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    let result = translator_i.pop();",
          "}"
        ],
        "oracles": [
          [
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());"
          ],
          [
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(matches!(result.unwrap(), HirFrame::Expr(_)));"
          ],
          [
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack2 = RefCell::new(vec![]);",
            "    let translator2 = Translator {",
            "    stack: stack2,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i2 = TranslatorI::new(&translator2, \"pattern\");",
            "    let result2 = translator_i2.pop();",
            "    assert!(result2.is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(matches!(result.unwrap(), HirFrame::Expr(_)));",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![]);",
            "    stack.borrow_mut().push(HirFrame::Expr(Hir::new()));",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack2 = RefCell::new(vec![]);",
            "    let translator2 = Translator {",
            "    stack: stack2,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i2 = TranslatorI::new(&translator2, \"pattern\");",
            "    let result2 = translator_i2.pop();",
            "    assert!(result2.is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack = RefCell::new(vec![",
          "        HirFrame::Expr(Hir::new()),",
          "        HirFrame::ClassUnicode(hir::ClassUnicode::new()),",
          "    ]);",
          "    let translator = Translator {",
          "        stack,",
          "        flags: Cell::new(Flags::enabled()),",
          "        allow_invalid_utf8: true,",
          "    };",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    let first_pop = translator_i.pop();",
          "    let second_pop = translator_i.pop();",
          "}"
        ],
        "oracles": [
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Expr(Hir::new()), HirFrame::ClassUnicode(hir::ClassUnicode::new())]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::enabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(first_pop, Some(HirFrame::ClassUnicode(hir::ClassUnicode::new())));"
          ],
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Expr(Hir::new()), HirFrame::ClassUnicode(hir::ClassUnicode::new())]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::enabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(second_pop, Some(HirFrame::Expr(Hir::new())));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Expr(Hir::new()),",
            "        HirFrame::ClassUnicode(hir::ClassUnicode::new()),",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let first_pop = translator_i.pop();",
            "    let second_pop = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Expr(Hir::new()), HirFrame::ClassUnicode(hir::ClassUnicode::new())]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::enabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(first_pop, Some(HirFrame::ClassUnicode(hir::ClassUnicode::new())));",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Expr(Hir::new()),",
            "        HirFrame::ClassUnicode(hir::ClassUnicode::new()),",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let first_pop = translator_i.pop();",
            "    let second_pop = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Expr(Hir::new()), HirFrame::ClassUnicode(hir::ClassUnicode::new())]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::enabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(second_pop, Some(HirFrame::Expr(Hir::new())));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack = RefCell::new(vec![",
          "        HirFrame::Group { old_flags: None },",
          "    ]);",
          "    let translator = Translator {",
          "        stack,",
          "        flags: Cell::new(Flags::disabled()),",
          "        allow_invalid_utf8: true,",
          "    };",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    let result = translator_i.pop();",
          "}"
        ],
        "oracles": [
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Group { old_flags: None }]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::disabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());"
          ],
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Group { old_flags: None }]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::disabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result.unwrap(), HirFrame::Group { old_flags: None });"
          ],
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Group { old_flags: None }]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::disabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(translator.stack.borrow().is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Group { old_flags: None },",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::disabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Group { old_flags: None }]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::disabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Group { old_flags: None },",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::disabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Group { old_flags: None }]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::disabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result.unwrap(), HirFrame::Group { old_flags: None });",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Group { old_flags: None },",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::disabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Group { old_flags: None }]);",
            "    let translator = Translator { stack, flags: Cell::new(Flags::disabled()), allow_invalid_utf8: true };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(translator.stack.borrow().is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack = RefCell::new(vec![",
          "        HirFrame::Alternation,",
          "        HirFrame::ClassBytes(hir::ClassBytes::new()),",
          "    ]);",
          "    let translator = Translator {",
          "        stack,",
          "        flags: Cell::new(Flags::enabled()),",
          "        allow_invalid_utf8: false,",
          "    };",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    let first_pop = translator_i.pop();",
          "    let second_pop = translator_i.pop();",
          "}"
        ],
        "oracles": [
          [
            "    let mut stack = RefCell::new(vec![",
            "    HirFrame::Alternation,",
            "    HirFrame::ClassBytes(hir::ClassBytes::new()),",
            "    ]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(first_pop, Some(HirFrame::ClassBytes(hir::ClassBytes::new())));"
          ],
          [
            "    let mut stack = RefCell::new(vec![",
            "    HirFrame::Alternation,",
            "    HirFrame::ClassBytes(hir::ClassBytes::new()),",
            "    ]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(second_pop, Some(HirFrame::Alternation));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Alternation,",
            "        HirFrame::ClassBytes(hir::ClassBytes::new()),",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let first_pop = translator_i.pop();",
            "    let second_pop = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![",
            "    HirFrame::Alternation,",
            "    HirFrame::ClassBytes(hir::ClassBytes::new()),",
            "    ]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(first_pop, Some(HirFrame::ClassBytes(hir::ClassBytes::new())));",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Alternation,",
            "        HirFrame::ClassBytes(hir::ClassBytes::new()),",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let first_pop = translator_i.pop();",
            "    let second_pop = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![",
            "    HirFrame::Alternation,",
            "    HirFrame::ClassBytes(hir::ClassBytes::new()),",
            "    ]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: false,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    assert_eq!(second_pop, Some(HirFrame::Alternation));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut stack = RefCell::new(vec![",
          "        HirFrame::Concat,",
          "    ]);",
          "    let translator = Translator {",
          "        stack,",
          "        flags: Cell::new(Flags::enabled()),",
          "        allow_invalid_utf8: true,",
          "    };",
          "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
          "    let result = translator_i.pop();",
          "}"
        ],
        "oracles": [
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Concat]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());"
          ],
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Concat]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result, Some(HirFrame::Concat));"
          ],
          [
            "    let mut stack = RefCell::new(vec![HirFrame::Concat]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(translator_i.trans().stack.borrow().is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Concat,",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Concat]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Concat,",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Concat]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert_eq!(result, Some(HirFrame::Concat));",
            "}"
          ],
          [
            "{",
            "    let mut stack = RefCell::new(vec![",
            "        HirFrame::Concat,",
            "    ]);",
            "    let translator = Translator {",
            "        stack,",
            "        flags: Cell::new(Flags::enabled()),",
            "        allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    let mut stack = RefCell::new(vec![HirFrame::Concat]);",
            "    let translator = Translator {",
            "    stack,",
            "    flags: Cell::new(Flags::enabled()),",
            "    allow_invalid_utf8: true,",
            "    };",
            "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
            "    let result = translator_i.pop();",
            "    assert!(translator_i.trans().stack.borrow().is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]