[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![]);",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![]);",
            "    let expected_matcher = Matcher::Empty;",
            "    assert_eq!(Matcher::prefixes(&lits), expected_matcher);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![]);",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new(vec![]);",
            "    let expected_matcher = Matcher::Empty;",
            "    assert_eq!(Matcher::prefixes(&lits), expected_matcher);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![]]);",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![vec![]]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matches!(matcher, Matcher::Empty));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![]]);",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new(vec![vec![]]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matches!(matcher, Matcher::Empty));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![b'a']]);",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 1);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == true);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == true);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse[b'a' as usize] == true);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().filter(|&&x| x).count() == 1);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(Matcher::new(&lits, sset).is_a_single_byte_set());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse[b'a' as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().filter(|&&x| x).count() == 1);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(Matcher::new(&lits, sset).is_a_single_byte_set());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matches!(matcher, Matcher::Bytes(_)));"
          ],
          [
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matcher.prefixes.lits.literals().len() == 3);"
          ],
          [
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matcher.prefixes.complete == false);"
          ],
          [
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matcher.prefixes.all_ascii == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matches!(matcher, Matcher::Bytes(_)));",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matcher.prefixes.lits.literals().len() == 3);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matcher.prefixes.complete == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'b'], vec![b'c']]);",
            "    let matcher = Matcher::prefixes(&lits);",
            "    assert!(matcher.prefixes.all_ascii == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![b'a'], vec![b'\\x80']]);",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == false);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == false);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 2);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse[b'a' as usize] == true);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse[b'\\x80' as usize] == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'\\x80']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'\\x80']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'\\x80']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 2);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'\\x80']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse[b'a' as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![b'a'], vec![b'\\x80']]);",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse[b'\\x80' as usize] == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert_eq!(sset.complete, false);"
          ],
          [
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);"
          ],
          [
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert_eq!(sset.dense.len(), 26);"
          ],
          [
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().all(|&b| b));"
          ],
          [
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(Matcher::new(&lits, sset).is_empty() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert_eq!(sset.complete, false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert_eq!(sset.dense.len(), 26);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().all(|&b| b));",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..26).map(|i| vec![i as u8]).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(Matcher::new(&lits, sset).is_empty() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == false);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == true);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 1);"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense[0] == b'a');"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().all(|&x| x == false || x == true));"
          ],
          [
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(Matcher::new(&lits, sset) == Matcher::Bytes(sset));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense[0] == b'a');",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().all(|&x| x == false || x == true));",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'a']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(Matcher::new(&lits, sset) == Matcher::Bytes(sset));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
          "    Matcher::prefixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == false);"
          ],
          [
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == true);"
          ],
          [
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 1);"
          ],
          [
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().all(|&b| b == true || b == false));"
          ],
          [
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense[0] == b'b');"
          ],
          [
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.approximate_size() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.complete == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.all_ascii == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense.len() == 1);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.sparse.iter().all(|&b| b == true || b == false));",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.dense[0] == b'b');",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    Matcher::prefixes(&lits);",
            "    let lits = Literals::new((0..32).map(|i| vec![b'b']).collect());",
            "    let sset = SingleByteSet::prefixes(&lits);",
            "    assert!(sset.approximate_size() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]