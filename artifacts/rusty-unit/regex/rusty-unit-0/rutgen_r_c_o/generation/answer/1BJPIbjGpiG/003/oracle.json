[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
          "        c: '\\r',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    output.push(b'\\r');",
            "    assert_eq!(String::from_utf8(output).unwrap(), \"\\r\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "        c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    output.push(b'\\r');",
            "    assert_eq!(String::from_utf8(output).unwrap(), \"\\r\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
          "        c: '\\u{0B}',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output.as_slice(), b\"\\x0B\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "        c: '\\u{0B}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output.as_slice(), b\"\\x0B\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
          "        c: ' ',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ', };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast).unwrap();",
            "    assert_eq!(output, b\"\\x20\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ', };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast).unwrap();",
            "    assert!(output.is_empty() == false);"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ', };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast).unwrap();",
            "    assert!(output.len() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "        c: ' ',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ', };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast).unwrap();",
            "    assert_eq!(output, b\"\\x20\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "        c: ' ',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ', };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast).unwrap();",
            "    assert!(output.is_empty() == false);",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "        c: ' ',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal { span: Span::default(), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space), c: ' ', };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast).unwrap();",
            "    assert!(output.len() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
          "        c: '\\u{07}',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\a\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\n\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\x{41}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\U{F600}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\u{FFFF}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\r\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\v\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\f\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\t\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\ \");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\x{41}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\U{F600}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\u{FFFF}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\t\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "        c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\u{07}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}', // 'A'",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{F600}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{FFFF}', // some unicode character",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\u{0B}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\ \");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
          "        c: '\\n',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\n\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\r\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\x{41}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1234}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\U{0001234}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1234}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{ABCD}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\u{ABCD}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1234}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{ABCD}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\t\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\n\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\x{41}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1234}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\U{0001234}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1234}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{ABCD}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\u{ABCD}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "        c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\x41',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1234}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{ABCD}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\t\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
          "        c: '\\u{0C}',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\f\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\r\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\t\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\x{41}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{F6}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\u{F6}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{F6}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1F600}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\U{1F600}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "        c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\f\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "        c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "        c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\t\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "        c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\x{41}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "        c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{F6}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\u{F6}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "        c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\u{0C}',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\u{0D}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\u{09}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: '\\u{41}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: '\\u{F6}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: '\\u{1F600}',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\U{1F600}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
          "        c: 'A',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\x{41}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\r\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\v\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\ \");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\u{42}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\U{0043}\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\x{41}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\ \");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\u{42}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "        c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'A',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output.as_slice(), b\"\\\\U{0043}\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
          "        c: 'B',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\\\u{0042}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\x{42}\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\r\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\v\");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\ \");"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\a\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    assert_eq!(output, b\"\\\\u{0042}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\x{42}\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\r\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\v\");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\ \");",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "        c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeShort),",
            "    c: 'B',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, b\"\\\\a\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = Vec::new();",
          "    let ast = ast::Literal {",
          "        span: Span::default(),",
          "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
          "        c: 'C',",
          "    };",
          "    let printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: output };",
          "    writer.fmt_literal(&ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000043}\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{43}\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\".as_bytes());"
          ],
          [
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\".as_bytes());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\U{00000043}\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\x{43}\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\r\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\v\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\ \".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\a\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\n\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\f\".as_bytes());",
            "}"
          ],
          [
            "{",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "        span: Span::default(),",
            "        kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "        c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let mut output = Vec::new();",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::UnicodeLong),",
            "    c: 'C',",
            "    };",
            "    let printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: output };",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::HexBrace(ast::HexLiteralKind::X),",
            "    c: 'C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab),",
            "    c: '\\x0B',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Space),",
            "    c: ' ',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell),",
            "    c: '\\x07',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::LineFeed),",
            "    c: '\\n',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::FormFeed),",
            "    c: '\\x0C',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    let ast = ast::Literal {",
            "    span: Span::default(),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab),",
            "    c: '\\t',",
            "    };",
            "    output.clear();",
            "    writer.fmt_literal(&ast);",
            "    assert_eq!(output, r\"\\t\".as_bytes());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]