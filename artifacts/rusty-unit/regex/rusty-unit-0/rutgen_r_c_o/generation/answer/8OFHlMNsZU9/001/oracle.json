[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
          "    let match_start: usize = 5;",
          "    let match_end: usize = 10;",
          "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
          "    ",
          "    let exec_read_only = ExecReadOnly {",
          "        res: vec![\"abc\".to_string()],",
          "        nfa: Program::default(),",
          "        dfa: Program::default(),",
          "        dfa_reverse: Program::default(),",
          "        suffixes: LiteralSearcher::default(),",
          "        match_type: MatchType::default(),",
          "    };",
          "",
          "    let program_cache = RefCell::new(ProgramCacheInner::default());",
          "    let exec = ExecNoSync {",
          "        ro: &Arc::new(exec_read_only),",
          "        cache: &program_cache,",
          "    };",
          "",
          "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
          "}"
        ],
        "oracles": [
          [
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert!(result.is_some());"
          ],
          [
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let (found_start, found_end) = result.unwrap();",
            "    assert!(found_start >= match_start);"
          ],
          [
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let (found_start, found_end) = result.unwrap();",
            "    assert!(found_start < match_end);"
          ],
          [
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let (found_start, found_end) = result.unwrap();",
            "    assert!(found_end <= next_utf8(text, match_end));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let (found_start, found_end) = result.unwrap();",
            "    assert!(found_start >= match_start);",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let (found_start, found_end) = result.unwrap();",
            "    assert!(found_start < match_end);",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcdefghijklmnopqrstuvwxyz\";",
            "    let match_start: usize = 5;",
            "    let match_end: usize = 10;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 20];",
            "    let exec_read_only = ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync { ro: &Arc::new(exec_read_only), cache: &program_cache, };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let (found_start, found_end) = result.unwrap();",
            "    assert!(found_end <= next_utf8(text, match_end));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let text: &[u8] = b\"abcde\";",
          "    let match_start: usize = 0;",
          "    let match_end: usize = 3;",
          "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
          "    ",
          "    let exec_read_only = ExecReadOnly {",
          "        res: vec![\"abc\".to_string()],",
          "        nfa: Program::default(),",
          "        dfa: Program::default(),",
          "        dfa_reverse: Program::default(),",
          "        suffixes: LiteralSearcher::default(),",
          "        match_type: MatchType::default(),",
          "    };",
          "",
          "    let program_cache = RefCell::new(ProgramCacheInner::default());",
          "    let exec = ExecNoSync {",
          "        ro: &Arc::new(exec_read_only),",
          "        cache: &program_cache,",
          "    };",
          "",
          "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
          "}"
        ],
        "oracles": [
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert!(result.is_some());"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots.len(), 6);"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[0], Slot::default());"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[1], Slot::default());"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[2], Slot::default());"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[3], Slot::default());"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[4], Slot::default());"
          ],
          [
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[5], Slot::default());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots.len(), 6);",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[0], Slot::default());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[1], Slot::default());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[2], Slot::default());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[3], Slot::default());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[4], Slot::default());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"abcde\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 3;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(slots[5], Slot::default());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let text: &[u8] = b\"short\";",
          "    let match_start: usize = 0;",
          "    let match_end: usize = 5; // This should trigger a panic because match_end + 2 > text.len()",
          "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
          "    ",
          "    let exec_read_only = ExecReadOnly {",
          "        res: vec![\"abc\".to_string()],",
          "        nfa: Program::default(),",
          "        dfa: Program::default(),",
          "        dfa_reverse: Program::default(),",
          "        suffixes: LiteralSearcher::default(),",
          "        match_type: MatchType::default(),",
          "    };",
          "",
          "    let program_cache = RefCell::new(ProgramCacheInner::default());",
          "    let exec = ExecNoSync {",
          "        ro: &Arc::new(exec_read_only),",
          "        cache: &program_cache,",
          "    };",
          "",
          "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
          "}"
        ],
        "oracles": [
          [
            "    let text: &[u8] = b\"short\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 5;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = std::panic::catch_unwind(|| {",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    });",
            "    assert!(result.is_err());"
          ],
          [
            "    let text: &[u8] = b\"short\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 5;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = std::panic::catch_unwind(|| {",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    });",
            "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let text: &[u8] = b\"short\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 5; // This should trigger a panic because match_end + 2 > text.len()",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"short\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 5;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = std::panic::catch_unwind(|| {",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    });",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let text: &[u8] = b\"short\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 5; // This should trigger a panic because match_end + 2 > text.len()",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"short\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 5;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 10];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = std::panic::catch_unwind(|| {",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    });",
            "    assert_eq!(result.unwrap_err().downcast_ref::<&str>(), None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let text: &[u8] = b\"\";",
          "    let match_start: usize = 0;",
          "    let match_end: usize = 0;",
          "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
          "    ",
          "    let exec_read_only = ExecReadOnly {",
          "        res: vec![\"abc\".to_string()],",
          "        nfa: Program::default(),",
          "        dfa: Program::default(),",
          "        dfa_reverse: Program::default(),",
          "        suffixes: LiteralSearcher::default(),",
          "        match_type: MatchType::default(),",
          "    };",
          "",
          "    let program_cache = RefCell::new(ProgramCacheInner::default());",
          "    let exec = ExecNoSync {",
          "        ro: &Arc::new(exec_read_only),",
          "        cache: &program_cache,",
          "    };",
          "",
          "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
          "}"
        ],
        "oracles": [
          [
            "    let text: &[u8] = b\"\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 0;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(result, None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let text: &[u8] = b\"\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 0;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    ",
            "    let exec_read_only = ExecReadOnly {",
            "        res: vec![\"abc\".to_string()],",
            "        nfa: Program::default(),",
            "        dfa: Program::default(),",
            "        dfa_reverse: Program::default(),",
            "        suffixes: LiteralSearcher::default(),",
            "        match_type: MatchType::default(),",
            "    };",
            "",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "        ro: &Arc::new(exec_read_only),",
            "        cache: &program_cache,",
            "    };",
            "",
            "    exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    let text: &[u8] = b\"\";",
            "    let match_start: usize = 0;",
            "    let match_end: usize = 0;",
            "    let slots: &mut [Slot] = &mut [Slot::default(); 6];",
            "    let exec_read_only = ExecReadOnly {",
            "    res: vec![\"abc\".to_string()],",
            "    nfa: Program::default(),",
            "    dfa: Program::default(),",
            "    dfa_reverse: Program::default(),",
            "    suffixes: LiteralSearcher::default(),",
            "    match_type: MatchType::default(),",
            "    };",
            "    let program_cache = RefCell::new(ProgramCacheInner::default());",
            "    let exec = ExecNoSync {",
            "    ro: &Arc::new(exec_read_only),",
            "    cache: &program_cache,",
            "    };",
            "    let result = exec.captures_nfa_with_match(slots, text, match_start, match_end);",
            "    assert_eq!(result, None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]