[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache_inner = CacheInner {",
          "        compiled: HashMap::new(),",
          "        trans: Transitions {",
          "            table: Vec::new(),",
          "            num_byte_classes: 0,",
          "        },",
          "        states: Vec::new(),",
          "        start_states: Vec::new(),",
          "        stack: Vec::new(),",
          "        flush_count: 0,",
          "        size: 0,",
          "    };",
          "    cache_inner.reset_size();",
          "}"
        ],
        "oracles": [
          [
            "    let expected_size = 0;",
            "    assert_eq!(cache_inner.size, expected_size);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut cache_inner = CacheInner {",
            "        compiled: HashMap::new(),",
            "        trans: Transitions {",
            "            table: Vec::new(),",
            "            num_byte_classes: 0,",
            "        },",
            "        states: Vec::new(),",
            "        start_states: Vec::new(),",
            "        stack: Vec::new(),",
            "        flush_count: 0,",
            "        size: 0,",
            "    };",
            "    cache_inner.reset_size();",
            "    let expected_size = 0;",
            "    assert_eq!(cache_inner.size, expected_size);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache_inner = CacheInner {",
          "        compiled: HashMap::new(),",
          "        trans: Transitions {",
          "            table: Vec::new(),",
          "            num_byte_classes: 0,",
          "        },",
          "        states: Vec::new(),",
          "        start_states: vec![0, 1, 2],",
          "        stack: Vec::new(),",
          "        flush_count: 0,",
          "        size: 0,",
          "    };",
          "    cache_inner.reset_size();",
          "}"
        ],
        "oracles": [
          [
            "    let mut cache_inner = CacheInner { compiled: HashMap::new(), trans: Transitions { table: Vec::new(), num_byte_classes: 0 }, states: Vec::new(), start_states: vec![0, 1, 2], stack: Vec::new(), flush_count: 0, size: 0 };",
            "    cache_inner.reset_size();",
            "    assert_eq!(cache_inner.size, (3 * mem::size_of::<StatePtr>()) + (0 * mem::size_of::<InstPtr>()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut cache_inner = CacheInner {",
            "        compiled: HashMap::new(),",
            "        trans: Transitions {",
            "            table: Vec::new(),",
            "            num_byte_classes: 0,",
            "        },",
            "        states: Vec::new(),",
            "        start_states: vec![0, 1, 2],",
            "        stack: Vec::new(),",
            "        flush_count: 0,",
            "        size: 0,",
            "    };",
            "    cache_inner.reset_size();",
            "    let mut cache_inner = CacheInner { compiled: HashMap::new(), trans: Transitions { table: Vec::new(), num_byte_classes: 0 }, states: Vec::new(), start_states: vec![0, 1, 2], stack: Vec::new(), flush_count: 0, size: 0 };",
            "    cache_inner.reset_size();",
            "    assert_eq!(cache_inner.size, (3 * mem::size_of::<StatePtr>()) + (0 * mem::size_of::<InstPtr>()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache_inner = CacheInner {",
          "        compiled: HashMap::new(),",
          "        trans: Transitions {",
          "            table: Vec::new(),",
          "            num_byte_classes: 0,",
          "        },",
          "        states: Vec::new(),",
          "        start_states: Vec::new(),",
          "        stack: vec![0, 1, 2, 3, 4],",
          "        flush_count: 0,",
          "        size: 0,",
          "    };",
          "    cache_inner.reset_size();",
          "}"
        ],
        "oracles": [
          [
            "    let expected_size = (cache_inner.start_states.len() * mem::size_of::<StatePtr>()) + (cache_inner.stack.len() * mem::size_of::<InstPtr>());",
            "    assert_eq!(cache_inner.size, expected_size);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut cache_inner = CacheInner {",
            "        compiled: HashMap::new(),",
            "        trans: Transitions {",
            "            table: Vec::new(),",
            "            num_byte_classes: 0,",
            "        },",
            "        states: Vec::new(),",
            "        start_states: Vec::new(),",
            "        stack: vec![0, 1, 2, 3, 4],",
            "        flush_count: 0,",
            "        size: 0,",
            "    };",
            "    cache_inner.reset_size();",
            "    let expected_size = (cache_inner.start_states.len() * mem::size_of::<StatePtr>()) + (cache_inner.stack.len() * mem::size_of::<InstPtr>());",
            "    assert_eq!(cache_inner.size, expected_size);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache_inner = CacheInner {",
          "        compiled: HashMap::new(),",
          "        trans: Transitions {",
          "            table: Vec::new(),",
          "            num_byte_classes: 0,",
          "        },",
          "        states: Vec::new(),",
          "        start_states: (0..1000).collect(),",
          "        stack: (0..2000).collect(),",
          "        flush_count: 0,",
          "        size: 0,",
          "    };",
          "    cache_inner.reset_size();",
          "}"
        ],
        "oracles": [
          [
            "    cache_inner.size = (cache_inner.start_states.len() * mem::size_of::<StatePtr>()) + (cache_inner.stack.len() * mem::size_of::<InstPtr>())",
            "    assert_eq!(cache_inner.size, (1000 * mem::size_of::<StatePtr>()) + (2000 * mem::size_of::<InstPtr>()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut cache_inner = CacheInner {",
            "        compiled: HashMap::new(),",
            "        trans: Transitions {",
            "            table: Vec::new(),",
            "            num_byte_classes: 0,",
            "        },",
            "        states: Vec::new(),",
            "        start_states: (0..1000).collect(),",
            "        stack: (0..2000).collect(),",
            "        flush_count: 0,",
            "        size: 0,",
            "    };",
            "    cache_inner.reset_size();",
            "    cache_inner.size = (cache_inner.start_states.len() * mem::size_of::<StatePtr>()) + (cache_inner.stack.len() * mem::size_of::<InstPtr>())",
            "    assert_eq!(cache_inner.size, (1000 * mem::size_of::<StatePtr>()) + (2000 * mem::size_of::<InstPtr>()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut cache_inner = CacheInner {",
          "        compiled: HashMap::new(),",
          "        trans: Transitions {",
          "            table: Vec::new(),",
          "            num_byte_classes: 0,",
          "        },",
          "        states: Vec::new(),",
          "        start_states: vec![STATE_MAX], // Upper bound test case",
          "        stack: vec![u32::MAX], // Max InstPtr value",
          "        flush_count: 0,",
          "        size: 0,",
          "    };",
          "    cache_inner.reset_size();",
          "}"
        ],
        "oracles": [
          [
            "    let state_size = mem::size_of::<StatePtr>();",
            "    let inst_size = mem::size_of::<InstPtr>();",
            "    let expected_size = (cache_inner.start_states.len() * state_size) + (cache_inner.stack.len() * inst_size);",
            "    assert_eq!(cache_inner.size, expected_size);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut cache_inner = CacheInner {",
            "        compiled: HashMap::new(),",
            "        trans: Transitions {",
            "            table: Vec::new(),",
            "            num_byte_classes: 0,",
            "        },",
            "        states: Vec::new(),",
            "        start_states: vec![STATE_MAX], // Upper bound test case",
            "        stack: vec![u32::MAX], // Max InstPtr value",
            "        flush_count: 0,",
            "        size: 0,",
            "    };",
            "    cache_inner.reset_size();",
            "    let state_size = mem::size_of::<StatePtr>();",
            "    let inst_size = mem::size_of::<InstPtr>();",
            "    let expected_size = (cache_inner.start_states.len() * state_size) + (cache_inner.stack.len() * inst_size);",
            "    assert_eq!(cache_inner.size, expected_size);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]