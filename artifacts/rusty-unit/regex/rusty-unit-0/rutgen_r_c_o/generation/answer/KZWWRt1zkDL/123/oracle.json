[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\a\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    assert_eq!(parser.char(), '\\\\');"
          ],
          [
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    assert!(parser.bump());"
          ],
          [
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let c = parser.char();",
            "    assert!(c == 'a');"
          ],
          [
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let c = parser.char();",
            "    let span = Span::new(parser.pos(), parser.pos());",
            "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: span, kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' })));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    assert_eq!(parser.char(), '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let c = parser.char();",
            "    assert!(c == 'a');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\a\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let c = parser.char();",
            "    let span = Span::new(parser.pos(), parser.pos());",
            "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal { span: span, kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Bell), c: '\\x07' })));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\f\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\f\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\f\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\f\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\f\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\f\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\f\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == LiteralKind::Special(SpecialLiteralKind::FormFeed)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\n\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(c, '\\\\');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(parser.bump());"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c != '0' && c != '7');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c != '8' && c != '9');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c == 'n');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(parser.parse_escape().is_ok());"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Literal(ast::Literal {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(c, '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c != '0' && c != '7');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c != '8' && c != '9');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c == 'n');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(parser.parse_escape().is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\n\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Literal(ast::Literal {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\r\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\r\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let expected = Ok(Primitive::Literal(ast::Literal {",
            "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 }),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    }));",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\r\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\r\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let expected = Ok(Primitive::Literal(ast::Literal {",
            "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 }),",
            "    kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::CarriageReturn),",
            "    c: '\\r',",
            "    }));",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\t\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\t\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\t\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert_eq!(result.unwrap(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' })));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\t\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\t\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\t\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\t\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert_eq!(result.unwrap(), Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::Tab), c: '\\t' })));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\v\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\v\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' })));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\v\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\v\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Special(ast::SpecialLiteralKind::VerticalTab), c: '\\x0B' })));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\ \";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start = parser.pos();",
            "    assert_eq!(parser.char(), '\\\\');"
          ],
          [
            "    let start = parser.pos();",
            "    assert!(parser.bump());"
          ],
          [
            "    let start = parser.pos();",
            "    assert_eq!(parser.char(), ' ');"
          ],
          [
            "    let start = parser.pos();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\ \";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert_eq!(parser.char(), '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\ \";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\ \";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert_eq!(parser.char(), ' ');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\ \";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(parser.parse_escape(), Ok(Primitive::Literal(ast::Literal {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\+\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert_eq!(parser.char(), '\\\\');"
          ],
          [
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert!(parser.bump());"
          ],
          [
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert_eq!(parser.char(), c);"
          ],
          [
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert!(is_meta_character(c));"
          ],
          [
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    let expected = Ok(Primitive::Literal(ast::Literal { span, kind: ast::LiteralKind::Punctuation, c }));",
            "    assert_eq!(parser.parse_escape(), expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\+\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert_eq!(parser.char(), '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\+\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\+\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert_eq!(parser.char(), c);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\+\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    assert!(is_meta_character(c));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\+\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let c = '+';",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let span = Span::new(start, Position { offset: 1, line: 1, column: 2 });",
            "    let expected = Ok(Primitive::Literal(ast::Literal { span, kind: ast::LiteralKind::Punctuation, c }));",
            "    assert_eq!(parser.parse_escape(), expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\*\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\*\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\*\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == ast::LiteralKind::Punctuation && lit.c == '*'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\*\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\*\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\*\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\*\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == ast::LiteralKind::Punctuation && lit.c == '*'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\?\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(c, '?');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(parser.bump());"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(parser.char(), '?');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let expected = Primitive::Literal(ast::Literal {",
            "    span: Span::new(start, parser.pos()),",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '?',",
            "    });",
            "    assert_eq!(parser.parse_escape().unwrap(), expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\?\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(c, '?');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\?\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\?\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(parser.char(), '?');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\?\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let expected = Primitive::Literal(ast::Literal {",
            "    span: Span::new(start, parser.pos()),",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '?',",
            "    });",
            "    assert_eq!(parser.parse_escape().unwrap(), expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\|\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.span.start.offset, 0);"
          ],
          [
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.span.end.offset, 2);"
          ],
          [
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.kind, ast::LiteralKind::Punctuation);"
          ],
          [
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.c, '|');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.span.start.offset, 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.span.end.offset, 2);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.kind, ast::LiteralKind::Punctuation);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\|\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.c, '|');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\(\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: \"\\\\(\" };",
            "    let result = parser.parse_escape();",
            "    let expected = Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Punctuation, c: '(' }));",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\(\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: \"\\\\(\" };",
            "    let result = parser.parse_escape();",
            "    let expected = Ok(Primitive::Literal(ast::Literal { span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }), kind: ast::LiteralKind::Punctuation, c: '(' }));",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\)\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    assert_eq!(parser.char(), '\\\\');"
          ],
          [
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    assert!(parser.bump());"
          ],
          [
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c == ')');"
          ],
          [
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert!(is_meta_character(c));"
          ],
          [
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Literal(ast::Literal {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    assert_eq!(parser.char(), '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c == ')');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert!(is_meta_character(c));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\)\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Literal(ast::Literal {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\[\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\[\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let expected = Ok(Primitive::Literal(ast::Literal {",
            "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '['",
            "    }));",
            "    assert_eq!(result, expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\[\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\[\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let expected = Ok(Primitive::Literal(ast::Literal {",
            "    span: Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 2, line: 1, column: 3 }),",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '['",
            "    }));",
            "    assert_eq!(result, expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\]\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    assert_eq!(parser.char(), '\\\\');"
          ],
          [
            "    let start = parser.pos();",
            "    assert!(parser.bump());"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(c, ']');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert!(is_meta_character(c));"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Literal(ast::Literal {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\]\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    assert_eq!(parser.char(), '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\]\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\]\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert_eq!(c, ']');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\]\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert!(is_meta_character(c));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\]\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(parser.parse_escape().unwrap(), Ok(Primitive::Literal(ast::Literal {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\{\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let expected_span = Span::new(start, Position { offset: 2, line: 1, column: 3 });",
            "    let expected_literal = ast::Literal {",
            "    span: expected_span,",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '{',",
            "    };",
            "    let expected_result = Ok(Primitive::Literal(expected_literal));",
            "    assert_eq!(parser.parse_escape(), expected_result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\{\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = Position { offset: 0, line: 1, column: 1 };",
            "    let expected_span = Span::new(start, Position { offset: 2, line: 1, column: 3 });",
            "    let expected_literal = ast::Literal {",
            "    span: expected_span,",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '{',",
            "    };",
            "    let expected_result = Ok(Primitive::Literal(expected_literal));",
            "    assert_eq!(parser.parse_escape(), expected_result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\}\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\}\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(matches!(result, Ok(Primitive::Literal(lit)) if lit.span.start == Position {offset: 0, line: 1, column: 1} && lit.c == '}'));"
          ],
          [
            "    let pattern = \"\\\\}\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(matches!(result, Ok(Primitive::Literal(lit)) if lit.kind == LiteralKind::Punctuation));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\}\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\}\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(matches!(result, Ok(Primitive::Literal(lit)) if lit.span.start == Position {offset: 0, line: 1, column: 1} && lit.c == '}'));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\}\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\}\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(matches!(result, Ok(Primitive::Literal(lit)) if lit.kind == LiteralKind::Punctuation));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\^\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start = parser.pos();",
            "    assert_eq!(parser.char(), '\\\\');"
          ],
          [
            "    let start = parser.pos();",
            "    assert!(parser.bump());"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c == '^');"
          ],
          [
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!("
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\^\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert_eq!(parser.char(), '\\\\');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\^\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    assert!(parser.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\^\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    assert!(c == '^');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\^\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start = parser.pos();",
            "    let c = parser.char();",
            "    let span = Span::new(start, parser.pos());",
            "    assert_eq!(",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\$\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.kind, ast::LiteralKind::Punctuation);"
          ],
          [
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.c, '$');"
          ],
          [
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    }",
            "    _ => panic!(\"Expected a Literal, found {:?}\", result),",
            "    }",
            "    assert!(parser.pos().offset > 0);"
          ],
          [
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    }",
            "    _ => panic!(\"Expected a Literal, found {:?}\", result),",
            "    }",
            "    assert!(parser.pos().line == 1);"
          ],
          [
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    }",
            "    _ => panic!(\"Expected a Literal, found {:?}\", result),",
            "    }",
            "    assert!(parser.pos().column == 3);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.kind, ast::LiteralKind::Punctuation);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.c, '$');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    }",
            "    _ => panic!(\"Expected a Literal, found {:?}\", result),",
            "    }",
            "    assert!(parser.pos().offset > 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    }",
            "    _ => panic!(\"Expected a Literal, found {:?}\", result),",
            "    }",
            "    assert!(parser.pos().line == 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\$\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    match result.unwrap() {",
            "    Primitive::Literal(lit) => {",
            "    }",
            "    _ => panic!(\"Expected a Literal, found {:?}\", result),",
            "    }",
            "    assert!(parser.pos().column == 3);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\#\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\#\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\#\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == ast::LiteralKind::Punctuation && lit.c == '#'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\#\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\#\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\#\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\#\";",
            "    let parser = ParserI { parser: Parser { octal: false, ..Default::default() }, pattern: pattern };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(lit) if lit.kind == ast::LiteralKind::Punctuation && lit.c == '#'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\&\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let start_position = Position { offset: 0, line: 1, column: 1 };",
            "    let expected_span = Span::new(start_position, Position { offset: 2, line: 1, column: 3 });",
            "    let expected_literal = ast::Literal {",
            "    span: expected_span,",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '&',",
            "    };",
            "    let expected_result = Ok(Primitive::Literal(expected_literal));",
            "    assert_eq!(parser.parse_escape(), expected_result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\&\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let start_position = Position { offset: 0, line: 1, column: 1 };",
            "    let expected_span = Span::new(start_position, Position { offset: 2, line: 1, column: 3 });",
            "    let expected_literal = ast::Literal {",
            "    span: expected_span,",
            "    kind: ast::LiteralKind::Punctuation,",
            "    c: '&',",
            "    };",
            "    let expected_result = Ok(Primitive::Literal(expected_literal));",
            "    assert_eq!(parser.parse_escape(), expected_result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\-\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.kind, ast::LiteralKind::Punctuation);"
          ],
          [
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.c, '-');"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.kind, ast::LiteralKind::Punctuation);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\-\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    match primitive {",
            "    Primitive::Literal(lit) => {",
            "    assert_eq!(lit.c, '-');",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\\\\~\";",
          "    let parser = ParserI {",
          "        parser: Parser { octal: false, ..Default::default() },",
          "        pattern: pattern,",
          "    };",
          "    parser.parse_escape();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\\\\~\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"\\\\~\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(literal) if"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\\\\~\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\~\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"\\\\~\";",
            "    let parser = ParserI {",
            "        parser: Parser { octal: false, ..Default::default() },",
            "        pattern: pattern,",
            "    };",
            "    parser.parse_escape();",
            "    let pattern = \"\\\\~\";",
            "    let parser = ParserI {",
            "    parser: Parser { octal: false, ..Default::default() },",
            "    pattern: pattern,",
            "    };",
            "    let result = parser.parse_escape();",
            "    let primitive = result.unwrap();",
            "    assert!(matches!(primitive, Primitive::Literal(literal) if",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]