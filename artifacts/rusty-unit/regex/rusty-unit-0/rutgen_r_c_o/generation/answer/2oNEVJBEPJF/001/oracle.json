[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![]);",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![]);",
            "    let result = Matcher::suffixes(&lits);",
            "    assert_eq!(result, Matcher::Empty);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![]);",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![]);",
            "    let result = Matcher::suffixes(&lits);",
            "    assert_eq!(result, Matcher::Empty);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.complete, false);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense.len(), 1);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense[0], 97);  // ASCII value for 'a'"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.sparse[97 as usize], true);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.sparse.iter().filter(|&&x| x).count(), 1);  // Only 'a' should be sparse"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.complete, false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense[0], 97);  // ASCII value for 'a'",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.sparse[97 as usize], true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97]]); // Single 'a'",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.sparse.iter().filter(|&&x| x).count(), 1);  // Only 'a' should be sparse",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.complete == false);"
          ],
          [
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.all_ascii == true);"
          ],
          [
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.dense.len() == 2);"
          ],
          [
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[97 as usize] == true);"
          ],
          [
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[98 as usize] == true);"
          ],
          [
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse.len() >= 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.complete == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.all_ascii == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.dense.len() == 2);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[97 as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[98 as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97], vec![98]]); // 'a' and 'b'",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![97], vec![98]]);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse.len() >= 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![97, 98], vec![99]]); // \"ab\" and \"c\"",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.complete == false);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.all_ascii == true);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.dense == vec![97, 98, 99]);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse.len() == 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![97, 98], vec![99]]); // \"ab\" and \"c\"",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.complete == false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97, 98], vec![99]]); // \"ab\" and \"c\"",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.all_ascii == true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97, 98], vec![99]]); // \"ab\" and \"c\"",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.dense == vec![97, 98, 99]);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![97, 98], vec![99]]); // \"ab\" and \"c\"",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse.len() == 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.complete, false);"
          ],
          [
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);"
          ],
          [
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense, vec![100, 101, 102]);"
          ],
          [
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse.len() >= 256);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.complete, false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense, vec![100, 101, 102]);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![100, 101, 102]]); // \"def\"",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse.len() >= 256);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![",
          "        vec![0], ",
          "        vec![255], ",
          "        vec![128]]); // Testing boundary byte values",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    assert!(matches!(result, Matcher::Bytes(_)));"
          ],
          [
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert_eq!(sset.complete, false);"
          ],
          [
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert_eq!(sset.all_ascii, false);"
          ],
          [
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert_eq!(sset.dense.len(), 2);"
          ],
          [
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert!(sset.sparse[0]);"
          ],
          [
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert!(sset.sparse[255 as usize]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![",
            "        vec![0], ",
            "        vec![255], ",
            "        vec![128]]); // Testing boundary byte values",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    assert!(matches!(result, Matcher::Bytes(_)));",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![",
            "        vec![0], ",
            "        vec![255], ",
            "        vec![128]]); // Testing boundary byte values",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert_eq!(sset.complete, false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![",
            "        vec![0], ",
            "        vec![255], ",
            "        vec![128]]); // Testing boundary byte values",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert_eq!(sset.all_ascii, false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![",
            "        vec![0], ",
            "        vec![255], ",
            "        vec![128]]); // Testing boundary byte values",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert_eq!(sset.dense.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![",
            "        vec![0], ",
            "        vec![255], ",
            "        vec![128]]); // Testing boundary byte values",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert!(sset.sparse[0]);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![",
            "        vec![0], ",
            "        vec![255], ",
            "        vec![128]]); // Testing boundary byte values",
            "    Matcher::suffixes(&lits);",
            "    let lits = Literals::new(vec![vec![0], vec![255], vec![128]]);",
            "    let result = Matcher::suffixes(&lits);",
            "    let sset = if let Matcher::Bytes(s) = result { s } else { panic!(\"Expected Bytes matcher\") };",
            "    assert!(sset.sparse[255 as usize]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
          "    Matcher::suffixes(&lits);",
          "}"
        ],
        "oracles": [
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.complete, false);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense.len(), 3);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[1 as usize]);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[2 as usize]);"
          ],
          [
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[3 as usize]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.complete, false);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.all_ascii, true);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert_eq!(sset.dense.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[1 as usize]);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[2 as usize]);",
            "}"
          ],
          [
            "{",
            "    let lits = Literals::new(vec![vec![1], vec![2], vec![3]]); // Testing lesser-used byte values",
            "    Matcher::suffixes(&lits);",
            "    let sset = SingleByteSet::suffixes(&lits);",
            "    assert!(sset.sparse[3 as usize]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]