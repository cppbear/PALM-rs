[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_literals = Literals {",
          "        lits: vec![",
          "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
          "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
          "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
          "            Literal::Byte(10)",
          "        ],",
          "        limit_size: 100,",
          "        limit_class: 10,",
          "    };",
          "    ",
          "    let cross_literals = Literals {",
          "        lits: vec![",
          "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
          "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
          "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
          "            Literal::Byte(20)",
          "        ],",
          "        limit_size: 100,",
          "        limit_class: 10,",
          "    };",
          "",
          "    self_literals.set_limit_size(100);",
          "    self_literals.set_limit_class(10);",
          "",
          "    self_literals.cross_product(&cross_literals);",
          "}"
        ],
        "oracles": [
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert_eq!(self_literals.lits.len(), 10);"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert_eq!(cross_literals.lits.len(), 10);"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.any_complete());"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.is_empty() == false);"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(cross_literals.is_empty() == false);"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.cross_product(&cross_literals));"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.lits.len() > 10);"
          ],
          [
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.lits.len() <= 100);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert_eq!(self_literals.lits.len(), 10);",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert_eq!(cross_literals.lits.len(), 10);",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.any_complete());",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.is_empty() == false);",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(cross_literals.is_empty() == false);",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.lits.len() > 10);",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), ",
            "            Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), ",
            "            Literal::Byte(10)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "    ",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), Literal::Byte(15), Literal::Byte(16), ",
            "            Literal::Byte(17), Literal::Byte(18), Literal::Byte(19), ",
            "            Literal::Byte(20)",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(100);",
            "    self_literals.set_limit_class(10);",
            "",
            "    self_literals.cross_product(&cross_literals);",
            "    self_literals.limit_size();",
            "    self_literals.limit_class();",
            "    self_literals.literals();",
            "    cross_literals.limit_size();",
            "    cross_literals.limit_class();",
            "    cross_literals.literals();",
            "    assert!(self_literals.lits.len() <= 100);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_literals = Literals {",
          "        lits: vec![",
          "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
          "            Literal::Byte(4), Literal::Byte(5), ",
          "        ],",
          "        limit_size: 20,",
          "        limit_class: 10,",
          "    };",
          "",
          "    let cross_literals = Literals {",
          "        lits: vec![",
          "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
          "            Literal::Byte(9), Literal::Byte(10), ",
          "            Literal::Byte(11), Literal::Byte(12), ",
          "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
          "        ],",
          "        limit_size: 100,",
          "        limit_class: 10,",
          "    };",
          "",
          "    self_literals.set_limit_size(20);",
          "    self_literals.set_limit_class(10);",
          "",
          "    assert!(self_literals.cross_product(&cross_literals));",
          "}"
        ],
        "oracles": [
          [
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.any_complete());"
          ],
          [
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(!self_literals.is_empty());"
          ],
          [
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(!cross_literals.is_empty());"
          ],
          [
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.cross_product(&cross_literals));"
          ],
          [
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.literals().len() > 5);"
          ],
          [
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.literals().iter().any(|lit| lit.is_cut() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "        ],",
            "        limit_size: 20,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10), ",
            "            Literal::Byte(11), Literal::Byte(12), ",
            "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.any_complete());",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "        ],",
            "        limit_size: 20,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10), ",
            "            Literal::Byte(11), Literal::Byte(12), ",
            "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(!self_literals.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "        ],",
            "        limit_size: 20,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10), ",
            "            Literal::Byte(11), Literal::Byte(12), ",
            "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(!cross_literals.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "        ],",
            "        limit_size: 20,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10), ",
            "            Literal::Byte(11), Literal::Byte(12), ",
            "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "        ],",
            "        limit_size: 20,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10), ",
            "            Literal::Byte(11), Literal::Byte(12), ",
            "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.literals().len() > 5);",
            "}"
          ],
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "        ],",
            "        limit_size: 20,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10), ",
            "            Literal::Byte(11), Literal::Byte(12), ",
            "            Literal::Byte(13), Literal::Byte(14), Literal::Byte(15), ",
            "        ],",
            "        limit_size: 100,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "",
            "    assert!(self_literals.cross_product(&cross_literals));",
            "    let mut self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5)], limit_size: 20, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10), Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14), Literal::Byte(15)], limit_size: 100, limit_class: 10 };",
            "    self_literals.set_limit_size(20);",
            "    self_literals.set_limit_class(10);",
            "    assert!(self_literals.literals().iter().any(|lit| lit.is_cut() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut self_literals = Literals {",
          "        lits: vec![",
          "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
          "            Literal::Byte(4), Literal::Byte(5), ",
          "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
          "            Literal::Byte(9), Literal::Byte(10),",
          "        ],",
          "        limit_size: 50,",
          "        limit_class: 10,",
          "    };",
          "",
          "    let cross_literals = Literals {",
          "        lits: vec![",
          "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
          "            Literal::Byte(14), ",
          "        ],",
          "        limit_size: 50,",
          "        limit_class: 10,",
          "    };",
          "",
          "    self_literals.set_limit_size(50);",
          "    self_literals.set_limit_class(10);",
          "    ",
          "    self_literals.cross_product(&cross_literals);",
          "}"
        ],
        "oracles": [
          [
            "    let self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10)], limit_size: 50, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14)], limit_size: 50, limit_class: 10 };",
            "    self_literals.set_limit_size(50);",
            "    self_literals.set_limit_class(10);",
            "    let result = self_literals.cross_product(&cross_literals);",
            "    assert!(result == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut self_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), ",
            "            Literal::Byte(4), Literal::Byte(5), ",
            "            Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), ",
            "            Literal::Byte(9), Literal::Byte(10),",
            "        ],",
            "        limit_size: 50,",
            "        limit_class: 10,",
            "    };",
            "",
            "    let cross_literals = Literals {",
            "        lits: vec![",
            "            Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), ",
            "            Literal::Byte(14), ",
            "        ],",
            "        limit_size: 50,",
            "        limit_class: 10,",
            "    };",
            "",
            "    self_literals.set_limit_size(50);",
            "    self_literals.set_limit_class(10);",
            "    ",
            "    self_literals.cross_product(&cross_literals);",
            "    let self_literals = Literals { lits: vec![Literal::Byte(1), Literal::Byte(2), Literal::Byte(3), Literal::Byte(4), Literal::Byte(5), Literal::Byte(6), Literal::Byte(7), Literal::Byte(8), Literal::Byte(9), Literal::Byte(10)], limit_size: 50, limit_class: 10 };",
            "    let cross_literals = Literals { lits: vec![Literal::Byte(11), Literal::Byte(12), Literal::Byte(13), Literal::Byte(14)], limit_size: 50, limit_class: 10 };",
            "    self_literals.set_limit_size(50);",
            "    self_literals.set_limit_class(10);",
            "    let result = self_literals.cross_product(&cross_literals);",
            "    assert!(result == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]