[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let index = 0; // Since there are no captures yet",
          "    let name = \"test_capture\".to_string();",
          "",
          "    let group = hir::Group {",
          "        kind: hir::GroupKind::CaptureName { index, name },",
          "        hir: Hir::empty(), // Assuming the existence of some empty Hir struct",
          "    };",
          "",
          "    let expr = Hir::from_group(group);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.compiled.captures.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.compiled.captures[0].is_some());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.capture_name_idx.get(\"test_capture\"), Some(&0));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.entry, 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(matches!(patch.hole, Hole::None));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let index = 0; // Since there are no captures yet",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(), // Assuming the existence of some empty Hir struct",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.compiled.captures.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let index = 0; // Since there are no captures yet",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(), // Assuming the existence of some empty Hir struct",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.compiled.captures[0].is_some());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let index = 0; // Since there are no captures yet",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(), // Assuming the existence of some empty Hir struct",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.capture_name_idx.get(\"test_capture\"), Some(&0));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let index = 0; // Since there are no captures yet",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(), // Assuming the existence of some empty Hir struct",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.entry, 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let index = 0; // Since there are no captures yet",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(), // Assuming the existence of some empty Hir struct",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    let index = 0;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty() };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(matches!(patch.hole, Hole::None));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
          "    let index = 1; // One existing capture",
          "    let name = \"test_capture\".to_string();",
          "",
          "    let group = hir::Group {",
          "        kind: hir::GroupKind::CaptureName { index, name },",
          "        hir: Hir::empty(),",
          "    };",
          "",
          "    let expr = Hir::from_group(group);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.compiled.captures.len(), 2);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.compiled.captures[1], Some(\"test_capture\".to_string()));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.capture_name_idx.contains_key(\"test_capture\"));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(*compiler.capture_name_idx.get(\"test_capture\").unwrap(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1; // One existing capture",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.compiled.captures.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1; // One existing capture",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(compiler.compiled.captures[1], Some(\"test_capture\".to_string()));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1; // One existing capture",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.capture_name_idx.contains_key(\"test_capture\"));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1; // One existing capture",
            "    let name = \"test_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(\"existing_capture\".to_string()));",
            "    let index = 1;",
            "    let name = \"test_capture\".to_string();",
            "    let group = hir::Group { kind: hir::GroupKind::CaptureName { index, name }, hir: Hir::empty(), };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(*compiler.capture_name_idx.get(\"test_capture\").unwrap(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    for i in 0..3 {",
          "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
          "    }",
          "    let index = 3; // index equals current captures length",
          "    let name = \"new_capture\".to_string();",
          "",
          "    let group = hir::Group {",
          "        kind: hir::GroupKind::CaptureName { index, name },",
          "        hir: Hir::empty(),",
          "    };",
          "",
          "    let expr = Hir::from_group(group);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(format!(\"capture_0\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_1\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_2\")));",
            "    assert_eq!(compiler.compiled.captures.len(), 3);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(format!(\"capture_0\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_1\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_2\")));",
            "    let index = 3;",
            "    let name = \"new_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.entry, 3);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(format!(\"capture_0\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_1\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_2\")));",
            "    let index = 3;",
            "    let name = \"new_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(patch.hole == Hole::None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..3 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 3; // index equals current captures length",
            "    let name = \"new_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(format!(\"capture_0\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_1\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_2\")));",
            "    assert_eq!(compiler.compiled.captures.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..3 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 3; // index equals current captures length",
            "    let name = \"new_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(format!(\"capture_0\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_1\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_2\")));",
            "    let index = 3;",
            "    let name = \"new_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.entry, 3);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..3 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 3; // index equals current captures length",
            "    let name = \"new_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.compiled.captures.push(Some(format!(\"capture_0\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_1\")));",
            "    compiler.compiled.captures.push(Some(format!(\"capture_2\")));",
            "    let index = 3;",
            "    let name = \"new_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(patch.hole == Hole::None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    for i in 0..10 {",
          "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
          "    }",
          "    let index = 10; // index equals current captures length",
          "    let name = \"another_capture\".to_string();",
          "",
          "    let group = hir::Group {",
          "        kind: hir::GroupKind::CaptureName { index, name },",
          "        hir: Hir::empty(),",
          "    };",
          "",
          "    let expr = Hir::from_group(group);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    assert_eq!(compiler.compiled.captures.len(), 10);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    let index = 10;",
            "    let name = \"another_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    let index = 10;",
            "    let name = \"another_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(patch.hole != Hole::None);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    let index = 10;",
            "    let name = \"another_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.compiled.captures.len() > 10);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..10 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 10; // index equals current captures length",
            "    let name = \"another_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    assert_eq!(compiler.compiled.captures.len(), 10);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..10 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 10; // index equals current captures length",
            "    let name = \"another_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    let index = 10;",
            "    let name = \"another_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..10 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 10; // index equals current captures length",
            "    let name = \"another_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    let index = 10;",
            "    let name = \"another_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(patch.hole != Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for i in 0..10 {",
            "        compiler.compiled.captures.push(Some(format!(\"capture_{}\", i)));",
            "    }",
            "    let index = 10; // index equals current captures length",
            "    let name = \"another_capture\".to_string();",
            "",
            "    let group = hir::Group {",
            "        kind: hir::GroupKind::CaptureName { index, name },",
            "        hir: Hir::empty(),",
            "    };",
            "",
            "    let expr = Hir::from_group(group);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new();",
            "    compiler.size_limit(100);",
            "    let index = 10;",
            "    let name = \"another_capture\".to_string();",
            "    let group = hir::Group {",
            "    kind: hir::GroupKind::CaptureName { index, name },",
            "    hir: Hir::empty(),",
            "    };",
            "    let expr = Hir::from_group(group);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.compiled.captures.len() > 10);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]