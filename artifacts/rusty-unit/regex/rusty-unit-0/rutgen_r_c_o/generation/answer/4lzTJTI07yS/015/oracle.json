[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::EndLine);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.insts.len(), expected_length_after_compilation);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(compiler.compiled.has_unicode_word_boundary == false);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(compiler.byte_classes.0[b'\\n' as usize] == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.insts.len(), expected_length_after_compilation);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(compiler.compiled.has_unicode_word_boundary == false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(compiler.byte_classes.0[b'\\n' as usize] == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::StartLine);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, 0);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    assert!(result_end_line.is_ok());"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    assert_eq!(patch_end_line.entry, 1);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    assert_eq!(patch_end_line.hole, Hole::None);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    assert!(result_start_text.is_ok());"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    assert_eq!(patch_start_text.entry, 2);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    assert_eq!(patch_start_text.hole, Hole::None);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    let expr_end_text = Hir::new(hir::Anchor::EndText);",
            "    let result_end_text = compiler.c(&expr_end_text);",
            "    assert!(result_end_text.is_ok());"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    let expr_end_text = Hir::new(hir::Anchor::EndText);",
            "    let result_end_text = compiler.c(&expr_end_text);",
            "    let patch_end_text = result_end_text.unwrap();",
            "    assert_eq!(patch_end_text.entry, 3);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    let expr_end_text = Hir::new(hir::Anchor::EndText);",
            "    let result_end_text = compiler.c(&expr_end_text);",
            "    let patch_end_text = result_end_text.unwrap();",
            "    assert_eq!(patch_end_text.hole, Hole::None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    assert!(result_end_line.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    assert_eq!(patch_end_line.entry, 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    assert_eq!(patch_end_line.hole, Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    assert!(result_start_text.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    assert_eq!(patch_start_text.entry, 2);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    assert_eq!(patch_start_text.hole, Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    let expr_end_text = Hir::new(hir::Anchor::EndText);",
            "    let result_end_text = compiler.c(&expr_end_text);",
            "    assert!(result_end_text.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    let expr_end_text = Hir::new(hir::Anchor::EndText);",
            "    let result_end_text = compiler.c(&expr_end_text);",
            "    let patch_end_text = result_end_text.unwrap();",
            "    assert_eq!(patch_end_text.entry, 3);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    let expr_end_line = Hir::new(hir::Anchor::EndLine);",
            "    let result_end_line = compiler.c(&expr_end_line);",
            "    let patch_end_line = result_end_line.unwrap();",
            "    let expr_start_text = Hir::new(hir::Anchor::StartText);",
            "    let result_start_text = compiler.c(&expr_start_text);",
            "    let patch_start_text = result_start_text.unwrap();",
            "    let expr_end_text = Hir::new(hir::Anchor::EndText);",
            "    let result_end_text = compiler.c(&expr_end_text);",
            "    let patch_end_text = result_end_text.unwrap();",
            "    assert_eq!(patch_end_text.hole, Hole::None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::StartText);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len() - 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::EndText);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.compiled.has_unicode_word_boundary, false);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.compiled.is_reverse, true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.compiled.has_unicode_word_boundary, false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(10 * (1 << 20)).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.compiled.is_reverse, true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::EndLine);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(result.unwrap().entry, compiler.insts.len() - 1);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.compiled.is_reverse, true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(result.unwrap().entry, compiler.insts.len() - 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndLine);",
            "    let result = compiler.c(&expr);",
            "    assert_eq!(compiler.compiled.is_reverse, true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::StartLine);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert!(compiler.c(&expr).is_ok());"
          ],
          [
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert!(compiler.compiled.is_reverse);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert_eq!(compiler.insts.len(), initial_len + 1);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert_eq!(compiler.compiled.byte_classes[0], expected_byte_class_value);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert_eq!(compiler.compiled.captures.len(), initial_capture_length);"
          ],
          [
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert!(compiler.check_size().is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert!(compiler.c(&expr).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert!(compiler.compiled.is_reverse);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert_eq!(compiler.insts.len(), initial_len + 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert_eq!(compiler.compiled.byte_classes[0], expected_byte_class_value);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert_eq!(compiler.compiled.captures.len(), initial_capture_length);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    let _ = compiler.c(&expr);",
            "    let compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartLine);",
            "    assert!(compiler.check_size().is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::StartText);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len());"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.entry, compiler.insts.len());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::StartText);",
            "    let result = compiler.c(&expr);",
            "    let patch = result.unwrap();",
            "    assert_eq!(patch.hole, Hole::None);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
          "    let expr = Hir::new(hir::Anchor::EndText);",
          "    let _ = compiler.c(&expr);",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.hole, Hole::None);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(patch.entry >= 0);"
          ],
          [
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.insts.len() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert_eq!(patch.hole, Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(patch.entry >= 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let _ = compiler.c(&expr);",
            "    let mut compiler = Compiler::new().size_limit(1).reverse(true);",
            "    let expr = Hir::new(hir::Anchor::EndText);",
            "    let patch = compiler.c(&expr).unwrap();",
            "    assert!(compiler.insts.len() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]