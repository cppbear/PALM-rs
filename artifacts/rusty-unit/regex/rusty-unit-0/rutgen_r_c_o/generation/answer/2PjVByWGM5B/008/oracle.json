[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals {",
          "        lits: vec![Literal::Byte(97)], // base is not empty",
          "        limit_size: 1024,",
          "        limit_class: 65535,",
          "    };",
          "    ",
          "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
          "    let class_unicode = ClassUnicode::new(vec![range]);",
          "",
          "    assert!(literals._add_char_class(&class_unicode, false)); ",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(!literals.class_exceeds_limits(cls_char_count(&class_unicode)));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(!literals.is_empty());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(class_unicode.iter().next().is_some());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(char::from_u32('a' as u32).is_some());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(char::from_u32('b' as u32).is_some());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(char::from_u32('c' as u32).is_some());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert_eq!(literals.lits.len(), 1);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(literals._add_char_class(&class_unicode, false));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert_eq!(literals.lits.len(), 4);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(!literals.class_exceeds_limits(cls_char_count(&class_unicode)));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(!literals.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(class_unicode.iter().next().is_some());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(char::from_u32('a' as u32).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(char::from_u32('b' as u32).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(char::from_u32('c' as u32).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert_eq!(literals.lits.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert!(literals._add_char_class(&class_unicode, false));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.remove_complete();",
            "    assert_eq!(literals.lits.len(), 4);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals {",
          "        lits: vec![Literal::Byte(97)], // base is not empty",
          "        limit_size: 1024,",
          "        limit_class: 65535,",
          "    };",
          "    ",
          "    let class_unicode = ClassUnicode::empty();",
          "",
          "    assert!(literals._add_char_class(&class_unicode, false)); ",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert_eq!(literals.lits.len(), 1);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert_eq!(literals.limit_size(), 1024);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert_eq!(literals.limit_class(), 65535);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals.lits[0].is_cut() == false);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals._add_char_class(&class_unicode, false));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals.lits.len() > 1);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals.lits.iter().all(|lit| lit.is_cut() == false));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert_eq!(literals.lits.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert_eq!(literals.limit_size(), 1024);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert_eq!(literals.limit_class(), 65535);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals.lits[0].is_cut() == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals._add_char_class(&class_unicode, false));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals.lits.len() > 1);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(97)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let class_unicode = ClassUnicode::empty();",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(97)], limit_size: 1024, limit_class: 65535 };",
            "    let class_unicode = ClassUnicode::empty();",
            "    assert!(literals.lits.iter().all(|lit| lit.is_cut() == false));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals {",
          "        lits: vec![Literal::Byte(98)], // base is not empty",
          "        limit_size: 1024,",
          "        limit_class: 65535,",
          "    };",
          "    ",
          "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
          "    let class_unicode = ClassUnicode::new(vec![range]);",
          "",
          "    assert!(literals._add_char_class(&class_unicode, false)); ",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals._add_char_class(&class_unicode, false));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits.len(), 3);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[0], Literal::Byte(98));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[1], Literal::Unicode('A'));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[2], Literal::Unicode('B'));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[3], Literal::Unicode('C'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(98)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals._add_char_class(&class_unicode, false));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(98)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(98)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[0], Literal::Byte(98));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(98)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[1], Literal::Unicode('A'));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(98)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[2], Literal::Unicode('B'));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(98)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' }; // valid range with uppercase letters",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(98)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'A', end: 'C' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[3], Literal::Unicode('C'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals {",
          "        lits: vec![Literal::Byte(99)], // base is not empty",
          "        limit_size: 1024,",
          "        limit_class: 65535,",
          "    };",
          "    ",
          "    let ranges = vec![",
          "        ClassUnicodeRange { start: 'd', end: 'f' },",
          "        ClassUnicodeRange { start: 'g', end: 'j' },",
          "    ];",
          "    let class_unicode = ClassUnicode::new(ranges);",
          "",
          "    assert!(literals._add_char_class(&class_unicode, false)); ",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals.class_exceeds_limits(cls_char_count(&class_unicode)) == false);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals.remove_complete().is_empty() == false);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(class_unicode.iter().count() > 0);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(char::from_u32(b'd' as u32).is_some());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(char::from_u32(b'f' as u32).is_some());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals.lits.len() > 0);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals._add_char_class(&class_unicode, false));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals.class_exceeds_limits(cls_char_count(&class_unicode)) == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals.remove_complete().is_empty() == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(class_unicode.iter().count() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(char::from_u32(b'd' as u32).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(char::from_u32(b'f' as u32).is_some());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals.lits.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(99)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let ranges = vec![",
            "        ClassUnicodeRange { start: 'd', end: 'f' },",
            "        ClassUnicodeRange { start: 'g', end: 'j' },",
            "    ];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(99)], limit_size: 1024, limit_class: 65535 };",
            "    let ranges = vec![ClassUnicodeRange { start: 'd', end: 'f' }, ClassUnicodeRange { start: 'g', end: 'j' }];",
            "    let class_unicode = ClassUnicode::new(ranges);",
            "    assert!(literals._add_char_class(&class_unicode, false));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals {",
          "        lits: vec![Literal::Byte(100)], // base is not empty",
          "        limit_size: 1024,",
          "        limit_class: 65535,",
          "    };",
          "    ",
          "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
          "    let class_unicode = ClassUnicode::new(vec![range]);",
          "",
          "    assert!(literals._add_char_class(&class_unicode, false)); ",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals._add_char_class(&class_unicode, false));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits.len(), 2);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[1], Literal::Unicode('x'));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[2], Literal::Unicode('y'));"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals.class_exceeds_limits(cls_char_count(&class_unicode)) == false);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals.remove_complete().is_empty() == false);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals.lits[0].is_cut() == false);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.clear();",
            "    assert!(literals.is_empty());"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.clear();",
            "    literals.set_limit_size(2048);",
            "    assert_eq!(literals.limit_size(), 2048);"
          ],
          [
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.clear();",
            "    literals.set_limit_size(2048);",
            "    literals.set_limit_class(100000);",
            "    assert_eq!(literals.limit_class(), 100000);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals._add_char_class(&class_unicode, false));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits.len(), 2);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[1], Literal::Unicode('x'));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.lits[2], Literal::Unicode('y'));",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals.class_exceeds_limits(cls_char_count(&class_unicode)) == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals.remove_complete().is_empty() == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(literals.lits[0].is_cut() == false);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.clear();",
            "    assert!(literals.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.clear();",
            "    literals.set_limit_size(2048);",
            "    assert_eq!(literals.limit_size(), 2048);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![Literal::Byte(100)], // base is not empty",
            "        limit_size: 1024,",
            "        limit_class: 65535,",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![Literal::Byte(100)], limit_size: 1024, limit_class: 65535 };",
            "    let range = ClassUnicodeRange { start: 'x', end: 'y' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    literals.clear();",
            "    literals.set_limit_size(2048);",
            "    literals.set_limit_class(100000);",
            "    assert_eq!(literals.limit_class(), 100000);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut literals = Literals {",
          "        lits: vec![], // base is empty",
          "        limit_size: 1024,",
          "        limit_class: 1, // intentionally low to exceed limit",
          "    };",
          "    ",
          "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
          "    let class_unicode = ClassUnicode::new(vec![range]);",
          "",
          "    assert!(!literals._add_char_class(&class_unicode, false)); ",
          "}"
        ],
        "oracles": [
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.class_exceeds_limits(cls_char_count(&class_unicode)), true);"
          ],
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.remove_complete().is_empty(), true);"
          ],
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.iter().next().is_some(), true);"
          ],
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.ranges().len(), 1);"
          ],
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.ranges()[0].start, 'a');"
          ],
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.ranges()[0].end, 'c');"
          ],
          [
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(!literals._add_char_class(&class_unicode, false));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.class_exceeds_limits(cls_char_count(&class_unicode)), true);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(literals.remove_complete().is_empty(), true);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.iter().next().is_some(), true);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.ranges().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.ranges()[0].start, 'a');",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert_eq!(class_unicode.ranges()[0].end, 'c');",
            "}"
          ],
          [
            "{",
            "    let mut literals = Literals {",
            "        lits: vec![], // base is empty",
            "        limit_size: 1024,",
            "        limit_class: 1, // intentionally low to exceed limit",
            "    };",
            "    ",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' }; // valid range",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "",
            "    assert!(!literals._add_char_class(&class_unicode, false)); ",
            "    let mut literals = Literals { lits: vec![], limit_size: 1024, limit_class: 1 };",
            "    let range = ClassUnicodeRange { start: 'a', end: 'c' };",
            "    let class_unicode = ClassUnicode::new(vec![range]);",
            "    assert!(!literals._add_char_class(&class_unicode, false));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]