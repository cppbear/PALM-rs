[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \"\";",
          "    let ast = Ast::Empty(Span::new(0, 0));",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"\";",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"\";",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Empty);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"\";",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"\";",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"\";",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"\";",
            "    let ast = Ast::Empty(Span::new(0, 0));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Empty);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \"a\";",
          "    let ast = Ast::Literal(Literal::new('a'));",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.kind, HirKind::Literal);"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.info.span, ast.span());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.kind, HirKind::Literal);",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a\";",
            "    let ast = Ast::Literal(Literal::new('a'));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.info.span, ast.span());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \"abc\";",
          "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.kind, HirKind::Class);"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.info.some_property, expected_value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.kind, HirKind::Class);",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"abc\";",
            "    let ast = Ast::Class(Class::new(vec!['a', 'b', 'c']));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.info.some_property, expected_value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \".*\";",
          "    let ast = Ast::Dot(Span::new(0, 1));",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Dot);"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().info, expected_info);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Dot);",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \".*\";",
            "    let ast = Ast::Dot(Span::new(0, 1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().info, expected_info);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \"(?i)[A-Z]\";",
          "    let ast = Ast::Assertion(Assertion::new());",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"(?i)[A-Z]\";",
            "    let ast = Ast::Assertion(Assertion::new());",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"(?i)[A-Z]\";",
            "    let ast = Ast::Assertion(Assertion::new());",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Assertion);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"(?i)[A-Z]\";",
            "    let ast = Ast::Assertion(Assertion::new());",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"(?i)[A-Z]\";",
            "    let ast = Ast::Assertion(Assertion::new());",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"(?i)[A-Z]\";",
            "    let ast = Ast::Assertion(Assertion::new());",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"(?i)[A-Z]\";",
            "    let ast = Ast::Assertion(Assertion::new());",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Assertion);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \"a|b\";",
          "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.kind, HirKind::Group);"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.info.pattern, pattern);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.kind, HirKind::Group);",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"a|b\";",
            "    let ast = Ast::Group(Group::new(vec![Ast::Literal(Literal::new('a'))]));",
            "    let result = translator.translate(pattern, &ast);",
            "    let hir = result.unwrap();",
            "    assert_eq!(hir.info.pattern, pattern);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut translator = Translator::new();",
          "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
          "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
          "    translator.translate(pattern, &ast);",
          "}"
        ],
        "oracles": [
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
            "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut translator = Translator::new();",
            "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
            "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Repetition);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
            "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
            "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut translator = Translator::new();",
            "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
            "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
            "    translator.translate(pattern, &ast);",
            "    let mut translator = Translator::new();",
            "    let pattern = \"((?<=\\\\d)(?=\\\\D))\";",
            "    let ast = Ast::Repetition(Repetition::new(Ast::Literal(Literal::new('a')), 0..1));",
            "    let result = translator.translate(pattern, &ast);",
            "    assert_eq!(result.unwrap().kind, HirKind::Repetition);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]