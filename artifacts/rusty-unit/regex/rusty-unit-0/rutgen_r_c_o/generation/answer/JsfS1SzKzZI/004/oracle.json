[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ast::ClassBracketed { ",
          "        span: Span::new(0, 10), ",
          "        negated: false, ",
          "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "            span: Span::new(0, 5), ",
          "            negated: false, ",
          "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
          "        }))) ",
          "    };",
          "    let mut visitor = MyVisitor::new();",
          "    let mut heap_visitor = HeapVisitor::new();",
          "    ",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.induct_class(&ast).is_some());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.pop_class(frame).is_some());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.stack_class.pop().is_none());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.stack_class.pop().is_none());"
          ],
          [
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.induct_class(&ast).is_some());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.pop_class(frame).is_some());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.stack_class.pop().is_none());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert!(heap_visitor.stack_class.pop().is_none());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 10), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "            span: Span::new(0, 5), ",
            "            negated: false, ",
            "            kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a')) ",
            "        }))) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    ",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed {",
            "    span: Span::new(0, 10),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "    span: Span::new(0, 5),",
            "    negated: false,",
            "    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))",
            "    })))",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().expect(\"Expected Some((post_ast, frame))\");",
            "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ast::ClassBracketed { ",
          "        span: Span::new(0, 15), ",
          "        negated: false, ",
          "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
          "            items: vec![",
          "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "                    span: Span::new(0, 5), ",
          "                    negated: false, ",
          "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
          "                })),",
          "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
          "                    span: Span::new(5, 10), ",
          "                    negated: false, ",
          "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
          "                })),",
          "            ]",
          "        }) ",
          "    };",
          "    let mut visitor = MyVisitor::new();",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let x = heap_visitor.induct_class(&ast).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((ast, x));",
            "    ast = child;",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
            "    let x = heap_visitor.pop_class(frame).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((post_ast, x));",
            "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
            "    assert_eq!(heap_visitor.stack_class.pop(), None);"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let x = heap_visitor.induct_class(&ast).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((ast, x));",
            "    ast = child;",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
            "    let x = heap_visitor.pop_class(frame).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((post_ast, x));",
            "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
            "    assert_eq!(heap_visitor.stack_class.pop(), None);"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let x = heap_visitor.induct_class(&ast).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((ast, x));",
            "    ast = child;",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
            "    let x = heap_visitor.pop_class(frame).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((post_ast, x));",
            "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
            "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 15), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
            "            items: vec![",
            "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "                    span: Span::new(0, 5), ",
            "                    negated: false, ",
            "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
            "                })),",
            "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "                    span: Span::new(5, 10), ",
            "                    negated: false, ",
            "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
            "                })),",
            "            ]",
            "        }) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let x = heap_visitor.induct_class(&ast).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((ast, x));",
            "    ast = child;",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
            "    let x = heap_visitor.pop_class(frame).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((post_ast, x));",
            "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
            "    assert_eq!(heap_visitor.stack_class.pop(), None);",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 15), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
            "            items: vec![",
            "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "                    span: Span::new(0, 5), ",
            "                    negated: false, ",
            "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
            "                })),",
            "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "                    span: Span::new(5, 10), ",
            "                    negated: false, ",
            "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
            "                })),",
            "            ]",
            "        }) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let x = heap_visitor.induct_class(&ast).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((ast, x));",
            "    ast = child;",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
            "    let x = heap_visitor.pop_class(frame).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((post_ast, x));",
            "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
            "    assert_eq!(heap_visitor.stack_class.pop(), None);",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed { ",
            "        span: Span::new(0, 15), ",
            "        negated: false, ",
            "        kind: ast::ClassSet::Union(ast::ClassSetUnion { ",
            "            items: vec![",
            "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "                    span: Span::new(0, 5), ",
            "                    negated: false, ",
            "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) ",
            "                })),",
            "                ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
            "                    span: Span::new(5, 10), ",
            "                    negated: false, ",
            "                    kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c'))",
            "                })),",
            "            ]",
            "        }) ",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 15), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('b')) })), ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span::new(5, 10), negated: false, kind: ast::ClassSet::Item(ast::ClassSetItem::Literal('c')) }))] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let x = heap_visitor.induct_class(&ast).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((ast, x));",
            "    ast = child;",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let (post_ast, frame) = heap_visitor.stack_class.pop().unwrap();",
            "    let x = heap_visitor.pop_class(frame).unwrap();",
            "    let child = x.child();",
            "    heap_visitor.stack_class.push((post_ast, x));",
            "    heap_visitor.visit_class_post(&post_ast, &mut visitor).unwrap();",
            "    assert!(heap_visitor.visit_class(&ast, &mut visitor).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ast::ClassBracketed {",
          "        span: Span::new(0, 20),",
          "        negated: false,",
          "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
          "            span: Span::new(0, 10),",
          "            kind: ast::ClassSetBinaryOpKind::Union,",
          "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
          "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
          "        })),",
          "    };",
          "    let mut visitor = MyVisitor::new();",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.induct_class(&ast).is_some());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.stack_class.pop().is_some());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.pop_class(frame).is_some());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.stack_class.pop().is_none());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.stack_class.pop().is_none());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor).unwrap(), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_pre(&ast, &mut visitor).is_ok());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.induct_class(&ast).is_some());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_post(&ast, &mut visitor).is_ok());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.stack_class.pop().is_some());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.pop_class(frame).is_some());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.visit_class_post(&post_ast, &mut visitor).is_ok());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.stack_class.pop().is_none());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert!(heap_visitor.stack_class.pop().is_none());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 20),",
            "        negated: false,",
            "        kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp {",
            "            span: Span::new(0, 10),",
            "            kind: ast::ClassSetBinaryOpKind::Union,",
            "            lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))),",
            "            rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))),",
            "        })),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 20), negated: false, kind: ast::ClassSet::BinaryOp(Box::new(ast::ClassSetBinaryOp { span: Span::new(0, 10), kind: ast::ClassSetBinaryOpKind::Union, lhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('a'))), rhs: Box::new(ast::ClassSet::Item(ast::ClassSetItem::Literal('d'))), })); } };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor).unwrap(), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let ast = ast::ClassBracketed {",
          "        span: Span::new(0, 5),",
          "        negated: false,",
          "        kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),",
          "    };",
          "    let mut visitor = MyVisitor::new();",
          "    let mut heap_visitor = HeapVisitor::new();",
          "",
          "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
            "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
            "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
            "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
            "    assert!(stack_class_empty_pop.is_none());"
          ],
          [
            "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
            "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
            "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
            "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
            "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 5),",
            "        negated: false,",
            "        kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
            "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
            "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
            "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
            "    assert!(stack_class_empty_pop.is_none());",
            "}"
          ],
          [
            "{",
            "    let ast = ast::ClassBracketed {",
            "        span: Span::new(0, 5),",
            "        negated: false,",
            "        kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }),",
            "    };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "",
            "    heap_visitor.visit_class(&ast, &mut visitor).unwrap();",
            "    let ast = ast::ClassBracketed { span: Span::new(0, 5), negated: false, kind: ast::ClassSet::Union(ast::ClassSetUnion { items: vec![] }) };",
            "    let mut visitor = MyVisitor::new();",
            "    let mut heap_visitor = HeapVisitor::new();",
            "    heap_visitor.visit_class_pre(&ast, &mut visitor).unwrap();",
            "    let induct_class_result = heap_visitor.induct_class(&ClassInduct::from_bracketed(&ast)).unwrap();",
            "    heap_visitor.visit_class_post(&ast, &mut visitor).unwrap();",
            "    let stack_class_pop = heap_visitor.stack_class.pop().unwrap();",
            "    let pop_class_result = heap_visitor.pop_class(stack_class_pop.1).unwrap();",
            "    heap_visitor.visit_class_post(&pop_class_result.child(), &mut visitor).unwrap();",
            "    let stack_class_empty_pop = heap_visitor.stack_class.pop();",
            "    assert_eq!(heap_visitor.visit_class(&ast, &mut visitor), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]