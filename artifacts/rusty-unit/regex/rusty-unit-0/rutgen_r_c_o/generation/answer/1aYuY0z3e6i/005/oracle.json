[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
          "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
          "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts.len() > 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.suffix_cache.version == 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[1] == false);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[2] == false);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[3] == false);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[4] == false);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts.len() >= 2);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts[0].is_compiled() == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts[1].is_compiled() == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.size_limit == 10 * (1 << 20));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compile_class.compile().is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compile_class.ranges.is_empty());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.suffix_cache.table.len() == 1000);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.num_exprs == 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.suffix_cache.version == 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[1] == false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[2] == false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[3] == false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.byte_classes.0[4] == false);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts.len() >= 2);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts[0].is_compiled() == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.insts[1].is_compiled() == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.size_limit == 10 * (1 << 20));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compile_class.compile().is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compile_class.ranges.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.suffix_cache.table.len() == 1000);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }, Utf8Range { start: 3, end: 4 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    assert!(compiler.num_exprs == 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
          "    ",
          "    // Prime the cache",
          "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
          "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
          "        key: key,",
          "        pc: 0,",
          "        version: 0,",
          "    });",
          "",
          "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
          "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert_eq!(compiler.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(matches!(compiler.insts[0], MaybeInst::Uncompiled(InstHole::Bytes { start: 5, end: 6 })));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.suffix_cache.table.iter().any(|entry| entry.key == key && entry.pc == 0));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[5 as usize] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[6 as usize] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[4 as usize] == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert_eq!(compiler.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(matches!(compiler.insts[0], MaybeInst::Uncompiled(InstHole::Bytes { start: 5, end: 6 })));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.suffix_cache.table.iter().any(|entry| entry.key == key && entry.pc == 0));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[5 as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[6 as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    ",
            "    // Prime the cache",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry {",
            "        key: key,",
            "        pc: 0,",
            "        version: 0,",
            "    });",
            "",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 5, end: 6 }];",
            "    let key = SuffixCacheKey { from_inst: ::std::usize::MAX, start: 5, end: 6 };",
            "    compiler.suffix_cache.table.push(SuffixCacheEntry { key: key, pc: 0, version: 0 });",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[4 as usize] == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let byte_range: Vec<Utf8Range> = vec![];",
          "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
          "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
          "    assert!(result.is_ok());",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 1, end: 100 }, Utf8Range { start: 200, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 1, end: 100 }, Utf8Range { start: 200, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 1 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 1, end: 100 }, Utf8Range { start: 200, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 1 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 5, end: 10 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 1, end: 100 }, Utf8Range { start: 200, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 1, end: 100 }, Utf8Range { start: 200, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 1 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 1, end: 100 }, Utf8Range { start: 200, end: 255 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 0, end: 1 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    let mut compiler = Compiler::new();",
            "    let byte_range: Vec<Utf8Range> = vec![Utf8Range { start: 5, end: 10 }];",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let byte_range = vec![Utf8Range { start: 1, end: 2 }];",
          "    ",
          "    // Set insts length to be at max",
          "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
          "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
          "    ",
          "    // This should panic, from_inst would be max and can't decrement",
          "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }];",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }];",
            "    ",
            "    // Set insts length to be at max",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    ",
            "    // This should panic, from_inst would be max and can't decrement",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 1, end: 2 }];",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
          "    ",
          "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
          "    compiler.push_compiled(Inst::Match(0));",
          "    ",
          "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
          "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.insts.len() > 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.suffix_cache.version == 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[7 as usize] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[8 as usize] == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.insts.len() > 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.suffix_cache.version == 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[7 as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_range.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_range = vec![Utf8Range { start: 7, end: 8 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_range.iter());",
            "    assert!(compiler.byte_classes.0[8 as usize] == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
          "    ",
          "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
          "    compiler.push_compiled(Inst::Match(0));",
          "    ",
          "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
          "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(patch.hole == Hole::None || patch.hole != Hole::None);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(patch.entry < ::std::usize::MAX);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.insts.len() > 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.insts.len() >= 2);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.suffix_cache.version == 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.byte_classes.0[10 as usize] == true);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.byte_classes.0[15 as usize] == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(patch.hole == Hole::None || patch.hole != Hole::None);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(patch.entry < ::std::usize::MAX);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.insts.len() > 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.insts.len() >= 2);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.suffix_cache.version == 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.byte_classes.0[10 as usize] == true);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    ",
            "    // Push a compiled instruction to ensure from_inst is not usize::MAX",
            "    compiler.push_compiled(Inst::Match(0));",
            "    ",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    compile_class.c_utf8_seq_(&byte_ranges.iter()).unwrap();",
            "    let mut compiler = Compiler::new();",
            "    let byte_ranges = vec![Utf8Range { start: 10, end: 15 }, Utf8Range { start: 20, end: 25 }];",
            "    compiler.push_compiled(Inst::Match(0));",
            "    let mut compile_class = CompileClass { c: &mut compiler, ranges: &[] };",
            "    let result = compile_class.c_utf8_seq_(&byte_ranges.iter());",
            "    let patch = result.unwrap();",
            "    assert!(compiler.byte_classes.0[15 as usize] == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]