[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
          "    compiler.size_limit(10);",
          "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
          "    compiler.byte_classes.set_range(0, 255);",
          "    compiler.compile_finish();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    assert_eq!(compiler.insts.len(), 0);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    assert_eq!(compiler.size_limit, 10 * (1 << 20));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    assert!(compiler.capture_name_idx.is_empty());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    assert_eq!(compiler.byte_classes.0, [false; 256]);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    assert_eq!(compiler.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    assert_eq!(compiler.size_limit, 10);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    assert_eq!(compiler.capture_name_idx.get(\"test\"), Some(&0));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    assert!(!compiler.byte_classes.0.iter().all(|&b| !b));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.capture_name_idx.get(\"test\"), Some(&0));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    assert_eq!(compiler.insts.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    assert_eq!(compiler.size_limit, 10 * (1 << 20));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    assert!(compiler.capture_name_idx.is_empty());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    assert_eq!(compiler.byte_classes.0, [false; 256]);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    assert_eq!(compiler.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    assert_eq!(compiler.size_limit, 10);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    assert_eq!(compiler.capture_name_idx.get(\"test\"), Some(&0));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    assert!(!compiler.byte_classes.0.iter().all(|&b| !b));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.capture_name_idx.get(\"test\"), Some(&0));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    for _ in 0..1000 {",
          "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
          "    }",
          "    compiler.size_limit(10485760);",
          "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
          "    compiler.byte_classes.set_range(0, 255);",
          "    compiler.compile_finish();",
          "}"
        ],
        "oracles": [
          [
            "    let compiler = Compiler::new();",
            "    assert_eq!(compiler.insts.len(), 0);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert_eq!(compiler.insts.len(), 1000);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert_eq!(compiler.size_limit, 10485760);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert!(compiler.capture_name_idx.contains_key(\"test\"));"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert_eq!(compiler.byte_classes.byte_classes().len(), 256);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1000);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(program.capture_name_idx.contains_key(\"test\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    assert_eq!(compiler.insts.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert_eq!(compiler.insts.len(), 1000);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert_eq!(compiler.size_limit, 10485760);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert!(compiler.capture_name_idx.contains_key(\"test\"));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    assert_eq!(compiler.byte_classes.byte_classes().len(), 256);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1000);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "        compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    compiler.size_limit(10485760);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    let mut compiler = Compiler::new();",
            "    for _ in 0..1000 {",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(1)));",
            "    }",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(program.capture_name_idx.contains_key(\"test\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
          "    compiler.size_limit(0);",
          "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
          "    compiler.byte_classes.set_range(0, 255);",
          "    compiler.compile_finish();",
          "}"
        ],
        "oracles": [
          [
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    assert!(compiler.compile_finish().is_ok());"
          ],
          [
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert_eq!(program.insts.len(), 1);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert_eq!(program.captures.len(), 1);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert_eq!(program.capture_name_idx.get(\"test\"), Some(&0));"
          ],
          [
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert!(program.is_bytes);"
          ],
          [
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert!(program.byte_classes.len() > 0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    assert!(compiler.compile_finish().is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert_eq!(program.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert_eq!(program.captures.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert_eq!(program.capture_name_idx.get(\"test\"), Some(&0));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert!(program.is_bytes);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(0);",
            "    compiler.capture_name_idx.insert(\"test\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let program = compiler.compile_finish().unwrap();",
            "    assert!(program.byte_classes.len() > 0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
          "    compiler.size_limit(10);",
          "    compiler.byte_classes.set_range(0, 255);",
          "    compiler.compile_finish();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(matches!(program.insts[0], Inst::Match(0)));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(program.capture_name_idx.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(matches!(program.insts[0], Inst::Match(0)));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(program.capture_name_idx.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut compiler = Compiler::new();",
          "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
          "    compiler.size_limit(10);",
          "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
          "    compiler.byte_classes.set_range(0, 255);",
          "    compiler.compile_finish();",
          "}"
        ],
        "oracles": [
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.captures.len(), 1);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.capture_name_idx.get(\"capture\"), Some(&0));"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);"
          ],
          [
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(program.is_bytes);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.insts.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.captures.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.capture_name_idx.get(\"capture\"), Some(&0));",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert_eq!(program.byte_classes.len(), 256);",
            "}"
          ],
          [
            "{",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    compiler.compile_finish();",
            "    let mut compiler = Compiler::new();",
            "    compiler.insts.push(MaybeInst::Compiled(Inst::Match(0)));",
            "    compiler.size_limit(10);",
            "    compiler.capture_name_idx.insert(\"capture\".to_string(), 0);",
            "    compiler.byte_classes.set_range(0, 255);",
            "    let result = compiler.compile_finish();",
            "    let program = result.unwrap();",
            "    assert!(program.is_bytes);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]