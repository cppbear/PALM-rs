[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<abc>\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
          "    parser.pos.set(start_pos);",
          "    parser.parse_capture_name(0);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == 'a' || parser.char() == 'b' || parser.char() == 'c' || parser.char() == '_');"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.name, \"abc\");"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.index, 0);"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.span.start, start_pos);"
          ],
          [
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.span.end.offset, 4);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == 'a' || parser.char() == 'b' || parser.char() == 'c' || parser.char() == '_');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.name, \"abc\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.index, 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.span.start, start_pos);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    let result = parser.parse_capture_name(0);",
            "    let capname = result.unwrap();",
            "    assert_eq!(capname.span.end.offset, 4);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"<>\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
          "    parser.pos.set(start_pos);",
          "    parser.parse_capture_name(0);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == '>');"
          ],
          [
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!((*left_val == *right_val) == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(0);",
            "    let pattern = \"<>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!((*left_val == *right_val) == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"<1abc>\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
          "    parser.pos.set(start_pos);",
          "    parser.parse_capture_name(1);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');"
          ],
          [
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(start_pos.offset != parser.pos().offset);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(1);",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(1);",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(1);",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(1);",
            "    let pattern = \"<1abc>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(start_pos.offset != parser.pos().offset);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"<abc\"; // missing '>'",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
          "    parser.pos.set(start_pos);",
          "    parser.parse_capture_name(2);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == '<');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != ' ');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.bump() == true);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos() == start_pos);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().offset == 0);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().line == 1);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().column == 1);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.error(parser.span(), ast::ErrorKind::GroupNameUnexpectedEof).is_err());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.error(Span::new(start_pos, start_pos), ast::ErrorKind::GroupNameEmpty).is_err());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.char().is_whitespace());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == 'a' || parser.char() == 'b' || parser.char() == 'c');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>' && parser.char() != '<');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '1' && parser.char() != '2' && parser.char() != '3');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != 'A' && parser.char() != 'B' && parser.char() != 'C');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.bump() == false);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == '>' && parser.char() != '<');"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.add_capture_name(&capname).is_err());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.error(parser.span_char(), ast::ErrorKind::GroupNameInvalid).is_err());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!name.is_empty());"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().offset == 0);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().line == 1);"
          ],
          [
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().column == 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == '<');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != ' ');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.bump() == true);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos() == start_pos);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().offset == 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().line == 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().column == 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.error(parser.span(), ast::ErrorKind::GroupNameUnexpectedEof).is_err());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.error(Span::new(start_pos, start_pos), ast::ErrorKind::GroupNameEmpty).is_err());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.char().is_whitespace());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == 'a' || parser.char() == 'b' || parser.char() == 'c');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>' && parser.char() != '<');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '1' && parser.char() != '2' && parser.char() != '3');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != 'A' && parser.char() != 'B' && parser.char() != 'C');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.bump() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() == '>' && parser.char() != '<');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.add_capture_name(&capname).is_err());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.error(parser.span_char(), ast::ErrorKind::GroupNameInvalid).is_err());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(!name.is_empty());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().offset == 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().line == 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc\"; // missing '>'",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(2);",
            "    let pattern = \"<abc\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos.get().column == 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"<abcdefghij>\"; // name length is 10",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
          "    parser.pos.set(start_pos);",
          "    parser.parse_capture_name(3);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.pos().offset, 0);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.pos().line, 1);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.pos().column, 1);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.parse_capture_name(3).is_ok());"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.capture_names.borrow().len(), 1);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.capture_names.borrow()[0].name, \"abcdefghij\");"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.capture_names.borrow()[0].index, 3);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos().offset > start_pos.offset);"
          ],
          [
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.pos().offset, 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.pos().line, 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.pos().column, 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.parse_capture_name(3).is_ok());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.capture_names.borrow().len(), 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.capture_names.borrow()[0].name, \"abcdefghij\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert_eq!(parser.capture_names.borrow()[0].index, 3);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pos().offset > start_pos.offset);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abcdefghij>\"; // name length is 10",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(3);",
            "    let pattern = \"<abcdefghij>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let pattern = \"<abc$>\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
          "    parser.pos.set(start_pos);",
          "    parser.parse_capture_name(4);",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');"
          ],
          [
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pattern()[start_pos.offset..start_pos.offset + 4] == \"abc$\");"
          ],
          [
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.capture_index.get() == 4);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(4);",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(4);",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.char() != '>');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(4);",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(4);",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.pattern()[start_pos.offset..start_pos.offset + 4] == \"abc$\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    parser.parse_capture_name(4);",
            "    let pattern = \"<abc$>\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser {}, pattern: pattern };",
            "    parser.pos.set(start_pos);",
            "    assert!(parser.capture_index.get() == 4);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]