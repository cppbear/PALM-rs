[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[[:loower:]]\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize parser fields */ },",
          "        pattern,",
          "    };",
          "    parser.maybe_parse_ascii_class();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert_eq!(parser.pos(), start_pos);"
          ],
          [
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert!(parser.maybe_parse_ascii_class().is_none());"
          ],
          [
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert_eq!(parser.pos(), start_pos);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert_eq!(parser.pos(), start_pos);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert!(parser.maybe_parse_ascii_class().is_none());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:loower:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI { parser: Parser { /* initialize parser fields */ }, pattern };",
            "    assert_eq!(parser.pos(), start_pos);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[[:alnum:]]\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize parser fields */ },",
          "        pattern,",
          "    };",
          "    parser.maybe_parse_ascii_class();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert!(parser.maybe_parse_ascii_class().is_some());"
          ],
          [
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert_eq!(parser.pos().offset, 13);"
          ],
          [
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert_eq!(parser.pos().line, 1);"
          ],
          [
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert_eq!(parser.pos().column, 13);"
          ],
          [
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let class = parser.maybe_parse_ascii_class().unwrap();",
            "    assert_eq!(class.kind, ClassAsciiKind::Alnum);"
          ],
          [
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let class = parser.maybe_parse_ascii_class().unwrap();",
            "    assert_eq!(class.negated, false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert!(parser.maybe_parse_ascii_class().is_some());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert_eq!(parser.pos().offset, 13);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert_eq!(parser.pos().line, 1);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    assert_eq!(parser.pos().column, 13);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let class = parser.maybe_parse_ascii_class().unwrap();",
            "    assert_eq!(class.kind, ClassAsciiKind::Alnum);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:alnum:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let class = parser.maybe_parse_ascii_class().unwrap();",
            "    assert_eq!(class.negated, false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[[:lower:]A]\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize parser fields */ },",
          "        pattern,",
          "    };",
          "    parser.maybe_parse_ascii_class();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.pos.get(), start_pos);"
          ],
          [
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.pattern, pattern);"
          ],
          [
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert!(parser.maybe_parse_ascii_class().is_some());"
          ],
          [
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.char(), 'A');"
          ],
          [
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.offset(), 15);"
          ],
          [
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert!(parser.parser().pos.get() > start_pos);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.pos.get(), start_pos);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.pattern, pattern);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert!(parser.maybe_parse_ascii_class().is_some());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.char(), 'A');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(parser.offset(), 15);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:lower:]A]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert!(parser.parser().pos.get() > start_pos);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[[:]]\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize parser fields */ },",
          "        pattern,",
          "    };",
          "    parser.maybe_parse_ascii_class();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(self.char(), '[');"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.bump());"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert_eq!(self.char(), ':');"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.bump());"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(!self.bump_if(\":]\"));"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.is_eof());"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert_eq!(self.parser().pos.get(), start);"
          ],
          [
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.maybe_parse_ascii_class().is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    assert_eq!(self.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert_eq!(self.char(), ':');",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.bump());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(!self.bump_if(\":]\"));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.is_eof());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert_eq!(self.parser().pos.get(), start);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let start = self.pos();",
            "    assert!(self.maybe_parse_ascii_class().is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"[[:^alpha:]]\";",
          "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
          "    let parser = ParserI {",
          "        parser: Parser { /* initialize parser fields */ },",
          "        pattern,",
          "    };",
          "    parser.maybe_parse_ascii_class();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    assert!(result.is_some());"
          ],
          [
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert_eq!(class_ascii.kind, ClassAsciiKind::Alpha);"
          ],
          [
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert!(class_ascii.negated);"
          ],
          [
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert_eq!(class_ascii.span.start.offset, 0);"
          ],
          [
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert!(class_ascii.span.is_one_line());"
          ],
          [
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert!(!class_ascii.span.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    assert!(result.is_some());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert_eq!(class_ascii.kind, ClassAsciiKind::Alpha);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert!(class_ascii.negated);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert_eq!(class_ascii.span.start.offset, 0);",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert!(class_ascii.span.is_one_line());",
            "}"
          ],
          [
            "{",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "        parser: Parser { /* initialize parser fields */ },",
            "        pattern,",
            "    };",
            "    parser.maybe_parse_ascii_class();",
            "    let pattern = \"[[:^alpha:]]\";",
            "    let start_pos = Position { offset: 0, line: 1, column: 1 };",
            "    let parser = ParserI {",
            "    parser: Parser { /* initialize parser fields */ },",
            "    pattern,",
            "    };",
            "    let result = parser.maybe_parse_ascii_class();",
            "    let class_ascii = result.unwrap();",
            "    assert!(!class_ascii.span.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]