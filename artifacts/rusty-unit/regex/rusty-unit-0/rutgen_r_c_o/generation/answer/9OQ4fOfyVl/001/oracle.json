[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: Vec::new(),",
          "            nfa: Program::default(),",
          "            dfa: Program::default(),",
          "            dfa_reverse: Program::default(),",
          "            suffixes: LiteralSearcher::default(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.regex_strings();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: Vec::new(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings(), &exec.ro.res);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: Vec::new(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert!(exec.regex_strings().is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: Vec::new(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: Vec::new(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings(), &exec.ro.res);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: Vec::new(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: Vec::new(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert!(exec.regex_strings().is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"abc\".to_string()],",
          "            nfa: Program::default(),",
          "            dfa: Program::default(),",
          "            dfa_reverse: Program::default(),",
          "            suffixes: LiteralSearcher::default(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.regex_strings();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default() }), cache: CachedThreadLocal::new() };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result.len(), 1);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default() }), cache: CachedThreadLocal::new() };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[0], \"abc\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"abc\".to_string()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default() }), cache: CachedThreadLocal::new() };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result.len(), 1);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"abc\".to_string()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default() }), cache: CachedThreadLocal::new() };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[0], \"abc\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()],",
          "            nfa: Program::default(),",
          "            dfa: Program::default(),",
          "            dfa_reverse: Program::default(),",
          "            suffixes: LiteralSearcher::default(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.regex_strings();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result.len(), 3);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[0], \"abc\");"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[1], \"def\");"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[2], \"ghi\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result.len(), 3);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[0], \"abc\");",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[1], \"def\");",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"abc\".to_string(), \"def\".to_string(), \"ghi\".to_string()], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    let result = exec.regex_strings();",
            "    assert_eq!(result[2], \"ghi\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let long_string = \"a\".repeat(256);",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![long_string.clone(), long_string.clone()],",
          "            nfa: Program::default(),",
          "            dfa: Program::default(),",
          "            dfa_reverse: Program::default(),",
          "            suffixes: LiteralSearcher::default(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.regex_strings();",
          "}"
        ],
        "oracles": [
          [
            "    let long_string = \"a\".repeat(256);",
            "    let expected = vec![long_string.clone(), long_string.clone()];",
            "    assert_eq!(exec.regex_strings(), &expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let long_string = \"a\".repeat(256);",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![long_string.clone(), long_string.clone()],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let long_string = \"a\".repeat(256);",
            "    let expected = vec![long_string.clone(), long_string.clone()];",
            "    assert_eq!(exec.regex_strings(), &expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(),",
          "            nfa: Program::default(),",
          "            dfa: Program::default(),",
          "            dfa_reverse: Program::default(),",
          "            suffixes: LiteralSearcher::default(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.regex_strings();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings().len(), 1000);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[0], \"regex_0\");"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[999], \"regex_999\");"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert!(exec.regex_strings().iter().all(|s| s.starts_with(\"regex_\")));"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert!(exec.regex_strings().iter().map(|s| s.trim_start_matches(\"regex_\").parse::<u32>().is_ok()).all(|b| b));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings().len(), 1000);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[0], \"regex_0\");",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[999], \"regex_999\");",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert!(exec.regex_strings().iter().all(|s| s.starts_with(\"regex_\")));",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(),",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: (0..1000).map(|i| format!(\"regex_{}\", i)).collect(), nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert!(exec.regex_strings().iter().map(|s| s.trim_start_matches(\"regex_\").parse::<u32>().is_ok()).all(|b| b));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let exec = Exec {",
          "        ro: Arc::new(ExecReadOnly {",
          "            res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)],",
          "            nfa: Program::default(),",
          "            dfa: Program::default(),",
          "            dfa_reverse: Program::default(),",
          "            suffixes: LiteralSearcher::default(),",
          "            match_type: MatchType::default(),",
          "        }),",
          "        cache: CachedThreadLocal::new(),",
          "    };",
          "    let _ = exec.regex_strings();",
          "}"
        ],
        "oracles": [
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings().len(), 3);"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[0], \"a\".repeat(255));"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[1], \"b\".repeat(255));"
          ],
          [
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[2], \"c\".repeat(255));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings().len(), 3);",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[0], \"a\".repeat(255));",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[1], \"b\".repeat(255));",
            "}"
          ],
          [
            "{",
            "    let exec = Exec {",
            "        ro: Arc::new(ExecReadOnly {",
            "            res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)],",
            "            nfa: Program::default(),",
            "            dfa: Program::default(),",
            "            dfa_reverse: Program::default(),",
            "            suffixes: LiteralSearcher::default(),",
            "            match_type: MatchType::default(),",
            "        }),",
            "        cache: CachedThreadLocal::new(),",
            "    };",
            "    let _ = exec.regex_strings();",
            "    let exec = Exec { ro: Arc::new(ExecReadOnly { res: vec![\"a\".repeat(255), \"b\".repeat(255), \"c\".repeat(255)], nfa: Program::default(), dfa: Program::default(), dfa_reverse: Program::default(), suffixes: LiteralSearcher::default(), match_type: MatchType::default(), }), cache: CachedThreadLocal::new(), };",
            "    assert_eq!(exec.regex_strings()[2], \"c\".repeat(255));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]