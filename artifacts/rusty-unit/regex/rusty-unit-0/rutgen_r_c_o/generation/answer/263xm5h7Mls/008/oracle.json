[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::StartLine,",
          "    };",
          "    let at = InputAt {",
          "        pos: 0,",
          "        c: Char(104), // 'h'",
          "        byte: Some(b'h'),",
          "        len: 11,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 11,",
            "    c: Char(100), // 'd'",
            "    byte: Some(b'd'),",
            "    len: 11,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == true);"
          ],
          [
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 11,",
            "    c: Char(100), // 'd'",
            "    byte: Some(b'd'),",
            "    len: 11,",
            "    };",
            "    let at = InputAt {",
            "    pos: 10,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 11,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);"
          ],
          [
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 11,",
            "    c: Char(100), // 'd'",
            "    byte: Some(b'd'),",
            "    len: 11,",
            "    };",
            "    let at = InputAt {",
            "    pos: 10,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 11,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104), // 'h'",
            "    byte: Some(b'h'),",
            "    len: 11,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartLine,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 11,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 11,",
            "    c: Char(100), // 'd'",
            "    byte: Some(b'd'),",
            "    len: 11,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == true);",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartLine,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 11,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 11,",
            "    c: Char(100), // 'd'",
            "    byte: Some(b'd'),",
            "    len: 11,",
            "    };",
            "    let at = InputAt {",
            "    pos: 10,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 11,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartLine,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 11,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 11,",
            "    c: Char(100), // 'd'",
            "    byte: Some(b'd'),",
            "    len: 11,",
            "    };",
            "    let at = InputAt {",
            "    pos: 10,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 11,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104), // 'h'",
            "    byte: Some(b'h'),",
            "    len: 11,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::EndLine,",
          "    };",
          "    let at = InputAt {",
          "        pos: 10,",
          "        c: Char(108), // 'l'",
          "        byte: Some(b'l'),",
          "        len: 11,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 10,",
            "    c: Char(108),",
            "    byte: Some(b'l'),",
            "    len: 11,",
            "    };",
            "    let result = input_data.is_empty_match(at, &empty);",
            "    assert_eq!(result, false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "        pos: 10,",
            "        c: Char(108), // 'l'",
            "        byte: Some(b'l'),",
            "        len: 11,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\\nworld\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 10,",
            "    c: Char(108),",
            "    byte: Some(b'l'),",
            "    len: 11,",
            "    };",
            "    let result = input_data.is_empty_match(at, &empty);",
            "    assert_eq!(result, false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::StartText,",
          "    };",
          "    let at = InputAt {",
          "        pos: 0,",
          "        c: Char(104), // 'h'",
          "        byte: Some(b'h'),",
          "        len: 5,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "    pos: 1,",
            "    c: Char(101), // 'e'",
            "    byte: Some(b'e'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "    pos: 1,",
            "    c: Char(101), // 'e'",
            "    byte: Some(b'e'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "    pos: 1,",
            "    c: Char(101), // 'e'",
            "    byte: Some(b'e'),",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "    pos: 1,",
            "    c: Char(101), // 'e'",
            "    byte: Some(b'e'),",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty));",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 0,",
            "        c: Char(104), // 'h'",
            "        byte: Some(b'h'),",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 0,",
            "    c: Char(104),",
            "    byte: Some(b'h'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(111), // 'o'",
            "    byte: Some(b'o'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "    pos: 2,",
            "    c: Char(108), // 'l'",
            "    byte: Some(b'l'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "    pos: 1,",
            "    c: Char(101), // 'e'",
            "    byte: Some(b'e'),",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "    pos: 1,",
            "    c: Char(101), // 'e'",
            "    byte: Some(b'e'),",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::EndText,",
          "    };",
          "    let at = InputAt {",
          "        pos: 5,",
          "        c: Char(0), // End of input",
          "        byte: None,",
          "        len: 5,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::EndText,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(0), // End of input",
            "        byte: None,",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    assert!(!input_data.is_empty_match(at, &empty));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello world\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::WordBoundary,",
          "    };",
          "    let at = InputAt {",
          "        pos: 5,",
          "        c: Char(32), // ' '",
          "        byte: Some(b' '),",
          "        len: 11,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello world\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(32),",
            "    byte: Some(b' '),",
            "    len: 11,",
            "    };",
            "    assert_eq!(input_data.is_empty_match(at, &empty), false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello world\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::WordBoundary,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(32), // ' '",
            "        byte: Some(b' '),",
            "        len: 11,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello world\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(32),",
            "    byte: Some(b' '),",
            "    len: 11,",
            "    };",
            "    assert_eq!(input_data.is_empty_match(at, &empty), false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello!\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::NotWordBoundary,",
          "    };",
          "    let at = InputAt {",
          "        pos: 5,",
          "        c: Char(33), // '!'",
          "        byte: Some(b'!'),",
          "        len: 6,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello!\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(33),",
            "    byte: Some(b'!'),",
            "    len: 6,",
            "    };",
            "    assert_eq!(input_data.is_empty_match(at, &empty), false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello!\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::NotWordBoundary,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(33), // '!'",
            "        byte: Some(b'!'),",
            "        len: 6,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello!\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(33),",
            "    byte: Some(b'!'),",
            "    len: 6,",
            "    };",
            "    assert_eq!(input_data.is_empty_match(at, &empty), false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::WordBoundaryAscii,",
          "    };",
          "    let at = InputAt {",
          "        pos: 5,",
          "        c: Char(0), // End of input",
          "        byte: None,",
          "        len: 5,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == true);"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);"
          ],
          [
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == true);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(0), // End of input",
            "        byte: None,",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(0), // End of input",
            "        byte: None,",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(0), // End of input",
            "        byte: None,",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == true);",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(0), // End of input",
            "        byte: None,",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == false);",
            "}"
          ],
          [
            "{",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::WordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(0), // End of input",
            "        byte: None,",
            "        len: 5,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(0),",
            "    byte: None,",
            "    len: 5,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::StartText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndText,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::WordBoundary,",
            "    };",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::NotWordBoundary,",
            "    };",
            "    assert!(input_data.is_empty_match(at, &empty) == true);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let input_data = CharInput(&b\"hello1\"[..]);",
          "    let empty = InstEmptyLook {",
          "        goto: InstPtr::new(),",
          "        look: EmptyLook::NotWordBoundaryAscii,",
          "    };",
          "    let at = InputAt {",
          "        pos: 5,",
          "        c: Char(49), // '1'",
          "        byte: Some(b'1'),",
          "        len: 6,",
          "    };",
          "    input_data.is_empty_match(at, &empty);",
          "}"
        ],
        "oracles": [
          [
            "    let input_data = CharInput(&b\"hello1\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(49), // '1'",
            "    byte: Some(b'1'),",
            "    len: 6,",
            "    };",
            "    let result = input_data.is_empty_match(at, &empty);",
            "    assert!(result == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let input_data = CharInput(&b\"hello1\"[..]);",
            "    let empty = InstEmptyLook {",
            "        goto: InstPtr::new(),",
            "        look: EmptyLook::NotWordBoundaryAscii,",
            "    };",
            "    let at = InputAt {",
            "        pos: 5,",
            "        c: Char(49), // '1'",
            "        byte: Some(b'1'),",
            "        len: 6,",
            "    };",
            "    input_data.is_empty_match(at, &empty);",
            "    let input_data = CharInput(&b\"hello1\"[..]);",
            "    let empty = InstEmptyLook {",
            "    goto: InstPtr::new(),",
            "    look: EmptyLook::EndLine,",
            "    };",
            "    let at = InputAt {",
            "    pos: 5,",
            "    c: Char(49), // '1'",
            "    byte: Some(b'1'),",
            "    len: 6,",
            "    };",
            "    let result = input_data.is_empty_match(at, &empty);",
            "    assert!(result == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]