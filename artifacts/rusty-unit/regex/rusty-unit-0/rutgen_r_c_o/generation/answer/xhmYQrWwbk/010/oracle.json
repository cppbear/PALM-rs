[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let prog = Program {",
          "        insts: vec![",
          "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
          "            Inst::Char(InstChar { /* fields here */ }),",
          "            Inst::Match(0),",
          "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
          "            Inst::Match(1),",
          "            Inst::Char(InstChar { /* fields here */ }),",
          "        ],",
          "        matches: vec![/* match pointers here */],",
          "        captures: vec![None; 2],",
          "        capture_name_idx: Arc::new(HashMap::new()),",
          "        start: 0,",
          "        byte_classes: vec![],",
          "        only_utf8: false,",
          "        is_bytes: false,",
          "        is_dfa: false,",
          "        is_reverse: false,",
          "        is_anchored_start: false,",
          "        is_anchored_end: false,",
          "        has_unicode_word_boundary: false,",
          "        prefixes: LiteralSearcher { /* fields here */ },",
          "        dfa_size_limit: 0,",
          "    };",
          "",
          "    let mut stack = vec![];",
          "    let input = MyInput { /* fields here */ };",
          "    let mut nlist = Threads::new();",
          "    let mut thread_caps = vec![None; 2];",
          "    let mut fsm = Fsm {",
          "        prog: &prog,",
          "        stack: &mut stack,",
          "        input,",
          "    };",
          "",
          "    let ip = 0;",
          "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
          "",
          "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
          "}"
        ],
        "oracles": [
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    assert!(!nlist.set.contains(ip));"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    assert!(matches!(self.prog[ip], Inst::Split(_)));"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    assert_eq!(initial_ip, 0);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    assert_eq!(expected_goto1, 2);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    assert_eq!(nlist.caps(ip).len(), 2);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    assert_eq!(nlist.set.len(), 0);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert_eq!(initial_stack_size, 0);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(nlist.set.insert(ip).is_some());"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(nlist.set.contains(ip));"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(stack.len() > initial_stack_size);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(thread_caps.iter().all(|&slot| slot.is_none()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    assert!(!nlist.set.contains(ip));",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    assert!(matches!(self.prog[ip], Inst::Split(_)));",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    assert_eq!(initial_ip, 0);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    assert_eq!(expected_goto1, 2);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    assert_eq!(nlist.caps(ip).len(), 2);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    assert_eq!(nlist.set.len(), 0);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert_eq!(initial_stack_size, 0);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(nlist.set.insert(ip).is_some());",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(nlist.set.contains(ip));",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(stack.len() > initial_stack_size);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Match(1),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 })], matches: vec![], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut nlist = Threads::new();",
            "    let ip = 0;",
            "    let initial_ip = ip;",
            "    let inst_split = if let Inst::Split(ref inst) = self.prog[ip] { inst } else { panic!(\"Expected a Split instruction\"); };",
            "    let expected_goto1 = inst_split.goto1;",
            "    let initial_stack_size = stack.len();",
            "    assert!(thread_caps.iter().all(|&slot| slot.is_none()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let prog = Program {",
          "        insts: vec![",
          "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
          "            Inst::Save(InstSave { goto: 4, slot: 0 }),",
          "            Inst::Match(0),",
          "            Inst::Char(InstChar { /* fields here */ }),",
          "        ],",
          "        matches: vec![/* match pointers here */],",
          "        captures: vec![None; 2],",
          "        capture_name_idx: Arc::new(HashMap::new()),",
          "        start: 0,",
          "        byte_classes: vec![],",
          "        only_utf8: false,",
          "        is_bytes: false,",
          "        is_dfa: false,",
          "        is_reverse: false,",
          "        is_anchored_start: false,",
          "        is_anchored_end: false,",
          "        has_unicode_word_boundary: false,",
          "        prefixes: LiteralSearcher { /* fields here */ },",
          "        dfa_size_limit: 0,",
          "    };",
          "",
          "    let mut stack = vec![];",
          "    let input = MyInput { /* fields here */ };",
          "    let mut nlist = Threads::new();",
          "    let mut thread_caps = vec![Some(0)];",
          "    let mut fsm = Fsm {",
          "        prog: &prog,",
          "        stack: &mut stack,",
          "        input,",
          "    };",
          "",
          "    let ip = 0;",
          "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
          "",
          "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
          "}"
        ],
        "oracles": [
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(nlist.set.contains(ip), false);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(fsm.prog[ip], Inst::Split(InstSplit { goto1: 2, goto2: 3 }));"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(nlist.set.contains(ip), true);"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(fsm.stack.len(), 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Save(InstSave { goto: 4, slot: 0 }),",
            "            Inst::Match(0),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![Some(0)];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(nlist.set.contains(ip), false);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Save(InstSave { goto: 4, slot: 0 }),",
            "            Inst::Match(0),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![Some(0)];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(fsm.prog[ip], Inst::Split(InstSplit { goto1: 2, goto2: 3 }));",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Save(InstSave { goto: 4, slot: 0 }),",
            "            Inst::Match(0),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![Some(0)];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(nlist.set.contains(ip), true);",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Save(InstSave { goto: 4, slot: 0 }),",
            "            Inst::Match(0),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    let mut thread_caps = vec![Some(0)];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Save(InstSave { goto: 4, slot: 0 }), Inst::Match(0), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let nlist = Threads::new();",
            "    let thread_caps = vec![Some(0)];",
            "    let fsm = Fsm { prog: &prog, stack: &mut stack, input };",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    assert_eq!(fsm.stack.len(), 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let prog = Program {",
          "        insts: vec![",
          "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
          "            Inst::Match(0),",
          "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
          "            Inst::Char(InstChar { /* fields here */ }),",
          "        ],",
          "        matches: vec![/* match pointers here */],",
          "        captures: vec![None; 2],",
          "        capture_name_idx: Arc::new(HashMap::new()),",
          "        start: 0,",
          "        byte_classes: vec![],",
          "        only_utf8: false,",
          "        is_bytes: false,",
          "        is_dfa: false,",
          "        is_reverse: false,",
          "        is_anchored_start: false,",
          "        is_anchored_end: false,",
          "        has_unicode_word_boundary: false,",
          "        prefixes: LiteralSearcher { /* fields here */ },",
          "        dfa_size_limit: 0,",
          "    };",
          "",
          "    let mut stack = vec![];",
          "    let input = MyInput { /* fields here */ };",
          "    let mut nlist = Threads::new();",
          "    nlist.set.insert(0);",
          "    let mut thread_caps = vec![None; 2];",
          "    let mut fsm = Fsm {",
          "        prog: &prog,",
          "        stack: &mut stack,",
          "        input,",
          "    };",
          "",
          "    let ip = 0;",
          "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
          "",
          "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
          "}"
        ],
        "oracles": [
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Match(0), Inst::Split(InstSplit { goto1: 5, goto2: 6 }), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    nlist.set.insert(0);",
            "    let mut thread_caps = vec![None; 2];",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    assert!(nlist.set.contains(ip));"
          ],
          [
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Match(0), Inst::Split(InstSplit { goto1: 5, goto2: 6 }), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    nlist.set.insert(0);",
            "    let mut thread_caps = vec![None; 2];",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    assert!(nlist.caps(ip).iter().all(|cap| cap.is_none()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    nlist.set.insert(0);",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Match(0), Inst::Split(InstSplit { goto1: 5, goto2: 6 }), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    nlist.set.insert(0);",
            "    let mut thread_caps = vec![None; 2];",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    assert!(nlist.set.contains(ip));",
            "}"
          ],
          [
            "{",
            "    let prog = Program {",
            "        insts: vec![",
            "            Inst::Split(InstSplit { goto1: 2, goto2: 3 }),",
            "            Inst::Match(0),",
            "            Inst::Split(InstSplit { goto1: 5, goto2: 6 }),",
            "            Inst::Char(InstChar { /* fields here */ }),",
            "        ],",
            "        matches: vec![/* match pointers here */],",
            "        captures: vec![None; 2],",
            "        capture_name_idx: Arc::new(HashMap::new()),",
            "        start: 0,",
            "        byte_classes: vec![],",
            "        only_utf8: false,",
            "        is_bytes: false,",
            "        is_dfa: false,",
            "        is_reverse: false,",
            "        is_anchored_start: false,",
            "        is_anchored_end: false,",
            "        has_unicode_word_boundary: false,",
            "        prefixes: LiteralSearcher { /* fields here */ },",
            "        dfa_size_limit: 0,",
            "    };",
            "",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    nlist.set.insert(0);",
            "    let mut thread_caps = vec![None; 2];",
            "    let mut fsm = Fsm {",
            "        prog: &prog,",
            "        stack: &mut stack,",
            "        input,",
            "    };",
            "",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    let prog = Program { insts: vec![Inst::Split(InstSplit { goto1: 2, goto2: 3 }), Inst::Match(0), Inst::Split(InstSplit { goto1: 5, goto2: 6 }), Inst::Char(InstChar { /* fields here */ }),], matches: vec![/* match pointers here */], captures: vec![None; 2], capture_name_idx: Arc::new(HashMap::new()), start: 0, byte_classes: vec![], only_utf8: false, is_bytes: false, is_dfa: false, is_reverse: false, is_anchored_start: false, is_anchored_end: false, has_unicode_word_boundary: false, prefixes: LiteralSearcher { /* fields here */ }, dfa_size_limit: 0, };",
            "    let mut stack = vec![];",
            "    let input = MyInput { /* fields here */ };",
            "    let mut nlist = Threads::new();",
            "    nlist.set.insert(0);",
            "    let mut thread_caps = vec![None; 2];",
            "    let ip = 0;",
            "    let at = InputAt { pos: 0, c: 'a', byte: None, len: 1 };",
            "    fsm.add_step(&mut nlist, &mut thread_caps, ip, at);",
            "    assert!(nlist.caps(ip).iter().all(|cap| cap.is_none()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]