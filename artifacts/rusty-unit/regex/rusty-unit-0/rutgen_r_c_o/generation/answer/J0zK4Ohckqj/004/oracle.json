[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"\";",
          "    let line_number_width = 0;",
          "    let by_line = vec![vec![]];",
          "    let multi_line = vec![];",
          "",
          "    let spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    spans.notate();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"\\n\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"\\n\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"abc\";",
          "    let line_number_width = 0;",
          "    let by_line = vec![vec![]];",
          "    let multi_line = vec![];",
          "",
          "    let spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    spans.notate();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"abc\\n\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"abc\\n\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"abc\\ndef\";",
          "    let line_number_width = 0;",
          "    let by_line = vec![vec![], vec![]];",
          "    let multi_line = vec![];",
          "",
          "    let spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    spans.notate();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"    abc\\n    def\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: abc\\n  \\n2: def\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"test\\ncase\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: test\\n  \\n2: case\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"test\\ncase\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 5;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"    1: test\\n    ^^^^\\n    2: case\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"test\\ncase\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 5;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"one\\ntwo\\nthree\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"    one\\n    ^^\\n    two\\n    three\\n\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"    abc\\n    def\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: abc\\n  \\n2: def\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"test\\ncase\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: test\\n  \\n2: case\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"test\\ncase\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 5;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"    1: test\\n    ^^^^\\n    2: case\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 1 }, end: Position { line: 0, column: 2 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"test\\ncase\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 2 }, end: Position { line: 0, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let line_number_width = 5;",
            "    let by_line = vec![vec![Span { start: Position { line: 0, column: 0 }, end: Position { line: 0, column: 4 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    let pattern = \"one\\ntwo\\nthree\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![vec![], vec![Span { start: Position { line: 1, column: 1 }, end: Position { line: 1, column: 3 } }], vec![]];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \"    one\\n    ^^\\n    two\\n    three\\n\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"abc\";",
          "    let line_number_width = 2;",
          "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
          "    let multi_line = vec![];",
          "",
          "    let spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    spans.notate();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: abc\\n  \\n\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }]];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: abc\\n  \\n\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"abc\\ndef\";",
          "    let line_number_width = 3;",
          "    let by_line = vec![",
          "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
          "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
          "    ];",
          "    let multi_line = vec![];",
          "",
          "    let spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    spans.notate();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"  1: abc\\n  ^\\n  2: def\\n  ^\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"abc\\n  ^\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"  1: \\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \" 1: abc\\n  ^^^\\n 2: def\\n\");"
          ],
          [
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"hello\\nworld\";",
            "    let line_number_width = 4;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"   1: hello\\n   ^ ^ ^ ^ ^\\n   2: world\\n   ^ ^ ^ ^ ^\\n\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"  1: abc\\n  ^\\n  2: def\\n  ^\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"abc\\n  ^\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"  1: \\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \" 1: abc\\n  ^^^\\n 2: def\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "        vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "        vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 0;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 2) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"\";",
            "    let line_number_width = 3;",
            "    let by_line = vec![",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"abc\\ndef\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 3) }],",
            "    vec![],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    let pattern = \"hello\\nworld\";",
            "    let line_number_width = 4;",
            "    let by_line = vec![",
            "    vec![Span { start: Position::new(0, 1), end: Position::new(0, 5) }],",
            "    vec![Span { start: Position::new(1, 1), end: Position::new(1, 5) }],",
            "    ];",
            "    let multi_line = vec![];",
            "    let spans = Spans {",
            "    pattern,",
            "    line_number_width,",
            "    by_line,",
            "    multi_line,",
            "    };",
            "    let notated = spans.notate();",
            "    assert_eq!(notated, \"   1: hello\\n   ^ ^ ^ ^ ^\\n   2: world\\n   ^ ^ ^ ^ ^\\n\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let pattern = \"abc\";",
          "    let line_number_width = 2;",
          "    let by_line = vec![vec![]];",
          "    let multi_line = vec![];",
          "",
          "    let spans = Spans {",
          "        pattern,",
          "        line_number_width,",
          "        by_line,",
          "        multi_line,",
          "    };",
          "",
          "    spans.notate();",
          "}"
        ],
        "oracles": [
          [
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: abc\\n\");"
          ],
          [
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert!(result.contains(\"abc\"));"
          ],
          [
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert!(result.starts_with(\" 1:\"));"
          ],
          [
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert!(result.ends_with(\"\\n\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert_eq!(result, \" 1: abc\\n\");",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert!(result.contains(\"abc\"));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert!(result.starts_with(\" 1:\"));",
            "}"
          ],
          [
            "{",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "",
            "    let spans = Spans {",
            "        pattern,",
            "        line_number_width,",
            "        by_line,",
            "        multi_line,",
            "    };",
            "",
            "    spans.notate();",
            "    let pattern = \"abc\";",
            "    let line_number_width = 2;",
            "    let by_line = vec![vec![]];",
            "    let multi_line = vec![];",
            "    let spans = Spans { pattern, line_number_width, by_line, multi_line };",
            "    let result = spans.notate();",
            "    assert!(result.ends_with(\"\\n\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]