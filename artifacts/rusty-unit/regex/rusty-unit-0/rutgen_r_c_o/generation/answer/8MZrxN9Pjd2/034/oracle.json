[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer {",
          "        printer: &mut printer,",
          "        wtr: &mut output,",
          "    };",
          "",
          "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    assert_eq!(writer.visit_pre(&hir).unwrap(), ());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    assert_eq!(output, \"a\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    assert_eq!(writer.visit_pre(&hir).unwrap(), ());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    assert_eq!(output, \"a\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer {",
          "        printer: &mut printer,",
          "        wtr: &mut output,",
          "    };",
          "",
          "    let hir = Hir::literal(hir::Literal::Byte(10));",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    assert_eq!(output, \"\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"[a-b]\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x14])\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?m:^)\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?m:$)\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\A\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\z\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\b\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"(?-u:\\b)\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\B\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"(?-u:\\B)\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureName { name: String::from(\"test\"), index: 0 }, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?P<test>\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureName { name: String::from(\"test\"), index: 0 }, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::NonCapturing, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?:\");"
          ],
          [
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureName { name: String::from(\"test\"), index: 0 }, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::NonCapturing, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::repetition(hir::Repetition::zero_or_more(hir::Hir::literal(hir::Literal::Byte(1))));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::concat(vec![hir::Hir::literal(hir::Literal::Byte(2)), hir::Hir::literal(hir::Literal::Byte(3))]);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?m:^)\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    assert_eq!(output, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"[a-b]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x14])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?m:^)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?m:$)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\A\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\z\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\b\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"(?-u:\\b)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"\\B\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, r\"(?-u:\\B)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureName { name: String::from(\"test\"), index: 0 }, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?P<test>\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureName { name: String::from(\"test\"), index: 0 }, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::NonCapturing, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?:\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::literal(hir::Literal::Byte(10));",
            "    let hir = Hir::literal(hir::Literal::Unicode('a'));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(10, 20)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::StartText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::anchor(hir::Anchor::EndText);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::UnicodeNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::word_boundary(hir::WordBoundary::AsciiNegate);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::CaptureName { name: String::from(\"test\"), index: 0 }, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let group = Group { kind: hir::GroupKind::NonCapturing, hir: Box::new(hir::Hir::empty()) };",
            "    let hir = Hir::group(group);",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::repetition(hir::Repetition::zero_or_more(hir::Hir::literal(hir::Literal::Byte(1))));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::concat(vec![hir::Hir::literal(hir::Literal::Byte(2)), hir::Hir::literal(hir::Literal::Byte(3))]);",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"(?m:^)\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer {",
          "        printer: &mut printer,",
          "        wtr: &mut output,",
          "    };",
          "",
          "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
          "",
          "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    assert_eq!(writer.visit_pre(&hir).is_ok(), true);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    assert_eq!(output, \"[a-c]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    assert_eq!(writer.visit_pre(&hir).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    assert_eq!(output, \"[a-c]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer {",
          "        printer: &mut printer,",
          "        wtr: &mut output,",
          "    };",
          "",
          "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
          "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
          "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
          "",
          "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert_eq!(writer.wtr, &\"(?-u:[\\n\\n])\");"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(output.contains(\"(?-u:[\"));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(output.contains(\"-\"));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(output.contains(\"])\"));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert_eq!(writer.wtr, &\"(?-u:[\\n\\n])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(output.contains(\"(?-u:[\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(output.contains(\"-\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(output.contains(\"])\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(10, 20);",
            "    let bytes_range_2 = ClassBytesRange::new(30, 40);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer {",
          "        printer: &mut printer,",
          "        wtr: &mut output,",
          "    };",
          "",
          "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
          "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
          "",
          "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let unicode_range_1 = ClassUnicodeRange::new('a', 'a');",
            "    let unicode_range_2 = ClassUnicodeRange::new('d', 'f');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range_1, unicode_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Unicode(class_unicode));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "    printer: &mut printer,",
            "    wtr: &mut output,",
            "    };",
            "    let class_bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let class_bytes_range_2 = ClassBytesRange::new(2, 3);",
            "    let class_bytes = ClassBytes::new(vec![class_bytes_range_1, class_bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let unicode_char = 'b';",
            "    let hir = Hir::literal(hir::Literal::Unicode(unicode_char));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let byte_value = 10;",
            "    let hir = Hir::literal(hir::Literal::Byte(byte_value));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let hir = Hir::empty();",
            "    let hir = Hir::repetition(Hir::empty());",
            "    let hir = Hir::concat(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::alternation(vec![Hir::empty(), Hir::empty()]);",
            "    let hir = Hir::group(Group {",
            "    kind: hir::GroupKind::CaptureIndex(0),",
            "    hir: Box::new(Hir::empty()),",
            "    });",
            "    let hir = Hir::anchor(hir::Anchor::StartLine);",
            "    let hir = Hir::anchor(hir::Anchor::EndLine);",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Unicode);",
            "    let hir = Hir::word_boundary(hir::WordBoundary::Ascii);",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer {",
          "        printer: &mut printer,",
          "        wtr: &mut output,",
          "    };",
          "",
          "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
          "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
          "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
          "",
          "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert_eq!(self.wtr.write_str(\"(?-u:[\")?, Ok(()));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert!(range.start() != range.end());"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert_eq!(self.write_literal_class_byte(range.start())?, Ok(()));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert_eq!(self.wtr.write_str(\"-\")?, Ok(()));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert_eq!(self.write_literal_class_byte(range.end())?, Ok(()));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    }",
            "    assert_eq!(self.wtr.write_str(\"])\")?, Ok(()));"
          ],
          [
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    }",
            "    assert_eq!(writer.visit_pre(&hir), Ok(()));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    assert_eq!(self.wtr.write_str(\"(?-u:[\")?, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert!(range.start() != range.end());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert_eq!(self.write_literal_class_byte(range.start())?, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert_eq!(self.wtr.write_str(\"-\")?, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    assert_eq!(self.write_literal_class_byte(range.end())?, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    }",
            "    assert_eq!(self.wtr.write_str(\"])\")?, Ok(()));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer {",
            "        printer: &mut printer,",
            "        wtr: &mut output,",
            "    };",
            "",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    writer.visit_pre(&hir).unwrap();",
            "    let bytes_range_1 = ClassBytesRange::new(1, 1);",
            "    let bytes_range_2 = ClassBytesRange::new(5, 10);",
            "    let class_bytes = ClassBytes::new(vec![bytes_range_1, bytes_range_2]);",
            "    let hir = Hir::class(hir::Class::Bytes(class_bytes));",
            "    for range in cls.iter() {",
            "    }",
            "    assert_eq!(writer.visit_pre(&hir), Ok(()));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]