[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
          "",
          "    let unicode_range = ClassUnicodeRange::new('a', 'c'); // start < end",
          "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
          "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
          "",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    assert_eq!(writer.output, \"[a-c]\");"
          ],
          [
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    assert_eq!(writer.output, \"(?-u:[1-5])\");"
          ],
          [
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('b'));",
            "    let _ = visitor.visit_pre(&unicode_literal);",
            "    assert_eq!(writer.output, \"b\");"
          ],
          [
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('b'));",
            "    let _ = visitor.visit_pre(&unicode_literal);",
            "    let byte_literal = Hir::literal(hir::Literal::Byte(65)); // 'A'",
            "    let _ = visitor.visit_pre(&byte_literal);",
            "    assert_eq!(writer.output, \"A\");"
          ],
          [
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('b'));",
            "    let _ = visitor.visit_pre(&unicode_literal);",
            "    let byte_literal = Hir::literal(hir::Literal::Byte(65)); // 'A'",
            "    let _ = visitor.visit_pre(&byte_literal);",
            "    let invalid_range = ClassBytesRange::new(5, 3); // start > end",
            "    let class_bytes_invalid = ClassBytes::new(vec![invalid_range]);",
            "    let hir_invalid = Hir { kind: HirKind::Class(Class::Bytes(class_bytes_invalid)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir_invalid);",
            "    assert!(result.is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c'); // start < end",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    assert_eq!(writer.output, \"[a-c]\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c'); // start < end",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    assert_eq!(writer.output, \"(?-u:[1-5])\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c'); // start < end",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('b'));",
            "    let _ = visitor.visit_pre(&unicode_literal);",
            "    assert_eq!(writer.output, \"b\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c'); // start < end",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('b'));",
            "    let _ = visitor.visit_pre(&unicode_literal);",
            "    let byte_literal = Hir::literal(hir::Literal::Byte(65)); // 'A'",
            "    let _ = visitor.visit_pre(&byte_literal);",
            "    assert_eq!(writer.output, \"A\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c'); // start < end",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let unicode_range = ClassUnicodeRange::new('a', 'c');",
            "    let class_unicode = ClassUnicode::new(vec![unicode_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let byte_range = ClassBytesRange::new(1, 5); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir_bytes = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let _ = visitor.visit_pre(&hir_bytes);",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('b'));",
            "    let _ = visitor.visit_pre(&unicode_literal);",
            "    let byte_literal = Hir::literal(hir::Literal::Byte(65)); // 'A'",
            "    let _ = visitor.visit_pre(&byte_literal);",
            "    let invalid_range = ClassBytesRange::new(5, 3); // start > end",
            "    let class_bytes_invalid = ClassBytes::new(vec![invalid_range]);",
            "    let hir_invalid = Hir { kind: HirKind::Class(Class::Bytes(class_bytes_invalid)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir_invalid);",
            "    assert!(result.is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
          "    ",
          "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
          "    let class_bytes = ClassBytes::new(vec![byte_range]);",
          "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
          "",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"(?-u:[\"));"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"-\"));"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"\\\\x01\"));"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"\\\\x03\"));"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(!writer.output.contains(\"\\\\x02\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    ",
            "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    ",
            "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"(?-u:[\"));",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    ",
            "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"-\"));",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    ",
            "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"\\\\x01\"));",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    ",
            "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(writer.output.contains(\"\\\\x03\"));",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    ",
            "    let byte_range = ClassBytesRange::new(1, 3); // start < end",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let byte_range = ClassBytesRange::new(1, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(!writer.output.contains(\"\\\\x02\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
          "",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
          "",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    assert!(result_unicode.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    assert!(result_byte.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    assert!(result_class_unicode.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    assert!(result_class_bytes.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    assert!(result_empty.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    assert!(result_repetition.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    assert!(result_concat.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    assert!(result_alternation.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    assert!(result_anchor_start_line.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    assert!(result_anchor_end_line.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    assert!(result_word_boundary_unicode.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    let hir_group_capture_index = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_index = visitor.visit_pre(&hir_group_capture_index);",
            "    assert!(result_group_capture_index.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    let hir_group_capture_index = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_index = visitor.visit_pre(&hir_group_capture_index);",
            "    let hir_group_capture_name = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureName { name: String::from(\"group\"), index: 0 }, hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_name = visitor.visit_pre(&hir_group_capture_name);",
            "    assert!(result_group_capture_name.is_ok());"
          ],
          [
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    let hir_group_capture_index = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_index = visitor.visit_pre(&hir_group_capture_index);",
            "    let hir_group_capture_name = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureName { name: String::from(\"group\"), index: 0 }, hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_name = visitor.visit_pre(&hir_group_capture_name);",
            "    let hir_group_non_capturing = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::NonCapturing, hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_non_capturing = visitor.visit_pre(&hir_group_non_capturing);",
            "    assert!(result_group_non_capturing.is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    assert!(result_unicode.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    assert!(result_byte.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    assert!(result_class_unicode.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    assert!(result_class_bytes.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    assert!(result_empty.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    assert!(result_repetition.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    assert!(result_concat.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    assert!(result_alternation.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    assert!(result_anchor_start_line.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    assert!(result_anchor_end_line.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    assert!(result_word_boundary_unicode.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    let hir_group_capture_index = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_index = visitor.visit_pre(&hir_group_capture_index);",
            "    assert!(result_group_capture_index.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    let hir_group_capture_index = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_index = visitor.visit_pre(&hir_group_capture_index);",
            "    let hir_group_capture_name = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureName { name: String::from(\"group\"), index: 0 }, hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_name = visitor.visit_pre(&hir_group_capture_name);",
            "    assert!(result_group_capture_name.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let writer = MockWriter { output: String::new() };",
            "    let visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir_unicode = Hir { kind: HirKind::Literal(hir::Literal::Unicode('b')), info: HirInfo::default() };",
            "    let result_unicode = visitor.visit_pre(&hir_unicode);",
            "    let hir_byte = Hir { kind: HirKind::Literal(hir::Literal::Byte(1)), info: HirInfo::default() };",
            "    let result_byte = visitor.visit_pre(&hir_byte);",
            "    let class_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir_class_unicode = Hir { kind: HirKind::Class(hir::Class::Unicode(class_unicode)), info: HirInfo::default() };",
            "    let result_class_unicode = visitor.visit_pre(&hir_class_unicode);",
            "    let class_bytes = ClassBytes::new(vec![ClassBytesRange::new(1, 2)]);",
            "    let hir_class_bytes = Hir { kind: HirKind::Class(hir::Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    let result_class_bytes = visitor.visit_pre(&hir_class_bytes);",
            "    let hir_empty = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
            "    let result_empty = visitor.visit_pre(&hir_empty);",
            "    let hir_repetition = Hir { kind: HirKind::Repetition(hir::Repetition::zero_or_more(Box::new(hir_empty))), info: HirInfo::default() };",
            "    let result_repetition = visitor.visit_pre(&hir_repetition);",
            "    let hir_concat = Hir { kind: HirKind::Concat(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_concat = visitor.visit_pre(&hir_concat);",
            "    let hir_alternation = Hir { kind: HirKind::Alternation(vec![hir_unicode, hir_empty]), info: HirInfo::default() };",
            "    let result_alternation = visitor.visit_pre(&hir_alternation);",
            "    let hir_anchor_start_line = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result_anchor_start_line = visitor.visit_pre(&hir_anchor_start_line);",
            "    let hir_anchor_end_line = Hir { kind: HirKind::Anchor(hir::Anchor::EndLine), info: HirInfo::default() };",
            "    let result_anchor_end_line = visitor.visit_pre(&hir_anchor_end_line);",
            "    let hir_word_boundary_unicode = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result_word_boundary_unicode = visitor.visit_pre(&hir_word_boundary_unicode);",
            "    let hir_group_capture_index = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_index = visitor.visit_pre(&hir_group_capture_index);",
            "    let hir_group_capture_name = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureName { name: String::from(\"group\"), index: 0 }, hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_capture_name = visitor.visit_pre(&hir_group_capture_name);",
            "    let hir_group_non_capturing = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::NonCapturing, hir: Box::new(hir_empty) }), info: HirInfo::default() };",
            "    let result_group_non_capturing = visitor.visit_pre(&hir_group_non_capturing);",
            "    assert!(result_group_non_capturing.is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
          "",
          "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
          "",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?-u:[\\x01-\\x03])\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"[a-c]\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"\u0005\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"A\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?-u:[\\x01])\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"[]\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?-u:[])\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?m:^)\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, r\"\\b\");"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(Hir::empty()) }), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(Hir::empty()) }), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?-u:[\\x01-\\x03])\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"[a-c]\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"\u0005\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"A\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?-u:[\\x01])\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"[]\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?-u:[])\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(?m:^)\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, r\"\\b\");",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(Hir::empty()) }), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 3)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')])), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Byte(5)), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Literal(hir::Literal::Unicode('A')), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::new(vec![ClassBytesRange::new(1, 1)]))), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Unicode(ClassUnicode::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Class(hir::Class::Bytes(ClassBytes::empty())), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Anchor(hir::Anchor::StartLine), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::WordBoundary(hir::WordBoundary::Unicode), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    let hir = Hir { kind: HirKind::Group(Group { kind: hir::GroupKind::CaptureIndex(0), hir: Box::new(Hir::empty()) }), info: HirInfo::default() };",
            "    let result = visitor.visit_pre(&hir);",
            "    assert_eq!(writer.output, \"(\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    struct MockWriter {",
          "        output: String,",
          "    }",
          "    ",
          "    impl fmt::Write for MockWriter {",
          "        fn write_str(&mut self, s: &str) -> fmt::Result {",
          "            self.output.push_str(s);",
          "            Ok(())",
          "        }",
          "    }",
          "",
          "    let mut writer = MockWriter { output: String::new() };",
          "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
          "",
          "    let byte_range = ClassBytesRange::new(5, 3); // start >= end to trigger panic",
          "    let class_bytes = ClassBytes::new(vec![byte_range]);",
          "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
          "",
          "    let _ = visitor.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let byte_range = ClassBytesRange::new(5, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    assert!(visitor.visit_pre(&hir).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct MockWriter {",
            "        output: String,",
            "    }",
            "    ",
            "    impl fmt::Write for MockWriter {",
            "        fn write_str(&mut self, s: &str) -> fmt::Result {",
            "            self.output.push_str(s);",
            "            Ok(())",
            "        }",
            "    }",
            "",
            "    let mut writer = MockWriter { output: String::new() };",
            "    let mut visitor = Writer { printer: &mut Printer { _priv: () }, wtr: &mut writer };",
            "",
            "    let byte_range = ClassBytesRange::new(5, 3); // start >= end to trigger panic",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "",
            "    let _ = visitor.visit_pre(&hir);",
            "    let byte_range = ClassBytesRange::new(5, 3);",
            "    let class_bytes = ClassBytes::new(vec![byte_range]);",
            "    let hir = Hir { kind: HirKind::Class(Class::Bytes(class_bytes)), info: HirInfo::default() };",
            "    assert!(visitor.visit_pre(&hir).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]