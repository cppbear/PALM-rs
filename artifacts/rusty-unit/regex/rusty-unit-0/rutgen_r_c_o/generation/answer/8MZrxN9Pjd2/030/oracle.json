[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let ranges = vec![",
          "        ClassUnicodeRange::new('a', 'b'),",
          "        ClassUnicodeRange::new('c', 'd')",
          "    ];",
          "    let cls = ClassUnicode::new(ranges);",
          "    let hir = Hir::class(hir::Class::Unicode(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let _ = writer.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x00-\\x03])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[a]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[a-b]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x00])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x80-\\xFF])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x14][\\x15-\\x19])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('x', 'y'), ClassUnicodeRange::new('z', 'z')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[x-y][z]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('x', 'y'), ClassUnicodeRange::new('z', 'z')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 21)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x14][\\x15])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('x', 'y'), ClassUnicodeRange::new('z', 'z')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 21)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[a]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x00-\\x03])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[a]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[a-b]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x00])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x80-\\xFF])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x14][\\x15-\\x19])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('x', 'y'), ClassUnicodeRange::new('z', 'z')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[x-y][z]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('x', 'y'), ClassUnicodeRange::new('z', 'z')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 21)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x14][\\x15])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('a', 'b'),",
            "        ClassUnicodeRange::new('c', 'd')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(0, 1),",
            "    ClassBytesRange::new(2, 3)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'b')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(0, 0)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(128, 255)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 25)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('x', 'y'), ClassUnicodeRange::new('z', 'z')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(10, 20), ClassBytesRange::new(21, 21)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassUnicodeRange::new('a', 'a')];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[a]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let ranges = vec![",
          "        ClassBytesRange::new(1, 3),",
          "        ClassBytesRange::new(4, 5)",
          "    ];",
          "    let cls = ClassBytes::new(ranges);",
          "    let hir = Hir::class(hir::Class::Bytes(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let _ = writer.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(1, 3), ClassBytesRange::new(4, 5)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(1, 3), ClassBytesRange::new(4, 5)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x01-\\x03\\x04-\\x05])\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassBytesRange::new(1, 3),",
            "        ClassBytesRange::new(4, 5)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(1, 3), ClassBytesRange::new(4, 5)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassBytesRange::new(1, 3),",
            "        ClassBytesRange::new(4, 5)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![ClassBytesRange::new(1, 3), ClassBytesRange::new(4, 5)];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"(?-u:[\\x01-\\x03\\x04-\\x05])\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let byte_value = 255u8;",
          "    let literal = hir::Literal::Byte(byte_value);",
          "    let hir = Hir::literal(literal);",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let _ = writer.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let byte_value = 255u8;",
            "    let literal = hir::Literal::Byte(byte_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(writer.visit_pre(&hir).is_err());"
          ],
          [
            "    let byte_value = 255u8;",
            "    let literal = hir::Literal::Byte(byte_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let byte_value = 255u8;",
            "    let literal = hir::Literal::Byte(byte_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let byte_value = 255u8;",
            "    let literal = hir::Literal::Byte(byte_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(writer.visit_pre(&hir).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let byte_value = 255u8;",
            "    let literal = hir::Literal::Byte(byte_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let byte_value = 255u8;",
            "    let literal = hir::Literal::Byte(byte_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let char_value = 'z';",
          "    let literal = hir::Literal::Unicode(char_value);",
          "    let hir = Hir::literal(literal);",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let _ = writer.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"z\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    assert!(writer_byte.visit_pre(&hir_byte).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    assert_eq!(output_byte, \"x\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    assert!(writer_class.visit_pre(&class_hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    assert_eq!(output_class, \"[a-c]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    assert!(writer_bytes_class.visit_pre(&class_bytes_hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    assert_eq!(output_bytes_class, \"(?-u:[a-c])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    let bad_value = 255u8;",
            "    let class_with_bad_bytes = ClassBytes::new(vec![ClassBytesRange::new(bad_value, bad_value)]);",
            "    let class_bytes_hir_bad = Hir::class(hir::Class::Bytes(class_with_bad_bytes));",
            "    let mut output_bad_bytes_class = String::new();",
            "    let mut writer_bad_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bad_bytes_class };",
            "    assert!(writer_bad_bytes_class.visit_pre(&class_bytes_hir_bad).is_err());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    let bad_value = 255u8;",
            "    let class_with_bad_bytes = ClassBytes::new(vec![ClassBytesRange::new(bad_value, bad_value)]);",
            "    let class_bytes_hir_bad = Hir::class(hir::Class::Bytes(class_with_bad_bytes));",
            "    let mut output_bad_bytes_class = String::new();",
            "    let mut writer_bad_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bad_bytes_class };",
            "    assert!(output_bad_bytes_class.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"z\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    assert!(writer_byte.visit_pre(&hir_byte).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    assert_eq!(output_byte, \"x\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    assert!(writer_class.visit_pre(&class_hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    assert_eq!(output_class, \"[a-c]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    assert!(writer_bytes_class.visit_pre(&class_bytes_hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    assert_eq!(output_bytes_class, \"(?-u:[a-c])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    let bad_value = 255u8;",
            "    let class_with_bad_bytes = ClassBytes::new(vec![ClassBytesRange::new(bad_value, bad_value)]);",
            "    let class_bytes_hir_bad = Hir::class(hir::Class::Bytes(class_with_bad_bytes));",
            "    let mut output_bad_bytes_class = String::new();",
            "    let mut writer_bad_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bad_bytes_class };",
            "    assert!(writer_bad_bytes_class.visit_pre(&class_bytes_hir_bad).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let char_value = 'z';",
            "    let literal = hir::Literal::Unicode(char_value);",
            "    let hir = Hir::literal(literal);",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let byte_value = 120u8;",
            "    let literal_byte = hir::Literal::Byte(byte_value);",
            "    let hir_byte = Hir::literal(literal_byte);",
            "    let mut output_byte = String::new();",
            "    let mut writer_byte = Writer { printer: &mut printer, wtr: &mut output_byte };",
            "    let unicode_class = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'c')]);",
            "    let class_hir = Hir::class(hir::Class::Unicode(unicode_class));",
            "    let mut output_class = String::new();",
            "    let mut writer_class = Writer { printer: &mut printer, wtr: &mut output_class };",
            "    let bytes_class = ClassBytes::new(vec![ClassBytesRange::new(97, 100)]);",
            "    let class_bytes_hir = Hir::class(hir::Class::Bytes(bytes_class));",
            "    let mut output_bytes_class = String::new();",
            "    let mut writer_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bytes_class };",
            "    let bad_value = 255u8;",
            "    let class_with_bad_bytes = ClassBytes::new(vec![ClassBytesRange::new(bad_value, bad_value)]);",
            "    let class_bytes_hir_bad = Hir::class(hir::Class::Bytes(class_with_bad_bytes));",
            "    let mut output_bad_bytes_class = String::new();",
            "    let mut writer_bad_bytes_class = Writer { printer: &mut printer, wtr: &mut output_bad_bytes_class };",
            "    assert!(output_bad_bytes_class.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let ranges = vec![",
          "        ClassBytesRange::new(10, 15),",
          "        ClassBytesRange::new(20, 30)",
          "    ];",
          "    let cls = ClassBytes::new(ranges);",
          "    let hir = Hir::class(hir::Class::Bytes(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let _ = writer.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(10, 15),",
            "    ClassBytesRange::new(20, 30)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(writer.visit_pre(&hir).is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(10, 15),",
            "    ClassBytesRange::new(20, 30)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x0F\\x14-\\x1E])\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassBytesRange::new(10, 15),",
            "        ClassBytesRange::new(20, 30)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(10, 15),",
            "    ClassBytesRange::new(20, 30)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(writer.visit_pre(&hir).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassBytesRange::new(10, 15),",
            "        ClassBytesRange::new(20, 30)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassBytesRange::new(10, 15),",
            "    ClassBytesRange::new(20, 30)",
            "    ];",
            "    let cls = ClassBytes::new(ranges);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"(?-u:[\\x0A-\\x0F\\x14-\\x1E])\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let ranges = vec![",
          "        ClassUnicodeRange::new('x', 'y'),",
          "        ClassUnicodeRange::new('z', 'z')",
          "    ];",
          "    let cls = ClassUnicode::new(ranges);",
          "    let hir = Hir::class(hir::Class::Unicode(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "    let _ = writer.visit_pre(&hir);",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[x-y]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(!output.contains('z'));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(output.contains(\"[\"));"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(output.contains(\"]\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('x', 'y'),",
            "        ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('x', 'y'),",
            "        ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert_eq!(output, \"[x-y]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('x', 'y'),",
            "        ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(!output.contains('z'));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('x', 'y'),",
            "        ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(output.contains(\"[\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "        ClassUnicodeRange::new('x', 'y'),",
            "        ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let _ = writer.visit_pre(&hir);",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let ranges = vec![",
            "    ClassUnicodeRange::new('x', 'y'),",
            "    ClassUnicodeRange::new('z', 'z')",
            "    ];",
            "    let cls = ClassUnicode::new(ranges);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    let result = writer.visit_pre(&hir);",
            "    assert!(output.contains(\"]\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]