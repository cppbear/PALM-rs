[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
          "    let hir = Hir::class(hir::Class::Bytes(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(writer.visit_pre(&hir).unwrap(), ());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.contains(\"(?-u:[\"));"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.contains(\"])\"));"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.chars().filter(|&c| c == '\\x00').count() == 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(writer.visit_pre(&hir).unwrap(), ());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.contains(\"(?-u:[\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.contains(\"])\"));",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 0)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert!(output.chars().filter(|&c| c == '\\x00').count() == 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let hir = Hir::literal(hir::Literal::Byte(65)); // ASCII 'A'",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Byte(65));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(writer.visit_pre(&hir).unwrap(), ());"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Byte(65));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"A\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Byte(65)); // ASCII 'A'",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Byte(65));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(writer.visit_pre(&hir).unwrap(), ());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Byte(65)); // ASCII 'A'",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Byte(65));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"A\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
          "    let hir = Hir::class(hir::Class::Bytes(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    assert_eq!(output, \"(?-u:[\\\\x00-\\\\xFF])\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    assert_eq!(output, \"[a-z]\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    assert!(writer.visit_pre(&hir_empty).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    assert!(writer.visit_pre(&hir_repetition).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    assert!(writer.visit_pre(&hir_concat).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    assert!(writer.visit_pre(&hir_alternation).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    assert!(writer.visit_pre(&hir_literal_unicode).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    assert_eq!(output, \"a\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    assert!(writer.visit_pre(&hir_literal_byte).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    assert_eq!(output, \"\\\\x00\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    assert!(writer.visit_pre(&hir_anchor_start_line).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    assert_eq!(output, \"(?m:^)\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    assert!(writer.visit_pre(&hir_anchor_end_line).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    assert_eq!(output, \"(?m:$)\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    assert!(writer.visit_pre(&hir_anchor_start_text).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    assert_eq!(output, r\"\\A\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    assert!(writer.visit_pre(&hir_anchor_end_text).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    assert_eq!(output, r\"\\z\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    assert!(writer.visit_pre(&hir_word_boundary_unicode).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    assert_eq!(output, r\"\\b\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    assert!(writer.visit_pre(&hir_group_capture_index).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    assert_eq!(output, \"(\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    assert!(writer.visit_pre(&hir_group_capture_name).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    assert_eq!(output, \"(?P<group>\");"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    let group_non_capturing = hir::Group::new(hir::GroupKind::NonCapturing, Box::new(hir.clone()));",
            "    let hir_group_non_capturing = Hir::group(group_non_capturing);",
            "    assert!(writer.visit_pre(&hir_group_non_capturing).is_ok());"
          ],
          [
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    let group_non_capturing = hir::Group::new(hir::GroupKind::NonCapturing, Box::new(hir.clone()));",
            "    let hir_group_non_capturing = Hir::group(group_non_capturing);",
            "    assert_eq!(output, \"(?:\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    assert_eq!(output, \"(?-u:[\\\\x00-\\\\xFF])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    assert_eq!(output, \"[a-z]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    assert!(writer.visit_pre(&hir_empty).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    assert!(writer.visit_pre(&hir_repetition).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    assert!(writer.visit_pre(&hir_concat).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    assert!(writer.visit_pre(&hir_alternation).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    assert!(writer.visit_pre(&hir_literal_unicode).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    assert_eq!(output, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    assert!(writer.visit_pre(&hir_literal_byte).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    assert_eq!(output, \"\\\\x00\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    assert!(writer.visit_pre(&hir_anchor_start_line).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    assert_eq!(output, \"(?m:^)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    assert!(writer.visit_pre(&hir_anchor_end_line).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    assert_eq!(output, \"(?m:$)\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    assert!(writer.visit_pre(&hir_anchor_start_text).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    assert_eq!(output, r\"\\A\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    assert!(writer.visit_pre(&hir_anchor_end_text).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    assert_eq!(output, r\"\\z\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    assert!(writer.visit_pre(&hir_word_boundary_unicode).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    assert_eq!(output, r\"\\b\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    assert!(writer.visit_pre(&hir_group_capture_index).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    assert_eq!(output, \"(\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    assert!(writer.visit_pre(&hir_group_capture_name).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    assert_eq!(output, \"(?P<group>\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    let group_non_capturing = hir::Group::new(hir::GroupKind::NonCapturing, Box::new(hir.clone()));",
            "    let hir_group_non_capturing = Hir::group(group_non_capturing);",
            "    assert!(writer.visit_pre(&hir_group_non_capturing).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls = ClassBytes::new(vec![ClassBytesRange::new(0, 255)]);",
            "    let hir = Hir::class(hir::Class::Bytes(cls));",
            "    let cls_unicode = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'z')]);",
            "    let hir_unicode = Hir::class(hir::Class::Unicode(cls_unicode));",
            "    let hir_empty = Hir::empty();",
            "    let hir_repetition = Hir::repetition(hir::Repetition::new(hir.clone(), hir::RepetitionKind::ZeroOrMore));",
            "    let hir_concat = Hir::concat(vec![hir.clone(), hir_empty]);",
            "    let hir_alternation = Hir::alternation(vec![hir.clone(), hir_empty]);",
            "    let lit_unicode = hir::Literal::Unicode('a');",
            "    let hir_literal_unicode = Hir::literal(lit_unicode);",
            "    let lit_byte = hir::Literal::Byte(0);",
            "    let hir_literal_byte = Hir::literal(lit_byte);",
            "    let anchor_start_line = hir::Anchor::StartLine;",
            "    let hir_anchor_start_line = Hir::anchor(anchor_start_line);",
            "    let anchor_end_line = hir::Anchor::EndLine;",
            "    let hir_anchor_end_line = Hir::anchor(anchor_end_line);",
            "    let anchor_start_text = hir::Anchor::StartText;",
            "    let hir_anchor_start_text = Hir::anchor(anchor_start_text);",
            "    let anchor_end_text = hir::Anchor::EndText;",
            "    let hir_anchor_end_text = Hir::anchor(anchor_end_text);",
            "    let word_boundary_unicode = hir::WordBoundary::Unicode;",
            "    let hir_word_boundary_unicode = Hir::word_boundary(word_boundary_unicode);",
            "    let group_capture_index = hir::Group::new(hir::GroupKind::CaptureIndex(1), Box::new(hir.clone()));",
            "    let hir_group_capture_index = Hir::group(group_capture_index);",
            "    let group_capture_name = hir::Group::new(hir::GroupKind::CaptureName { name: \"group\".to_string(), index: 0 }, Box::new(hir.clone()));",
            "    let hir_group_capture_name = Hir::group(group_capture_name);",
            "    let group_non_capturing = hir::Group::new(hir::GroupKind::NonCapturing, Box::new(hir.clone()));",
            "    let hir_group_non_capturing = Hir::group(group_non_capturing);",
            "    assert_eq!(output, \"(?:\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
          "    let hir = Hir::class(hir::Class::Unicode(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"[a]\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(0b00000001, 0b00000001)]);",
            "    let hir_bytes = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    let mut output_bytes = String::new();",
            "    let mut writer_bytes = Writer { printer: &mut printer, wtr: &mut output_bytes };",
            "    writer_bytes.visit_pre(&hir_bytes).unwrap();",
            "    assert_eq!(output_bytes, \"(?-u:[\\x01])\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(0b00000001, 0b00000001)]);",
            "    let hir_bytes = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    let mut output_bytes = String::new();",
            "    let mut writer_bytes = Writer { printer: &mut printer, wtr: &mut output_bytes };",
            "    writer_bytes.visit_pre(&hir_bytes).unwrap();",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('a'));",
            "    let mut output_literal = String::new();",
            "    let mut writer_literal = Writer { printer: &mut printer, wtr: &mut output_literal };",
            "    writer_literal.visit_pre(&unicode_literal).unwrap();",
            "    assert_eq!(output_literal, \"a\");"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(0b00000001, 0b00000001)]);",
            "    let hir_bytes = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    let mut output_bytes = String::new();",
            "    let mut writer_bytes = Writer { printer: &mut printer, wtr: &mut output_bytes };",
            "    writer_bytes.visit_pre(&hir_bytes).unwrap();",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('a'));",
            "    let mut output_literal = String::new();",
            "    let mut writer_literal = Writer { printer: &mut printer, wtr: &mut output_literal };",
            "    writer_literal.visit_pre(&unicode_literal).unwrap();",
            "    let byte_literal = Hir::literal(hir::Literal::Byte(0b00000001));",
            "    let mut output_byte_literal = String::new();",
            "    let mut writer_byte_literal = Writer { printer: &mut printer, wtr: &mut output_byte_literal };",
            "    writer_byte_literal.visit_pre(&byte_literal).unwrap();",
            "    assert_eq!(output_byte_literal, \"\\x01\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    assert_eq!(output, \"[a]\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(0b00000001, 0b00000001)]);",
            "    let hir_bytes = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    let mut output_bytes = String::new();",
            "    let mut writer_bytes = Writer { printer: &mut printer, wtr: &mut output_bytes };",
            "    writer_bytes.visit_pre(&hir_bytes).unwrap();",
            "    assert_eq!(output_bytes, \"(?-u:[\\x01])\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(0b00000001, 0b00000001)]);",
            "    let hir_bytes = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    let mut output_bytes = String::new();",
            "    let mut writer_bytes = Writer { printer: &mut printer, wtr: &mut output_bytes };",
            "    writer_bytes.visit_pre(&hir_bytes).unwrap();",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('a'));",
            "    let mut output_literal = String::new();",
            "    let mut writer_literal = Writer { printer: &mut printer, wtr: &mut output_literal };",
            "    writer_literal.visit_pre(&unicode_literal).unwrap();",
            "    assert_eq!(output_literal, \"a\");",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'a')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    writer.visit_pre(&hir).unwrap();",
            "    let cls_bytes = ClassBytes::new(vec![ClassBytesRange::new(0b00000001, 0b00000001)]);",
            "    let hir_bytes = Hir::class(hir::Class::Bytes(cls_bytes));",
            "    let mut output_bytes = String::new();",
            "    let mut writer_bytes = Writer { printer: &mut printer, wtr: &mut output_bytes };",
            "    writer_bytes.visit_pre(&hir_bytes).unwrap();",
            "    let unicode_literal = Hir::literal(hir::Literal::Unicode('a'));",
            "    let mut output_literal = String::new();",
            "    let mut writer_literal = Writer { printer: &mut printer, wtr: &mut output_literal };",
            "    writer_literal.visit_pre(&unicode_literal).unwrap();",
            "    let byte_literal = Hir::literal(hir::Literal::Byte(0b00000001));",
            "    let mut output_byte_literal = String::new();",
            "    let mut writer_byte_literal = Writer { printer: &mut printer, wtr: &mut output_byte_literal };",
            "    writer_byte_literal.visit_pre(&byte_literal).unwrap();",
            "    assert_eq!(output_byte_literal, \"\\x01\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let hir = Hir::literal(hir::Literal::Unicode(''));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Unicode(''));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Unicode(''));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let hir = Hir::literal(hir::Literal::Unicode(''));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut output = String::new();",
          "    let mut printer = Printer { _priv: () };",
          "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
          "    let hir = Hir::class(hir::Class::Unicode(cls));",
          "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
          "",
          "    writer.visit_pre(&hir).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(writer.visit_pre(&hir).is_ok(), true);"
          ],
          [
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"[a-b]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(writer.visit_pre(&hir).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "",
            "    writer.visit_pre(&hir).unwrap();",
            "    let mut output = String::new();",
            "    let mut printer = Printer { _priv: () };",
            "    let cls = ClassUnicode::new(vec![ClassUnicodeRange::new('a', 'b')]);",
            "    let hir = Hir::class(hir::Class::Unicode(cls));",
            "    let mut writer = Writer { printer: &mut printer, wtr: &mut output };",
            "    assert_eq!(output, \"[a-b]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]