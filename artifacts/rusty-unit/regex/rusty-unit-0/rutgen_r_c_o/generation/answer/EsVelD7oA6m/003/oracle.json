[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let inputs = vec![",
          "        '\\u{0080}', // U+0080",
          "        '\\u{00A0}', // U+00A0",
          "        '\\u{2000}', // U+2000",
          "        '\\u{3000}', // U+3000",
          "        '\\u{4E00}', // U+4E00",
          "        '\\u{1F600}', // U+1F600",
          "        '\\u{10FFFF}', // U+10FFFF",
          "    ];",
          "    for c in inputs {",
          "        is_word_character(c);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(!is_word_character('\\u{0080}'));"
          ],
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{00A0}'));"
          ],
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{2000}'));"
          ],
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{3000}'));"
          ],
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{4E00}'));"
          ],
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{1F600}'));"
          ],
          [
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{10FFFF}'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(!is_word_character('\\u{0080}'));",
            "}"
          ],
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{00A0}'));",
            "}"
          ],
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{2000}'));",
            "}"
          ],
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{3000}'));",
            "}"
          ],
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{4E00}'));",
            "}"
          ],
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{1F600}'));",
            "}"
          ],
          [
            "{",
            "    let inputs = vec![",
            "        '\\u{0080}', // U+0080",
            "        '\\u{00A0}', // U+00A0",
            "        '\\u{2000}', // U+2000",
            "        '\\u{3000}', // U+3000",
            "        '\\u{4E00}', // U+4E00",
            "        '\\u{1F600}', // U+1F600",
            "        '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    for c in inputs {",
            "        is_word_character(c);",
            "    }",
            "    let inputs = vec![",
            "    '\\u{0080}', // U+0080",
            "    '\\u{00A0}', // U+00A0",
            "    '\\u{2000}', // U+2000",
            "    '\\u{3000}', // U+3000",
            "    '\\u{4E00}', // U+4E00",
            "    '\\u{1F600}', // U+1F600",
            "    '\\u{10FFFF}', // U+10FFFF",
            "    ];",
            "    assert!(is_word_character('\\u{10FFFF}'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let edge_cases = vec![",
          "        '\\u{FFFF}', // U+FFFF - last 2-byte character",
          "        '\\u{10100}', // U+10100 - first character in supplementary planes",
          "        '\\u{1FFFF}', // U+1FFFF - near the upper limit of 2 bytes",
          "        '\\u{10FFFF}', // U+10FFFF - maximum valid Unicode character",
          "    ];",
          "    for c in edge_cases {",
          "        is_word_character(c);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{FFFF}'));"
          ],
          [
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{10100}'));"
          ],
          [
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{1FFFF}'));"
          ],
          [
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{10FFFF}'));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let edge_cases = vec![",
            "        '\\u{FFFF}', // U+FFFF - last 2-byte character",
            "        '\\u{10100}', // U+10100 - first character in supplementary planes",
            "        '\\u{1FFFF}', // U+1FFFF - near the upper limit of 2 bytes",
            "        '\\u{10FFFF}', // U+10FFFF - maximum valid Unicode character",
            "    ];",
            "    for c in edge_cases {",
            "        is_word_character(c);",
            "    }",
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{FFFF}'));",
            "}"
          ],
          [
            "{",
            "    let edge_cases = vec![",
            "        '\\u{FFFF}', // U+FFFF - last 2-byte character",
            "        '\\u{10100}', // U+10100 - first character in supplementary planes",
            "        '\\u{1FFFF}', // U+1FFFF - near the upper limit of 2 bytes",
            "        '\\u{10FFFF}', // U+10FFFF - maximum valid Unicode character",
            "    ];",
            "    for c in edge_cases {",
            "        is_word_character(c);",
            "    }",
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{10100}'));",
            "}"
          ],
          [
            "{",
            "    let edge_cases = vec![",
            "        '\\u{FFFF}', // U+FFFF - last 2-byte character",
            "        '\\u{10100}', // U+10100 - first character in supplementary planes",
            "        '\\u{1FFFF}', // U+1FFFF - near the upper limit of 2 bytes",
            "        '\\u{10FFFF}', // U+10FFFF - maximum valid Unicode character",
            "    ];",
            "    for c in edge_cases {",
            "        is_word_character(c);",
            "    }",
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{1FFFF}'));",
            "}"
          ],
          [
            "{",
            "    let edge_cases = vec![",
            "        '\\u{FFFF}', // U+FFFF - last 2-byte character",
            "        '\\u{10100}', // U+10100 - first character in supplementary planes",
            "        '\\u{1FFFF}', // U+1FFFF - near the upper limit of 2 bytes",
            "        '\\u{10FFFF}', // U+10FFFF - maximum valid Unicode character",
            "    ];",
            "    for c in edge_cases {",
            "        is_word_character(c);",
            "    }",
            "    let edge_cases = vec!['\\u{FFFF}', '\\u{10100}', '\\u{1FFFF}', '\\u{10FFFF}'];",
            "    assert!(!is_word_character('\\u{10FFFF}'));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]