[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[a-z]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union), Ok(Either::Right(class)));"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union), Ok(Either::Left(nested_union)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union), Ok(Either::Right(class)));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union), Ok(Either::Left(nested_union)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[[a-z]-[0-9]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    assert!(parser.char() == ']');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    let union_result = parser.pop_class(union);",
            "    assert!(matches!(union_result, Either::Right(class)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    assert!(parser.char() == ']');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[a-z]-[0-9]]\",",
            "    };",
            "    let union_result = parser.pop_class(union);",
            "    assert!(matches!(union_result, Either::Right(class)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[a-z&&[b-d]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.pop_class(union).is_ok());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.pop_class(union).unwrap() matches Either::Right(class);"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert_eq!(parser.stack_class.borrow().is_empty(), false);"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert_eq!(parser.stack_class.borrow().len(), expected_length);"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.peek() == Some(']'));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.pattern.contains(\"a-z&&[b-d]\"));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.bump_if(\"&&\"));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.pop_class(union).is_ok());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.pop_class(union).unwrap() matches Either::Right(class);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert_eq!(parser.stack_class.borrow().is_empty(), false);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert_eq!(parser.stack_class.borrow().len(), expected_length);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.peek() == Some(']'));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.pattern.contains(\"a-z&&[b-d]\"));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z&&[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z&&[b-d]]\" };",
            "    assert!(parser.bump_if(\"&&\"));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[a-z--[c-e]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.pop_class(union).is_ok());"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union).unwrap(), Either::Right(_)));"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union).unwrap(), Either::Left(_)));"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.char() == ']');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert_eq!(parser.pattern, \"[a-z--[c-e]]\");"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.bump_space().is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.pop_class(union).is_ok());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union).unwrap(), Either::Right(_)));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(matches!(parser.pop_class(union).unwrap(), Either::Left(_)));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.char() == ']');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert_eq!(parser.pattern, \"[a-z--[c-e]]\");",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-z--[c-e]]\",",
            "    };",
            "    assert!(parser.bump_space().is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[a-z~~[b-d]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    assert_eq!(parser.peek(), Some(']'));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    let union = parser.parse_set_class().unwrap();",
            "    assert!(matches!(union, ast::ClassSet::Bracketed(..)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z~~[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z~~[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z~~[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    assert_eq!(parser.peek(), Some(']'));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-z~~[b-d]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[a-z~~[b-d]]\" };",
            "    let union = parser.parse_set_class().unwrap();",
            "    assert!(matches!(union, ast::ClassSet::Bracketed(..)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.is_eof() == false);"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert_eq!(parser.char(), ']');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert_eq!(parser.pop_class(parser.union).unwrap(), Either::Right(Class::Bracketed(...));"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert_eq!(parser.pop_class(parser.union).unwrap(), Either::Left(nested_union);"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.pop_class(parser.union).is_ok());"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.char() == ']');"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.pattern == \"[]]\");"
          ],
          [
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.stack_class.borrow().is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.is_eof() == false);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert_eq!(parser.char(), ']');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert_eq!(parser.pop_class(parser.union).unwrap(), Either::Right(Class::Bracketed(...));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert_eq!(parser.pop_class(parser.union).unwrap(), Either::Left(nested_union);",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.pop_class(parser.union).is_ok());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.char() == ']');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.pattern == \"[]]\");",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI { parser: Parser::new(), pattern: \"[]]\" };",
            "    assert!(parser.stack_class.borrow().is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[[:alpha:]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    let initial_union = parser.push_class_open(ast::ClassSetUnion { span: parser.span(), items: vec![] }).unwrap();",
            "    let nested_union = parser.maybe_parse_ascii_class().unwrap();",
            "    assert!(initial_union.items.is_empty());"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    let initial_union = parser.push_class_open(ast::ClassSetUnion { span: parser.span(), items: vec![] }).unwrap();",
            "    let nested_union = parser.maybe_parse_ascii_class().unwrap();",
            "    assert!(matches!(parser.pop_class(initial_union), Ok(Either::Right(class)));"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    let initial_union = parser.push_class_open(ast::ClassSetUnion { span: parser.span(), items: vec![] }).unwrap();",
            "    let nested_union = parser.maybe_parse_ascii_class().unwrap();",
            "    assert!(matches!(parser.pop_class(initial_union), Ok(Either::Left(nested_union)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[:alpha:]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[:alpha:]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[:alpha:]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    let initial_union = parser.push_class_open(ast::ClassSetUnion { span: parser.span(), items: vec![] }).unwrap();",
            "    let nested_union = parser.maybe_parse_ascii_class().unwrap();",
            "    assert!(initial_union.items.is_empty());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[:alpha:]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    let initial_union = parser.push_class_open(ast::ClassSetUnion { span: parser.span(), items: vec![] }).unwrap();",
            "    let nested_union = parser.maybe_parse_ascii_class().unwrap();",
            "    assert!(matches!(parser.pop_class(initial_union), Ok(Either::Right(class)));",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[[:alpha:]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[[:alpha:]]\",",
            "    };",
            "    let initial_union = parser.push_class_open(ast::ClassSetUnion { span: parser.span(), items: vec![] }).unwrap();",
            "    let nested_union = parser.maybe_parse_ascii_class().unwrap();",
            "    assert!(matches!(parser.pop_class(initial_union), Ok(Either::Left(nested_union)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let parser = ParserI {",
          "        parser: Parser::new(),",
          "        pattern: \"[a-zA-Z0-9&&[a-f]]\",",
          "    };",
          "    parser.parse_set_class();",
          "}"
        ],
        "oracles": [
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    assert!(!parser.is_eof());"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    assert!(parser.char() == ']');"
          ],
          [
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    let result = parser.pop_class(union);",
            "    assert!(matches!(result, Either::Right(class)) || matches!(result, Either::Left(nested_union));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    assert_eq!(parser.char(), '[');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    assert!(!parser.is_eof());",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    assert!(parser.char() == ']');",
            "}"
          ],
          [
            "{",
            "    let parser = ParserI {",
            "        parser: Parser::new(),",
            "        pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    parser.parse_set_class();",
            "    let parser = ParserI {",
            "    parser: Parser::new(),",
            "    pattern: \"[a-zA-Z0-9&&[a-f]]\",",
            "    };",
            "    let result = parser.pop_class(union);",
            "    assert!(matches!(result, Either::Right(class)) || matches!(result, Either::Left(nested_union));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]