[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let ast = ast::ClassSetItem::Empty(Span::default());",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert_eq!(writer.wtr, \"a-z\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\pb\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert_eq!(writer.wtr, \"a-z\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\pb\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Empty(Span::default());",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let ast = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false });",
            "    let ast = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('b') });",
            "    let ast = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Normal }));",
            "    assert_eq!(writer.wtr, \"a-z[:alnum:]\\\\D]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
          "    let ast = ast::ClassSetItem::Literal(literal);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
            "    assert_eq!(writer.visit_class_set_item_post(&ast), Err(fmt::Error));"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
            "    let result = writer.wtr;",
            "    assert_eq!(result, \"\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
            "    let result = writer.wtr;",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal, end: literal });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Literal(literal);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
            "    assert_eq!(writer.visit_class_set_item_post(&ast), Err(fmt::Error));",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Literal(literal);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
            "    let result = writer.wtr;",
            "    assert_eq!(result, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Literal(literal);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal.clone(), end: literal.clone() });",
            "    let result = writer.wtr;",
            "    let ast = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: literal, end: literal });",
            "    assert!(writer.visit_class_set_item_post(&ast).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
          "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
          "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
          "    let ast = ast::ClassSetItem::Range(range);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    assert!(writer.visit_class_set_item_post(&ast).is_err());"
          ],
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    assert_eq!(writer.wtr, \"\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    assert!(writer.visit_class_set_item_post(&ast).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    assert_eq!(writer.wtr, \"\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '每' }; // valid but non-integer",
          "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
          "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
          "    let ast = ast::ClassSetItem::Range(range);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '每' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    assert!(writer.visit_class_set_item_post(&ast).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '每' }; // valid but non-integer",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: '每' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let ast = ast::ClassSetItem::Range(range);",
            "    assert!(writer.visit_class_set_item_post(&ast).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
          "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert!(writer.wtr == \"a-z\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_empty).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_union).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_literal).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    assert!(writer.wtr == \"x\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_ascii).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    assert!(writer.wtr == \"[:alpha:]\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_unicode).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    assert!(writer.wtr == r\"\\pA\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_perl).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert!(writer.wtr == r\"\\D\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_bracketed).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    assert!(writer.wtr == \"]\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    assert!(writer.wtr == \"a-z\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_empty).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_union).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_literal).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    assert!(writer.wtr == \"x\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_ascii).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    assert!(writer.wtr == \"[:alpha:]\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_unicode).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    assert!(writer.wtr == r\"\\pA\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_perl).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    assert!(writer.wtr == r\"\\D\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    assert!(writer.visit_class_set_item_post(&class_set_item_bracketed).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alnum, negated: false };",
            "    let ast = ast::ClassSetItem::Ascii(class_ascii);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } });",
            "    let class_set_item_empty = ast::ClassSetItem::Empty(Span::default());",
            "    let class_set_item_union = ast::ClassSetItem::Union(ClassSetUnion {});",
            "    let class_set_item_literal = ast::ClassSetItem::Literal(Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'x' });",
            "    let class_set_item_ascii = ast::ClassSetItem::Ascii(ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false });",
            "    let class_set_item_unicode = ast::ClassSetItem::Unicode(ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('A') });",
            "    let class_set_item_perl = ast::ClassSetItem::Perl(ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: true });",
            "    let class_set_item_bracketed = ast::ClassSetItem::Bracketed(Box::new(ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) }));",
            "    assert!(writer.wtr == \"]\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('位') };",
          "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert!(result.is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert_eq!(writer.wtr, \"a-z\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert_eq!(printer, Printer { _priv: () });"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert!(writer.wtr.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('位') };",
            "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('位') };",
            "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert_eq!(writer.wtr, \"a-z\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('位') };",
            "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert_eq!(printer, Printer { _priv: () });",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('位') };",
            "    let ast = ast::ClassSetItem::Unicode(class_unicode);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_range = ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'z' } };",
            "    let ast = ast::ClassSetItem::Range(class_range);",
            "    let result = writer.visit_class_set_item_post(&ast);",
            "    assert!(writer.wtr.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
          "    let ast = ast::ClassSetItem::Perl(class_perl);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = ast::ClassSetItem::Perl(class_perl);",
            "    assert_eq!(writer.wtr, r\"\\d\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = ast::ClassSetItem::Perl(class_perl);",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = ast::ClassSetItem::Perl(class_perl);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = ast::ClassSetItem::Perl(class_perl);",
            "    assert_eq!(writer.wtr, r\"\\d\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = ast::ClassSetItem::Perl(class_perl);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let ast = ast::ClassSetItem::Perl(class_perl);",
            "    assert!(writer.visit_class_set_item_post(&ast).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
          "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item).is_err());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    assert_eq!(writer.wtr, \"\");"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());"
          ],
          [
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
            "    assert_eq!(writer.wtr, \"A-Z\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item).is_err());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    assert_eq!(writer.wtr, \"\");",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
            "    assert!(writer.visit_class_set_item_post(&class_set_item).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::NormalUnion(vec![]) };",
            "    let ast = ast::ClassSetItem::Bracketed(Box::new(class_bracketed));",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'a' }, end: Literal { span: Span::default(), kind: LiteralKind::Punctuation, c: 'z' } });",
            "    let class_set_item = ast::ClassSetItem::Range(ClassSetRange { span: Span::default(), start: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'A' }, end: Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'Z' } });",
            "    assert_eq!(writer.wtr, \"A-Z\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut printer = Printer { _priv: () };",
          "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
          "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
          "    let ast = ast::ClassSetItem::Union(class_union);",
          "    writer.visit_class_set_item_post(&ast).unwrap();",
          "}"
        ],
        "oracles": [
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    assert!(writer.visit_class_set_item_post(&class_empty).is_ok());"
          ],
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    assert_eq!(writer.visit_class_set_item_post(&class_literal).is_ok(), true);"
          ],
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    assert!(writer.visit_class_set_item_post(&class_range).is_ok());"
          ],
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    assert!(writer.visit_class_set_item_post(&class_ascii).is_ok());"
          ],
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let class_unicode = ClassSetItem::Unicode(unicode);",
            "    assert!(writer.visit_class_set_item_post(&class_unicode).is_ok());"
          ],
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let class_unicode = ClassSetItem::Unicode(unicode);",
            "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let class_perl = ClassSetItem::Perl(perl);",
            "    assert!(writer.visit_class_set_item_post(&class_perl).is_ok());"
          ],
          [
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let class_unicode = ClassSetItem::Unicode(unicode);",
            "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let class_perl = ClassSetItem::Perl(perl);",
            "    let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };",
            "    let class_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
            "    assert!(writer.visit_class_set_item_post(&class_bracketed).is_ok());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    assert!(writer.visit_class_set_item_post(&class_empty).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    assert_eq!(writer.visit_class_set_item_post(&class_literal).is_ok(), true);",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    assert!(writer.visit_class_set_item_post(&class_range).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    assert!(writer.visit_class_set_item_post(&class_ascii).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let class_unicode = ClassSetItem::Unicode(unicode);",
            "    assert!(writer.visit_class_set_item_post(&class_unicode).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let class_unicode = ClassSetItem::Unicode(unicode);",
            "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let class_perl = ClassSetItem::Perl(perl);",
            "    assert!(writer.visit_class_set_item_post(&class_perl).is_ok());",
            "}"
          ],
          [
            "{",
            "    let mut printer = Printer { _priv: () };",
            "    let mut writer = Writer { printer: &mut printer, wtr: String::new() };",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_union = ClassSetUnion { span: Span::default(), items: vec![] };",
            "    let ast = ast::ClassSetItem::Union(class_union);",
            "    writer.visit_class_set_item_post(&ast).unwrap();",
            "    let class_empty = ClassSetItem::Empty(Span::default());",
            "    let literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let class_literal = ClassSetItem::Literal(literal);",
            "    let start_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'a' };",
            "    let end_literal = Literal { span: Span::default(), kind: LiteralKind::Verbatim, c: 'b' };",
            "    let range = ClassSetRange { span: Span::default(), start: start_literal, end: end_literal };",
            "    let class_range = ClassSetItem::Range(range);",
            "    let ascii = ClassAscii { span: Span::default(), kind: ClassAsciiKind::Alpha, negated: false };",
            "    let class_ascii = ClassSetItem::Ascii(ascii);",
            "    let unicode = ClassUnicode { span: Span::default(), negated: false, kind: ClassUnicodeKind::OneLetter('c') };",
            "    let class_unicode = ClassSetItem::Unicode(unicode);",
            "    let perl = ClassPerl { span: Span::default(), kind: ClassPerlKind::Digit, negated: false };",
            "    let class_perl = ClassSetItem::Perl(perl);",
            "    let bracketed = ClassBracketed { span: Span::default(), negated: false, kind: ClassSet::Union(vec![]) };",
            "    let class_bracketed = ClassSetItem::Bracketed(Box::new(bracketed));",
            "    assert!(writer.visit_class_set_item_post(&class_bracketed).is_ok());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]