[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
          "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
          "    ",
          "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
          "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
          "",
          "    let parser = Parser { /* initialize parser state */ };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
          "",
          "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
          "    parser_i.is_eof = || false;",
          "    parser_i.char = || '-';",
          "    parser_i.peek_space = || Some(']');",
          "",
          "    parser_i.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
            "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
            "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    let class_set_item = result.unwrap();",
            "    assert_eq!(class_set_item, ast::ClassSetItem::Range(ast::ClassSetRange {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
            "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'a' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'b' });",
            "    let parser_i = ParserI { parser: &parser, pattern: \"a-b\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    let class_set_item = result.unwrap();",
            "    assert_eq!(class_set_item, ast::ClassSetItem::Range(ast::ClassSetRange {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
          "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
          "    ",
          "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
          "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
          "",
          "    let parser = Parser { /* initialize parser state */ };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"c-d\" };",
          "",
          "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
          "    parser_i.is_eof = || false;",
          "    parser_i.char = || '-';",
          "    parser_i.peek_space = || Some(']');",
          "",
          "    parser_i.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert_eq!(parser_i.parse_set_class_item(), Ok(prim1.clone()));"
          ],
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert!(!parser_i.is_eof());"
          ],
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert_eq!(parser_i.char(), '-');"
          ],
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert_eq!(parser_i.peek_space(), Some(']'));"
          ],
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let result = parser_i.parse_set_class_range();",
            "    let expected_range = ast::ClassSetRange {",
            "    span: Span::new(span1.start, span2.end),",
            "    start: prim1.into_class_literal(&parser_i).unwrap(),",
            "    end: prim2.into_class_literal(&parser_i).unwrap(),",
            "    };",
            "    assert_eq!(result, Ok(ast::ClassSetItem::Range(expected_range)));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"c-d\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert_eq!(parser_i.parse_set_class_item(), Ok(prim1.clone()));",
            "}"
          ],
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"c-d\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert!(!parser_i.is_eof());",
            "}"
          ],
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"c-d\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert_eq!(parser_i.char(), '-');",
            "}"
          ],
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"c-d\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    assert_eq!(parser_i.peek_space(), Some(']'));",
            "}"
          ],
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"c-d\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 2, line: 1, column: 3 }, Position { offset: 3, line: 1, column: 4 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let result = parser_i.parse_set_class_range();",
            "    let expected_range = ast::ClassSetRange {",
            "    span: Span::new(span1.start, span2.end),",
            "    start: prim1.into_class_literal(&parser_i).unwrap(),",
            "    end: prim2.into_class_literal(&parser_i).unwrap(),",
            "    };",
            "    assert_eq!(result, Ok(ast::ClassSetItem::Range(expected_range)));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
          "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
          "    ",
          "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
          "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
          "",
          "    let parser = Parser { /* initialize parser state */ };",
          "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
          "",
          "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
          "    parser_i.is_eof = || false;",
          "    parser_i.char = || '-';",
          "    parser_i.peek_space = || Some(']');",
          "",
          "    parser_i.parse_set_class_range();",
          "}"
        ],
        "oracles": [
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    assert!(result.is_ok());"
          ],
          [
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    let class_set_item = result.unwrap();",
            "    assert_eq!(class_set_item, ast::ClassSetItem::Range(ast::ClassSetRange { span: Span::new(span1.start, span2.end), start: prim1.into_class_literal(&parser_i).unwrap(), end: prim2.into_class_literal(&parser_i).unwrap() }));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    assert!(result.is_ok());",
            "}"
          ],
          [
            "{",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
            "    ",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
            "",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "",
            "    parser_i.parse_set_class_range();",
            "    let span1 = Span::new(Position { offset: 0, line: 1, column: 1 }, Position { offset: 1, line: 1, column: 2 });",
            "    let span2 = Span::new(Position { offset: 3, line: 1, column: 4 }, Position { offset: 2, line: 1, column: 3 });",
            "    let prim1 = Primitive::Literal(Literal { span: span1.clone(), kind: ast::LiteralKind::Verbatim, c: 'd' });",
            "    let prim2 = Primitive::Literal(Literal { span: span2.clone(), kind: ast::LiteralKind::Verbatim, c: 'c' });",
            "    let parser = Parser { /* initialize parser state */ };",
            "    let parser_i = ParserI { parser: &parser, pattern: \"d-c\" };",
            "    parser_i.parse_set_class_item = || Ok(prim1.clone());",
            "    parser_i.is_eof = || false;",
            "    parser_i.char = || '-';",
            "    parser_i.peek_space = || Some(']');",
            "    let result = parser_i.parse_set_class_range();",
            "    let class_set_item = result.unwrap();",
            "    assert_eq!(class_set_item, ast::ClassSetItem::Range(ast::ClassSetRange { span: Span::new(span1.start, span2.end), start: prim1.into_class_literal(&parser_i).unwrap(), end: prim2.into_class_literal(&parser_i).unwrap() }));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]