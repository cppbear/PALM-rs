{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/dfa.rs\n// crate name is regex\ntype InstPtr = u32;\ntype StatePtr = u32;\nuse std::collections::HashMap;\nuse std::fmt;\nuse std::iter::repeat;\nuse std::mem;\nuse exec::ProgramCache;\nuse prog::{Inst, Program};\nuse sparse::SparseSet;\nconst STATE_UNKNOWN: StatePtr = 1 << 31;\nconst STATE_DEAD: StatePtr = STATE_UNKNOWN + 1;\nconst STATE_QUIT: StatePtr = STATE_DEAD + 1;\nconst STATE_START: StatePtr = 1 << 30;\nconst STATE_MATCH: StatePtr = 1 << 29;\nconst STATE_MAX: StatePtr = STATE_MATCH - 1;\n#[derive(Clone, Debug)]\nstruct CacheInner {\n    /// A cache of pre-compiled DFA states, keyed by the set of NFA states\n    /// and the set of empty-width flags set at the byte in the input when the\n    /// state was observed.\n    ///\n    /// A StatePtr is effectively a `*State`, but to avoid various inconvenient\n    /// things, we just pass indexes around manually. The performance impact of\n    /// this is probably an instruction or two in the inner loop. However, on\n    /// 64 bit, each StatePtr is half the size of a *State.\n    compiled: HashMap<State, StatePtr>,\n    /// The transition table.\n    ///\n    /// The transition table is laid out in row-major order, where states are\n    /// rows and the transitions for each state are columns. At a high level,\n    /// given state `s` and byte `b`, the next state can be found at index\n    /// `s * 256 + b`.\n    ///\n    /// This is, of course, a lie. A StatePtr is actually a pointer to the\n    /// *start* of a row in this table. When indexing in the DFA's inner loop,\n    /// this removes the need to multiply the StatePtr by the stride. Yes, it\n    /// matters. This reduces the number of states we can store, but: the\n    /// stride is rarely 256 since we define transitions in terms of\n    /// *equivalence classes* of bytes. Each class corresponds to a set of\n    /// bytes that never discriminate a distinct path through the DFA from each\n    /// other.\n    trans: Transitions,\n    /// Our set of states. Note that `StatePtr / num_byte_classes` indexes\n    /// this Vec rather than just a `StatePtr`.\n    states: Vec<State>,\n    /// A set of cached start states, which are limited to the number of\n    /// permutations of flags set just before the initial byte of input. (The\n    /// index into this vec is a `EmptyFlags`.)\n    ///\n    /// N.B. A start state can be \"dead\" (i.e., no possible match), so we\n    /// represent it with a StatePtr.\n    start_states: Vec<StatePtr>,\n    /// Stack scratch space used to follow epsilon transitions in the NFA.\n    /// (This permits us to avoid recursion.)\n    ///\n    /// The maximum stack size is the number of NFA states.\n    stack: Vec<InstPtr>,\n    /// The total number of times this cache has been flushed by the DFA\n    /// because of space constraints.\n    flush_count: u64,\n    /// The total heap size of the DFA's cache. We use this to determine when\n    /// we should flush the cache.\n    size: usize,\n}\n#[derive(Clone)]\nstruct Transitions {\n    /// The table.\n    table: Vec<StatePtr>,\n    /// The stride.\n    num_byte_classes: usize,\n}\n#[derive(Clone, Eq, Hash, PartialEq)]\nstruct State {\n    data: Box<[u8]>,\n}\nimpl CacheInner {\n    fn reset_size(&mut self) {\n        self.size = (self.start_states.len() * mem::size_of::<StatePtr>())\n            + (self.stack.len() * mem::size_of::<InstPtr>());\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Resets the cache size to account for fixed costs, such as the program\n/// and stack sizes.\nfn reset_size(&mut self) {\n    self.size =\n        (self.start_states.len() * mem::size_of::<StatePtr>())\n        + (self.stack.len() * mem::size_of::<InstPtr>());\n}\n",
  "depend_pt": ""
}