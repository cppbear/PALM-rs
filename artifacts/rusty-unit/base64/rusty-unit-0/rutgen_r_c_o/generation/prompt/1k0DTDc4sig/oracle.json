{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/alphabet.rs\n// crate name is base64\nuse crate::PAD_BYTE;\nuse core::{convert, fmt};\n#[cfg(any(feature = \"std\", test))]\nuse std::error;\nconst ALPHABET_SIZE: usize = 64;\npub const STANDARD: Alphabet = Alphabet::from_str_unchecked(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",\n);\npub const URL_SAFE: Alphabet = Alphabet::from_str_unchecked(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\",\n);\npub const CRYPT: Alphabet = Alphabet::from_str_unchecked(\n    \"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n);\npub const BCRYPT: Alphabet = Alphabet::from_str_unchecked(\n    \"./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n);\npub const IMAP_MUTF7: Alphabet = Alphabet::from_str_unchecked(\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\",\n);\npub const BIN_HEX: Alphabet = Alphabet::from_str_unchecked(\n    \"!\\\"#$%&'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr\",\n);\n#[derive(Clone, Debug, Eq, PartialEq)]\npub struct Alphabet {\n    pub(crate) symbols: [u8; ALPHABET_SIZE],\n}\nimpl Alphabet {\n    const fn from_str_unchecked(alphabet: &str) -> Self {\n        let mut symbols = [0_u8; ALPHABET_SIZE];\n        let source_bytes = alphabet.as_bytes();\n        let mut index = 0;\n        while index < ALPHABET_SIZE {\n            symbols[index] = source_bytes[index];\n            index += 1;\n        }\n        Self { symbols }\n    }\n    pub const fn new(alphabet: &str) -> Result<Self, ParseAlphabetError> {\n        let bytes = alphabet.as_bytes();\n        if bytes.len() != ALPHABET_SIZE {\n            return Err(ParseAlphabetError::InvalidLength);\n        }\n        {\n            let mut index = 0;\n            while index < ALPHABET_SIZE {\n                let byte = bytes[index];\n                if !(byte >= 32_u8 && byte <= 126_u8) {\n                    return Err(ParseAlphabetError::UnprintableByte(byte));\n                }\n                if byte == PAD_BYTE {\n                    return Err(ParseAlphabetError::ReservedByte(byte));\n                }\n                let mut probe_index = 0;\n                while probe_index < ALPHABET_SIZE {\n                    if probe_index == index {\n                        probe_index += 1;\n                        continue;\n                    }\n                    let probe_byte = bytes[probe_index];\n                    if byte == probe_byte {\n                        return Err(ParseAlphabetError::DuplicatedByte(byte));\n                    }\n                    probe_index += 1;\n                }\n                index += 1;\n            }\n        }\n        Ok(Self::from_str_unchecked(alphabet))\n    }\n    #[must_use]\n    pub fn as_str(&self) -> &str {}\n}\n\nThe function to be tested is presented as follows:\n/// Performs no checks so that it can be const.\n/// Used only for known-valid strings.\nconst fn from_str_unchecked(alphabet: &str) -> Self {\n    let mut symbols = [0_u8; ALPHABET_SIZE];\n    let source_bytes = alphabet.as_bytes();\n\n    // a way to copy that's allowed in const fn\n    let mut index = 0;\n    while index < ALPHABET_SIZE {\n        symbols[index] = source_bytes[index];\n        index += 1;\n    }\n\n    Self { symbols }\n}\n",
  "depend_pt": ""
}