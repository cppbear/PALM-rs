{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/engine/general_purpose/decode_suffix.rs\n// crate name is base64\nuse crate::{\n    engine::{general_purpose::INVALID_VALUE, DecodeMetadata, DecodePaddingMode},\n    DecodeError, DecodeSliceError, PAD_BYTE,\n};\n#[derive(PartialEq, Eq, Debug)]\npub struct DecodeMetadata {\n    /// Number of decoded bytes output\n    pub(crate) decoded_len: usize,\n    /// Offset of the first padding byte in the input, if any\n    pub(crate) padding_offset: Option<usize>,\n}\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum DecodeSliceError {\n    /// A [`DecodeError`] occurred\n    DecodeError(DecodeError),\n    /// The provided slice is too small.\n    OutputSliceTooSmall,\n}\n#[derive(Clone, Debug, PartialEq, Eq)]\npub enum DecodeError {\n    /// An invalid byte was found in the input. The offset and offending byte are provided.\n    ///\n    /// Padding characters (`=`) interspersed in the encoded form are invalid, as they may only\n    /// be present as the last 0-2 bytes of input.\n    ///\n    /// This error may also indicate that extraneous trailing input bytes are present, causing\n    /// otherwise valid padding to no longer be the last bytes of input.\n    InvalidByte(usize, u8),\n    /// The length of the input, as measured in valid base64 symbols, is invalid.\n    /// There must be 2-4 symbols in the last input quad.\n    InvalidLength(usize),\n    /// The last non-padding input symbol's encoded 6 bits have nonzero bits that will be discarded.\n    /// This is indicative of corrupted or truncated Base64.\n    /// Unlike [`DecodeError::InvalidByte`], which reports symbols that aren't in the alphabet,\n    /// this error is for symbols that are in the alphabet but represent nonsensical encodings.\n    InvalidLastSymbol(usize, u8),\n    /// The nature of the padding was not as configured: absent or incorrect when it must be\n    /// canonical, or present when it must be absent, etc.\n    InvalidPadding,\n}\n#[derive(Clone, Copy, Debug, PartialEq, Eq)]\npub enum DecodePaddingMode {\n    /// Canonical padding is allowed, but any fewer padding bytes than that is also allowed.\n    Indifferent,\n    /// Padding must be canonical (0, 1, or 2 `=` as needed to produce a 4 byte suffix).\n    RequireCanonical,\n    /// Padding must be absent -- for when you want predictable padding, without any wasted bytes.\n    RequireNone,\n}\nimpl DecodeMetadata {\n    pub(crate) fn new(decoded_bytes: usize, padding_index: Option<usize>) -> Self {\n        Self {\n            decoded_len: decoded_bytes,\n            padding_offset: padding_index,\n        }\n    }\n}\npub(crate) fn decode_suffix(\n    input: &[u8],\n    input_index: usize,\n    output: &mut [u8],\n    mut output_index: usize,\n    decode_table: &[u8; 256],\n    decode_allow_trailing_bits: bool,\n    padding_mode: DecodePaddingMode,\n) -> Result<DecodeMetadata, DecodeSliceError> {\n    debug_assert!((input.len() - input_index) <= 4);\n    let mut morsels_in_leftover = 0;\n    let mut padding_bytes_count = 0;\n    let mut first_padding_offset: usize = 0;\n    let mut last_symbol = 0_u8;\n    let mut morsels = [0_u8; 4];\n    for (leftover_index, &b) in input[input_index..].iter().enumerate() {\n        if b == PAD_BYTE {\n            if leftover_index < 2 {\n                debug_assert!(\n                    leftover_index == 0 || (leftover_index == 1 && padding_bytes_count ==\n                    0)\n                );\n                let bad_padding_index = input_index + leftover_index;\n                return Err(DecodeError::InvalidByte(bad_padding_index, b).into());\n            }\n            if padding_bytes_count == 0 {\n                first_padding_offset = leftover_index;\n            }\n            padding_bytes_count += 1;\n            continue;\n        }\n        if padding_bytes_count > 0 {\n            return Err(\n                DecodeError::InvalidByte(input_index + first_padding_offset, PAD_BYTE)\n                    .into(),\n            );\n        }\n        last_symbol = b;\n        let morsel = decode_table[b as usize];\n        if morsel == INVALID_VALUE {\n            return Err(DecodeError::InvalidByte(input_index + leftover_index, b).into());\n        }\n        morsels[morsels_in_leftover] = morsel;\n        morsels_in_leftover += 1;\n    }\n    if !input.is_empty() && morsels_in_leftover < 2 {\n        return Err(DecodeError::InvalidLength(input_index + morsels_in_leftover).into());\n    }\n    match padding_mode {\n        DecodePaddingMode::Indifferent => {}\n        DecodePaddingMode::RequireCanonical => {\n            if (padding_bytes_count + morsels_in_leftover) % 4 != 0 {\n                return Err(DecodeError::InvalidPadding.into());\n            }\n        }\n        DecodePaddingMode::RequireNone => {\n            if padding_bytes_count > 0 {\n                return Err(DecodeError::InvalidPadding.into());\n            }\n        }\n    }\n    let leftover_bytes_to_append = morsels_in_leftover * 6 / 8;\n    let mut leftover_num = (u32::from(morsels[0]) << 26) | (u32::from(morsels[1]) << 20)\n        | (u32::from(morsels[2]) << 14) | (u32::from(morsels[3]) << 8);\n    let mask = !0_u32 >> (leftover_bytes_to_append * 8);\n    if !decode_allow_trailing_bits && (leftover_num & mask) != 0 {\n        return Err(\n            DecodeError::InvalidLastSymbol(\n                    input_index + morsels_in_leftover - 1,\n                    last_symbol,\n                )\n                .into(),\n        );\n    }\n    for _ in 0..leftover_bytes_to_append {\n        let hi_byte = (leftover_num >> 24) as u8;\n        leftover_num <<= 8;\n        *output.get_mut(output_index).ok_or(DecodeSliceError::OutputSliceTooSmall)? = hi_byte;\n        output_index += 1;\n    }\n    Ok(\n        DecodeMetadata::new(\n            output_index,\n            if padding_bytes_count > 0 {\n                Some(input_index + first_padding_offset)\n            } else {\n                None\n            },\n        ),\n    )\n}\n\nThe function to be tested is presented as follows:\n/// Decode the last 0-4 bytes, checking for trailing set bits and padding per the provided\n/// parameters.\n///\n/// Returns the decode metadata representing the total number of bytes decoded, including the ones\n/// indicated as already written by `output_index`.\npub(crate) fn decode_suffix(\n    input: &[u8],\n    input_index: usize,\n    output: &mut [u8],\n    mut output_index: usize,\n    decode_table: &[u8; 256],\n    decode_allow_trailing_bits: bool,\n    padding_mode: DecodePaddingMode,\n) -> Result<DecodeMetadata, DecodeSliceError> {\n    debug_assert!((input.len() - input_index) <= 4);\n\n    // Decode any leftovers that might not be a complete input chunk of 4 bytes.\n    // Use a u32 as a stack-resident 4 byte buffer.\n    let mut morsels_in_leftover = 0;\n    let mut padding_bytes_count = 0;\n    // offset from input_index\n    let mut first_padding_offset: usize = 0;\n    let mut last_symbol = 0_u8;\n    let mut morsels = [0_u8; 4];\n\n    for (leftover_index, &b) in input[input_index..].iter().enumerate() {\n        // '=' padding\n        if b == PAD_BYTE {\n            // There can be bad padding bytes in a few ways:\n            // 1 - Padding with non-padding characters after it\n            // 2 - Padding after zero or one characters in the current quad (should only\n            //     be after 2 or 3 chars)\n            // 3 - More than two characters of padding. If 3 or 4 padding chars\n            //     are in the same quad, that implies it will be caught by #2.\n            //     If it spreads from one quad to another, it will be an invalid byte\n            //     in the first quad.\n            // 4 - Non-canonical padding -- 1 byte when it should be 2, etc.\n            //     Per config, non-canonical but still functional non- or partially-padded base64\n            //     may be treated as an error condition.\n\n            if leftover_index < 2 {\n                // Check for error #2.\n                // Either the previous byte was padding, in which case we would have already hit\n                // this case, or it wasn't, in which case this is the first such error.\n                debug_assert!(\n                    leftover_index == 0 || (leftover_index == 1 && padding_bytes_count == 0)\n                );\n                let bad_padding_index = input_index + leftover_index;\n                return Err(DecodeError::InvalidByte(bad_padding_index, b).into());\n            }\n\n            if padding_bytes_count == 0 {\n                first_padding_offset = leftover_index;\n            }\n\n            padding_bytes_count += 1;\n            continue;\n        }\n\n        // Check for case #1.\n        // To make '=' handling consistent with the main loop, don't allow\n        // non-suffix '=' in trailing chunk either. Report error as first\n        // erroneous padding.\n        if padding_bytes_count > 0 {\n            return Err(\n                DecodeError::InvalidByte(input_index + first_padding_offset, PAD_BYTE).into(),\n            );\n        }\n\n        last_symbol = b;\n\n        // can use up to 8 * 6 = 48 bits of the u64, if last chunk has no padding.\n        // Pack the leftovers from left to right.\n        let morsel = decode_table[b as usize];\n        if morsel == INVALID_VALUE {\n            return Err(DecodeError::InvalidByte(input_index + leftover_index, b).into());\n        }\n\n        morsels[morsels_in_leftover] = morsel;\n        morsels_in_leftover += 1;\n    }\n\n    // If there was 1 trailing byte, and it was valid, and we got to this point without hitting\n    // an invalid byte, now we can report invalid length\n    if !input.is_empty() && morsels_in_leftover < 2 {\n        return Err(DecodeError::InvalidLength(input_index + morsels_in_leftover).into());\n    }\n\n    match padding_mode {\n        DecodePaddingMode::Indifferent => { /* everything we care about was already checked */ }\n        DecodePaddingMode::RequireCanonical => {\n            // allow empty input\n            if (padding_bytes_count + morsels_in_leftover) % 4 != 0 {\n                return Err(DecodeError::InvalidPadding.into());\n            }\n        }\n        DecodePaddingMode::RequireNone => {\n            if padding_bytes_count > 0 {\n                // check at the end to make sure we let the cases of padding that should be InvalidByte\n                // get hit\n                return Err(DecodeError::InvalidPadding.into());\n            }\n        }\n    }\n\n    // When encoding 1 trailing byte (e.g. 0xFF), 2 base64 bytes (\"/w\") are needed.\n    // / is the symbol for 63 (0x3F, bottom 6 bits all set) and w is 48 (0x30, top 2 bits\n    // of bottom 6 bits set).\n    // When decoding two symbols back to one trailing byte, any final symbol higher than\n    // w would still decode to the original byte because we only care about the top two\n    // bits in the bottom 6, but would be a non-canonical encoding. So, we calculate a\n    // mask based on how many bits are used for just the canonical encoding, and optionally\n    // error if any other bits are set. In the example of one encoded byte -> 2 symbols,\n    // 2 symbols can technically encode 12 bits, but the last 4 are non-canonical, and\n    // useless since there are no more symbols to provide the necessary 4 additional bits\n    // to finish the second original byte.\n\n    let leftover_bytes_to_append = morsels_in_leftover * 6 / 8;\n    // Put the up to 6 complete bytes as the high bytes.\n    // Gain a couple percent speedup from nudging these ORs to use more ILP with a two-way split.\n    let mut leftover_num = (u32::from(morsels[0]) << 26)\n        | (u32::from(morsels[1]) << 20)\n        | (u32::from(morsels[2]) << 14)\n        | (u32::from(morsels[3]) << 8);\n\n    // if there are bits set outside the bits we care about, last symbol encodes trailing bits that\n    // will not be included in the output\n    let mask = !0_u32 >> (leftover_bytes_to_append * 8);\n    if !decode_allow_trailing_bits && (leftover_num & mask) != 0 {\n        // last morsel is at `morsels_in_leftover` - 1\n        return Err(DecodeError::InvalidLastSymbol(\n            input_index + morsels_in_leftover - 1,\n            last_symbol,\n        )\n        .into());\n    }\n\n    // Strangely, this approach benchmarks better than writing bytes one at a time,\n    // or copy_from_slice into output.\n    for _ in 0..leftover_bytes_to_append {\n        let hi_byte = (leftover_num >> 24) as u8;\n        leftover_num <<= 8;\n        *output\n            .get_mut(output_index)\n            .ok_or(DecodeSliceError::OutputSliceTooSmall)? = hi_byte;\n        output_index += 1;\n    }\n\n    Ok(DecodeMetadata::new(\n        output_index,\n        if padding_bytes_count > 0 {\n            Some(input_index + first_padding_offset)\n        } else {\n            None\n        },\n    ))\n}\n",
  "depend_pt": ""
}