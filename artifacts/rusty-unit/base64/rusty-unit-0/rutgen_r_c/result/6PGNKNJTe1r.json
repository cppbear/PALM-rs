{
    "function_name": "base64::engine::general_purpose::decode::complete_quads_len",
    "tests": 18,
    "tests_lines": [
        10,
        10,
        9,
        77,
        13,
        17,
        8,
        14,
        8,
        9,
        14,
        9,
        14,
        14,
        9,
        13,
        14,
        13
    ],
    "oracles": 18,
    "oracles_compiled": 13,
    "oracles_compiled_rate": 72.22222222222221,
    "tests_compiled": 13,
    "tests_compiled_rate": 72.22222222222221,
    "oracles_run": 13,
    "oracles_passed": 4,
    "oracles_passed_rate": 30.76923076923077,
    "tests_run": 13,
    "tests_passed": 4,
    "tests_passed_rate": 30.76923076923077,
    "lines": 26,
    "lines_covered": 26,
    "lines_coveraged_rate": 100.0,
    "branches": 12,
    "branches_covered": 9,
    "branches_coverage_rate": 75.0,
    "codes_lines": [
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        140,
        141,
        142,
        143,
        144,
        145,
        146,
        149,
        150,
        151,
        152,
        153,
        154,
        155,
        159,
        160,
        161,
        162,
        163
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let input: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x05]; // Length is 5 (input.len() % 4 == 1)",
                "    let input_len_rem: usize = 1;",
                "    let output_len: usize = 3; // Sufficient output length for complete quads",
                "    let mut decode_table: [u8; 256] = [0; 256];",
                "    decode_table[0x05] = INVALID_VALUE; // Set an invalid value for the last_byte",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(4, 0x05))));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                141,
                142,
                143,
                144,
                163
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x05]; // Length is 5 (input.len() % 4 == 1)",
                "    let input_len_rem: usize = 1;",
                "    let output_len: usize = 2; // Insufficient output length for complete quads",
                "    let mut decode_table: [u8; 256] = [0; 256];",
                "    decode_table[0x04] = INVALID_VALUE; // Last byte is valid since it is not 0x05",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                141,
                142,
                143,
                145,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                160,
                163
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[0x01, 0x02, 0x03, 0x04]; // Length is 4 (input.len() % 4 == 0)",
                "    let input_len_rem: usize = 0;",
                "    let output_len: usize = 3; // Sufficient output length",
                "    let decode_table: [u8; 256] = [0; 256]; // All bytes valid",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Ok(4)); // Valid case should return Ok(4)",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                146,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                161,
                162,
                163
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all values to INVALID_VALUE",
                "    let input = b\"QUJD\"; // valid base64 input",
                "    let input_len_rem = 0; // 4 % 4",
                "    let output_len = 3; // suitable output size",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(4));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                146,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                161,
                162,
                163
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'Z' as usize] = 25; // valid for 'Z'",
                "        table[b'Y' as usize] = 24; // valid for 'Y'",
                "        table[b'!' as usize] = INVALID_VALUE; // invalid character",
                "        table",
                "    };",
                "    let input = b\"QUJ!\"; // includes an invalid character",
                "    let input_len_rem = 1; // (4 % 4) == 1",
                "    let output_len = 2; // any output length greater than 0 should be fine",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(3, b'!'))));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all values to INVALID_VALUE",
                "    let input = b\"QUJD\"; // valid base64 input",
                "    let input_len_rem = 0; // 4 % 4",
                "    let output_len = 2; // too small for output",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeSliceError::OutputSliceTooSmall));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                146,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                161,
                162,
                163
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All invalid values",
                "    let input = b\"QUJ\"; // input length is 3, so last byte 'J'",
                "    let input_len_rem = 1; // (3 % 4) == 1",
                "    let output_len = 2; // valid output length",
                "",
                "    // This should not panic, but will invoke logic for invalid last byte",
                "    complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'A' as usize] = 0; // valid for 'A'",
                "        table[b'B' as usize] = 1; // valid for 'B'",
                "        table[b'C' as usize] = 2; // valid for 'C'",
                "        table",
                "    };",
                "    let input = b\"A==\"; // 3 length; 3 % 4 == 3",
                "    let input_len_rem = 3; // (3 % 4) == 3",
                "    let output_len = 3; // sufficient output length ",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(3));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                146,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                161,
                162,
                163
            ]
        ],
        [
            [
                "{",
                "    const DECODE_TABLE: [u8; 256] = [INVALID_VALUE; 256];",
                "    let input: &[u8] = b\"YWF\"; // Length is 3, hence `len() % 4 == 1`",
                "    let input_len_rem = 1; // input.len() % 4 == 1",
                "    let output_len = 0; // output_len < input_complete_nonterminal_quads_len / 4 * 3 should trigger the error",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &DECODE_TABLE);",
                "    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcd\";",
                "    let input_len_rem = 1; // This doesn't match with input.len() % 4 which is 0.",
                "    let output_len = 6;",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcd\\x80\"; // Invalid byte outside the Base64 alphabet.",
                "    let input_len_rem = 1; // input.len() % 4 == 1",
                "    let output_len = 6;",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[usize::from(b'a')] = 0; // Populate valid decode table values for valid Base64 chars",
                "    decode_table[usize::from(b'b')] = 1;",
                "    decode_table[usize::from(b'c')] = 2;",
                "    decode_table[usize::from(b'd')] = 3;",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert!(matches!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(5, 0x80)))));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                141,
                142,
                143,
                144,
                163
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcde\"; // Valid Base64 input",
                "    let input_len_rem = 1; // input.len() % 4 == 1",
                "    let output_len = 1; // Output length is too small",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[usize::from(b'a')] = 0; // Populate valid decode table values",
                "    decode_table[usize::from(b'b')] = 1;",
                "    decode_table[usize::from(b'c')] = 2;",
                "    decode_table[usize::from(b'd')] = 3;",
                "    decode_table[usize::from(b'e')] = 4;",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert!(matches!(result, Err(DecodeSliceError::OutputSliceTooSmall)));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                141,
                142,
                143,
                145,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                160,
                163
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcd\"; // A complete quads input without any issues.",
                "    let input_len_rem = 0; // input.len() % 4 == 0",
                "    let output_len = 3; // Allocated output length",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[usize::from(b'a')] = 0;",
                "    decode_table[usize::from(b'b')] = 1;",
                "    decode_table[usize::from(b'c')] = 2;",
                "    decode_table[usize::from(b'd')] = 3;",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Ok(4));",
                "}"
            ],
            [
                131,
                132,
                133,
                134,
                135,
                136,
                137,
                140,
                146,
                149,
                150,
                151,
                152,
                153,
                154,
                155,
                159,
                161,
                162,
                163
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 140,
            "start_column": 8,
            "end_line": 140,
            "end_column": 26,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 143,
            "start_column": 12,
            "end_line": 143,
            "end_column": 33,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 143,
            "start_column": 37,
            "end_line": 143,
            "end_column": 90,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 155,
            "start_column": 9,
            "end_line": 155,
            "end_column": 25,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 155,
            "start_column": 29,
            "end_line": 155,
            "end_column": 100,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 159,
            "start_column": 8,
            "end_line": 159,
            "end_column": 65,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let input: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x05]; // Length is 5 (input.len() % 4 == 1)",
                "    let input_len_rem: usize = 1;",
                "    let output_len: usize = 3; // Sufficient output length for complete quads",
                "    let mut decode_table: [u8; 256] = [0; 256];",
                "    decode_table[0x05] = INVALID_VALUE; // Set an invalid value for the last_byte",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(4, 0x05))));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[0x01, 0x02, 0x03, 0x04, 0x05]; // Length is 5 (input.len() % 4 == 1)",
                "    let input_len_rem: usize = 1;",
                "    let output_len: usize = 2; // Insufficient output length for complete quads",
                "    let mut decode_table: [u8; 256] = [0; 256];",
                "    decode_table[0x04] = INVALID_VALUE; // Last byte is valid since it is not 0x05",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = &[0x01, 0x02, 0x03, 0x04]; // Length is 4 (input.len() % 4 == 0)",
                "    let input_len_rem: usize = 0;",
                "    let output_len: usize = 3; // Sufficient output length",
                "    let decode_table: [u8; 256] = [0; 256]; // All bytes valid",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Ok(4)); // Valid case should return Ok(4)",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all values to INVALID_VALUE",
                "    let input = b\"QUJD\"; // valid base64 input",
                "    let input_len_rem = 0; // 4 % 4",
                "    let output_len = 3; // suitable output size",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(4));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'Z' as usize] = 25; // valid for 'Z'",
                "        table[b'Y' as usize] = 24; // valid for 'Y'",
                "        table[b'!' as usize] = INVALID_VALUE; // invalid character",
                "        table",
                "    };",
                "    let input = b\"QUJ!\"; // includes an invalid character",
                "    let input_len_rem = 1; // (4 % 4) == 1",
                "    let output_len = 2; // any output length greater than 0 should be fine",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(3, b'!'))));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // Set all values to INVALID_VALUE",
                "    let input = b\"QUJD\"; // valid base64 input",
                "    let input_len_rem = 0; // 4 % 4",
                "    let output_len = 2; // too small for output",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Err(DecodeSliceError::OutputSliceTooSmall));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256]; // All invalid values",
                "    let input = b\"QUJ\"; // input length is 3, so last byte 'J'",
                "    let input_len_rem = 1; // (3 % 4) == 1",
                "    let output_len = 2; // valid output length",
                "",
                "    // This should not panic, but will invoke logic for invalid last byte",
                "    complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'A' as usize] = 0; // valid for 'A'",
                "        table[b'B' as usize] = 1; // valid for 'B'",
                "        table[b'C' as usize] = 2; // valid for 'C'",
                "        table",
                "    };",
                "    let input = b\"A==\"; // 3 length; 3 % 4 == 3",
                "    let input_len_rem = 3; // (3 % 4) == 3",
                "    let output_len = 3; // sufficient output length ",
                "",
                "    assert_eq!(complete_quads_len(input, input_len_rem, output_len, &decode_table), Ok(3));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    const DECODE_TABLE: [u8; 256] = [INVALID_VALUE; 256];",
                "    let input: &[u8] = b\"YWF\"; // Length is 3, hence `len() % 4 == 1`",
                "    let input_len_rem = 1; // input.len() % 4 == 1",
                "    let output_len = 0; // output_len < input_complete_nonterminal_quads_len / 4 * 3 should trigger the error",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &DECODE_TABLE);",
                "    assert_eq!(result, Err(DecodeSliceError::OutputSliceTooSmall));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcd\";",
                "    let input_len_rem = 1; // This doesn't match with input.len() % 4 which is 0.",
                "    let output_len = 6;",
                "    let decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcd\\x80\"; // Invalid byte outside the Base64 alphabet.",
                "    let input_len_rem = 1; // input.len() % 4 == 1",
                "    let output_len = 6;",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[usize::from(b'a')] = 0; // Populate valid decode table values for valid Base64 chars",
                "    decode_table[usize::from(b'b')] = 1;",
                "    decode_table[usize::from(b'c')] = 2;",
                "    decode_table[usize::from(b'd')] = 3;",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert!(matches!(result, Err(DecodeSliceError::DecodeError(DecodeError::InvalidByte(5, 0x80)))));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcde\"; // Valid Base64 input",
                "    let input_len_rem = 1; // input.len() % 4 == 1",
                "    let output_len = 1; // Output length is too small",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[usize::from(b'a')] = 0; // Populate valid decode table values",
                "    decode_table[usize::from(b'b')] = 1;",
                "    decode_table[usize::from(b'c')] = 2;",
                "    decode_table[usize::from(b'd')] = 3;",
                "    decode_table[usize::from(b'e')] = 4;",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert!(matches!(result, Err(DecodeSliceError::OutputSliceTooSmall)));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: &[u8] = b\"abcd\"; // A complete quads input without any issues.",
                "    let input_len_rem = 0; // input.len() % 4 == 0",
                "    let output_len = 3; // Allocated output length",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[usize::from(b'a')] = 0;",
                "    decode_table[usize::from(b'b')] = 1;",
                "    decode_table[usize::from(b'c')] = 2;",
                "    decode_table[usize::from(b'd')] = 3;",
                "",
                "    let result = complete_quads_len(input, input_len_rem, output_len, &decode_table);",
                "    assert_eq!(result, Ok(4));",
                "}"
            ],
            [
                {
                    "start_line": 140,
                    "start_column": 8,
                    "end_line": 140,
                    "end_column": 26,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 143,
                    "start_column": 12,
                    "end_line": 143,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 143,
                    "start_column": 37,
                    "end_line": 143,
                    "end_column": 90,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 155,
                    "start_column": 9,
                    "end_line": 155,
                    "end_column": 25,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 155,
                    "start_column": 29,
                    "end_line": 155,
                    "end_column": 100,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 159,
                    "start_column": 8,
                    "end_line": 159,
                    "end_column": 65,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/base64/rusty-unit-0/src/engine/general_purpose/decode.rs"
}