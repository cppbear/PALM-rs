{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/write/encoder.rs\n// crate name is base64\nThe function to be tested is presented as follows:\n/// Encode input and then write to the delegate writer.\n///\n/// Under non-error circumstances, this returns `Ok` with the value being the number of bytes\n/// of `input` consumed. The value may be `0`, which interacts poorly with `write_all`, which\n/// interprets `Ok(0)` as an error, despite it being allowed by the contract of `write`. See\n/// <https://github.com/rust-lang/rust/issues/56889> for more on that.\n///\n/// If the previous call to `write` provided more (encoded) data than the delegate writer could\n/// accept in a single call to its `write`, the remaining data is buffered. As long as buffered\n/// data is present, subsequent calls to `write` will try to write the remaining buffered data\n/// to the delegate and return either `Ok(0)` -- and therefore not consume any of `input` -- or\n/// an error.\n///\n/// # Errors\n///\n/// Any errors emitted by the delegate writer are returned.\nfn write(&mut self, input: &[u8]) -> Result<usize> {\n    assert!(\n        self.delegate.is_some(),\n        \"Cannot write more after calling finish()\"\n    );\n\n    if input.is_empty() {\n        return Ok(0);\n    }\n\n    // The contract of `Write::write` places some constraints on this implementation:\n    // - a call to `write()` represents at most one call to a wrapped `Write`, so we can't\n    // iterate over the input and encode multiple chunks.\n    // - Errors mean that \"no bytes were written to this writer\", so we need to reset the\n    // internal state to what it was before the error occurred\n\n    // before reading any input, write any leftover encoded output from last time\n    if self.output_occupied_len > 0 {\n        let current_len = self.output_occupied_len;\n        return self\n            .write_to_delegate(current_len)\n            // did not read any input\n            .map(|()| 0);\n    }\n\n    debug_assert_eq!(0, self.output_occupied_len);\n\n    // how many bytes, if any, were read into `extra` to create a triple to encode\n    let mut extra_input_read_len = 0;\n    let mut input = input;\n\n    let orig_extra_len = self.extra_input_occupied_len;\n\n    let mut encoded_size = 0;\n    // always a multiple of MIN_ENCODE_CHUNK_SIZE\n    let mut max_input_len = MAX_INPUT_LEN;\n\n    // process leftover un-encoded input from last write\n    if self.extra_input_occupied_len > 0 {\n        debug_assert!(self.extra_input_occupied_len < 3);\n        if input.len() + self.extra_input_occupied_len >= MIN_ENCODE_CHUNK_SIZE {\n            // Fill up `extra`, encode that into `output`, and consume as much of the rest of\n            // `input` as possible.\n            // We could write just the encoding of `extra` by itself but then we'd have to\n            // return after writing only 4 bytes, which is inefficient if the underlying writer\n            // would make a syscall.\n            extra_input_read_len = MIN_ENCODE_CHUNK_SIZE - self.extra_input_occupied_len;\n            debug_assert!(extra_input_read_len > 0);\n            // overwrite only bytes that weren't already used. If we need to rollback extra_len\n            // (when the subsequent write errors), the old leading bytes will still be there.\n            self.extra_input[self.extra_input_occupied_len..MIN_ENCODE_CHUNK_SIZE]\n                .copy_from_slice(&input[0..extra_input_read_len]);\n\n            let len = self.engine.internal_encode(\n                &self.extra_input[0..MIN_ENCODE_CHUNK_SIZE],\n                &mut self.output[..],\n            );\n            debug_assert_eq!(4, len);\n\n            input = &input[extra_input_read_len..];\n\n            // consider extra to be used up, since we encoded it\n            self.extra_input_occupied_len = 0;\n            // don't clobber where we just encoded to\n            encoded_size = 4;\n            // and don't read more than can be encoded\n            max_input_len = MAX_INPUT_LEN - MIN_ENCODE_CHUNK_SIZE;\n\n        // fall through to normal encoding\n        } else {\n            // `extra` and `input` are non empty, but `|extra| + |input| < 3`, so there must be\n            // 1 byte in each.\n            debug_assert_eq!(1, input.len());\n            debug_assert_eq!(1, self.extra_input_occupied_len);\n\n            self.extra_input[self.extra_input_occupied_len] = input[0];\n            self.extra_input_occupied_len += 1;\n            return Ok(1);\n        };\n    } else if input.len() < MIN_ENCODE_CHUNK_SIZE {\n        // `extra` is empty, and `input` fits inside it\n        self.extra_input[0..input.len()].copy_from_slice(input);\n        self.extra_input_occupied_len = input.len();\n        return Ok(input.len());\n    };\n\n    // either 0 or 1 complete chunks encoded from extra\n    debug_assert!(encoded_size == 0 || encoded_size == 4);\n    debug_assert!(\n        // didn't encode extra input\n        MAX_INPUT_LEN == max_input_len\n            // encoded one triple\n            || MAX_INPUT_LEN == max_input_len + MIN_ENCODE_CHUNK_SIZE\n    );\n\n    // encode complete triples only\n    let input_complete_chunks_len = input.len() - (input.len() % MIN_ENCODE_CHUNK_SIZE);\n    let input_chunks_to_encode_len = cmp::min(input_complete_chunks_len, max_input_len);\n    debug_assert_eq!(0, max_input_len % MIN_ENCODE_CHUNK_SIZE);\n    debug_assert_eq!(0, input_chunks_to_encode_len % MIN_ENCODE_CHUNK_SIZE);\n\n    encoded_size += self.engine.internal_encode(\n        &input[..(input_chunks_to_encode_len)],\n        &mut self.output[encoded_size..],\n    );\n\n    // not updating `self.output_occupied_len` here because if the below write fails, it should\n    // \"never take place\" -- the buffer contents we encoded are ignored and perhaps retried\n    // later, if the consumer chooses.\n\n    self.write_to_delegate(encoded_size)\n        // no matter whether we wrote the full encoded buffer or not, we consumed the same\n        // input\n        .map(|()| extra_input_read_len + input_chunks_to_encode_len)\n        .map_err(|e| {\n            // in case we filled and encoded `extra`, reset extra_len\n            self.extra_input_occupied_len = orig_extra_len;\n\n            e\n        })\n}\n",
  "depend_pt": ""
}