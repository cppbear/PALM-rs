{
    "function_name": "base64::engine::general_purpose::decode::decode_chunk_8",
    "tests": 27,
    "tests_lines": [
        12,
        12,
        12,
        33,
        13,
        14,
        15,
        9,
        16,
        16,
        14,
        13,
        15,
        19,
        21,
        24,
        13,
        17,
        22,
        27,
        18,
        22,
        15,
        18,
        20,
        13,
        14
    ],
    "oracles": 27,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 25.925925925925924,
    "tests_compiled": 7,
    "tests_compiled_rate": 25.925925925925924,
    "oracles_run": 7,
    "oracles_passed": 4,
    "oracles_passed_rate": 57.14285714285714,
    "tests_run": 7,
    "tests_passed": 4,
    "tests_passed_rate": 57.14285714285714,
    "lines": 79,
    "lines_covered": 58,
    "lines_coveraged_rate": 73.41772151898735,
    "branches": 16,
    "branches_covered": 10,
    "branches_coverage_rate": 62.5,
    "codes_lines": [
        174,
        175,
        176,
        177,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        187,
        188,
        189,
        190,
        191,
        192,
        193,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        219,
        220,
        221,
        222,
        223,
        224,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        235,
        236,
        237,
        238,
        239,
        240,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250,
        251,
        252
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
                "    let index_at_start_of_input = 0;",
                "    let decode_table: [u8; 256] = [0; 256]; // In a real scenario, this would be a valid decode table",
                "    let mut output: [u8; 6] = [0; 6];",
                "",
                "    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                183,
                184,
                185,
                186,
                187,
                192,
                193,
                194,
                195,
                196,
                201,
                202,
                203,
                204,
                205,
                210,
                211,
                212,
                213,
                214,
                219,
                220,
                221,
                222,
                223,
                228,
                229,
                230,
                231,
                232,
                237,
                238,
                239,
                240,
                241,
                246,
                247,
                248,
                249,
                250,
                251,
                252
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[1] = 0; // Assuming these are valid mappings for this example",
                "        table[2] = 1;",
                "        table[3] = 2;",
                "        table[4] = 3;",
                "        table[5] = 4;",
                "        table[6] = 5;",
                "        table[7] = 6;",
                "        table[8] = 7;",
                "        table",
                "    };",
                "    let mut output: [u8; 6] = [0; 6];",
                "    ",
                "    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);",
                "    ",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, [0, 1, 2, 3, 4, 5]); // placeholder for expected output",
                "}"
            ],
            [
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                183,
                184,
                185,
                186,
                187,
                192,
                193,
                194,
                195,
                196,
                201,
                202,
                203,
                204,
                205,
                210,
                211,
                212,
                213,
                214,
                219,
                220,
                221,
                222,
                223,
                228,
                229,
                230,
                231,
                232,
                237,
                238,
                239,
                240,
                241,
                246,
                247,
                248,
                249,
                250,
                251,
                252
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        for i in 0..64 {",
                "            table[i] = i as u8; // Assuming first 64 bytes are valid for base64 decoding.",
                "        }",
                "        table",
                "    };",
                "    let mut output = [0u8; 6];",
                "    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);",
                "    assert!(result.is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 64, 6, 7]; // 64 is invalid in this context",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        for i in 0..64 {",
                "            table[i] = i as u8; // Assuming first 64 bytes are valid for base64 decoding.",
                "        }",
                "        table",
                "    };",
                "    let mut output = [0u8; 6];",
                "    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);",
                "    assert!(result.is_err());",
                "    if let Err(DecodeError { index, byte }) = result {",
                "        assert_eq!(index, 5); // The index where the invalid byte is located",
                "        assert_eq!(byte, 64); // The invalid byte itself",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'A' as usize] = 0; // valid base64 value for 'A'",
                "        table[b'B' as usize] = 1; // valid base64 value for 'B'",
                "        table[b'C' as usize] = 2; // valid base64 value for 'C'",
                "        table[b'D' as usize] = 3; // valid base64 value for 'D'",
                "        table[b'E' as usize] = 4; // valid base64 value for 'E'",
                "        table[b'F' as usize] = 5; // valid base64 value for 'F'",
                "        table[b'G' as usize] = 6; // valid base64 value for 'G'",
                "        table[b'H' as usize] = 7; // valid base64 value for 'H'",
                "        table",
                "    };",
                "",
                "    let input: &[u8] = b\"ABCDEFGH\"; // valid input to decode",
                "    let expected_output: [u8; 6] = [0, 1, 2, 3, 4, 5]; // expected output after decoding",
                "    let mut output = [0u8; 6];",
                "    ",
                "    let result = decode_chunk_8(input, 0, &decode_table, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, expected_output);",
                "}"
            ],
            [
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                183,
                184,
                185,
                186,
                187,
                192,
                193,
                194,
                195,
                196,
                201,
                202,
                203,
                204,
                205,
                210,
                211,
                212,
                213,
                214,
                219,
                220,
                221,
                222,
                223,
                228,
                229,
                230,
                231,
                232,
                237,
                238,
                239,
                240,
                241,
                246,
                247,
                248,
                249,
                250,
                251,
                252
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'A' as usize] = 0; // valid base64 value for 'A'",
                "        table[b'B' as usize] = 1; // valid base64 value for 'B'",
                "        table[b'C' as usize] = 2; // valid base64 value for 'C'",
                "        table[b'D' as usize] = 3; // valid base64 value for 'D'",
                "        table[b'E' as usize] = 4; // valid base64 value for 'E'",
                "        table[b'F' as usize] = 5; // valid base64 value for 'F'",
                "        table[b'G' as usize] = 6; // valid base64 value for 'G'",
                "        table[b'H' as usize] = 7; // valid base64 value for 'H'",
                "        // no valid value for 'I', keeping it INVALID_VALUE",
                "        table",
                "    };",
                "",
                "    let input: &[u8] = b\"ABCDEFGI\"; // 'I' is invalid",
                "    let mut output = [0u8; 6];",
                "",
                "    let result = decode_chunk_8(input, 0, &decode_table, &mut output);",
                "    assert!(result.is_err());",
                "    if let Err(DecodeError::InvalidByte(index, byte)) = result {",
                "        assert_eq!(index, 6);",
                "        assert_eq!(byte, b'I');",
                "    } else {",
                "        panic!(\"Expected DecodeError::InvalidByte\");",
                "    }",
                "}"
            ],
            [
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                183,
                184,
                185,
                186,
                187,
                192,
                193,
                194,
                195,
                196,
                201,
                202,
                203,
                204,
                205,
                210,
                211,
                212,
                213,
                214,
                219,
                220,
                221,
                222,
                223,
                228,
                229,
                230,
                231,
                232,
                237,
                238,
                239,
                240,
                241,
                242,
                243,
                244,
                245,
                252
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
                "    let index_at_start_of_input: usize = 0;",
                "",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[0] = 0; // Valid byte",
                "    decode_table[1] = 1; // Valid byte",
                "    decode_table[2] = INVALID_VALUE; // Invalid byte",
                "",
                "    let mut output: [u8; 6] = [0; 6];",
                "",
                "    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);",
                "    assert!(result.is_err());",
                "    if let Err(DecodeError::InvalidByte(idx, byte)) = result {",
                "        assert_eq!(idx, index_at_start_of_input + 2);",
                "        assert_eq!(byte, 2);",
                "    }",
                "}"
            ],
            [
                174,
                175,
                176,
                177,
                178,
                179,
                180,
                181,
                183,
                184,
                185,
                186,
                187,
                192,
                193,
                194,
                195,
                196,
                197,
                198,
                199,
                200,
                252
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 181,
            "start_column": 8,
            "end_line": 181,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 187,
            "start_column": 8,
            "end_line": 187,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 196,
            "start_column": 8,
            "end_line": 196,
            "end_column": 31,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 205,
            "start_column": 8,
            "end_line": 205,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 214,
            "start_column": 8,
            "end_line": 214,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 223,
            "start_column": 8,
            "end_line": 223,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 232,
            "start_column": 8,
            "end_line": 232,
            "end_column": 31,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 241,
            "start_column": 8,
            "end_line": 241,
            "end_column": 31,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
                "    let index_at_start_of_input = 0;",
                "    let decode_table: [u8; 256] = [0; 256]; // In a real scenario, this would be a valid decode table",
                "    let mut output: [u8; 6] = [0; 6];",
                "",
                "    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [1, 2, 3, 4, 5, 6, 7, 8];",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[1] = 0; // Assuming these are valid mappings for this example",
                "        table[2] = 1;",
                "        table[3] = 2;",
                "        table[4] = 3;",
                "        table[5] = 4;",
                "        table[6] = 5;",
                "        table[7] = 6;",
                "        table[8] = 7;",
                "        table",
                "    };",
                "    let mut output: [u8; 6] = [0; 6];",
                "    ",
                "    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);",
                "    ",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, [0, 1, 2, 3, 4, 5]); // placeholder for expected output",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        for i in 0..64 {",
                "            table[i] = i as u8; // Assuming first 64 bytes are valid for base64 decoding.",
                "        }",
                "        table",
                "    };",
                "    let mut output = [0u8; 6];",
                "    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 64, 6, 7]; // 64 is invalid in this context",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        for i in 0..64 {",
                "            table[i] = i as u8; // Assuming first 64 bytes are valid for base64 decoding.",
                "        }",
                "        table",
                "    };",
                "    let mut output = [0u8; 6];",
                "    let result = decode_chunk_8(&input, 0, &decode_table, &mut output);",
                "    assert!(result.is_err());",
                "    if let Err(DecodeError { index, byte }) = result {",
                "        assert_eq!(index, 5); // The index where the invalid byte is located",
                "        assert_eq!(byte, 64); // The invalid byte itself",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'A' as usize] = 0; // valid base64 value for 'A'",
                "        table[b'B' as usize] = 1; // valid base64 value for 'B'",
                "        table[b'C' as usize] = 2; // valid base64 value for 'C'",
                "        table[b'D' as usize] = 3; // valid base64 value for 'D'",
                "        table[b'E' as usize] = 4; // valid base64 value for 'E'",
                "        table[b'F' as usize] = 5; // valid base64 value for 'F'",
                "        table[b'G' as usize] = 6; // valid base64 value for 'G'",
                "        table[b'H' as usize] = 7; // valid base64 value for 'H'",
                "        table",
                "    };",
                "",
                "    let input: &[u8] = b\"ABCDEFGH\"; // valid input to decode",
                "    let expected_output: [u8; 6] = [0, 1, 2, 3, 4, 5]; // expected output after decoding",
                "    let mut output = [0u8; 6];",
                "    ",
                "    let result = decode_chunk_8(input, 0, &decode_table, &mut output);",
                "    assert!(result.is_ok());",
                "    assert_eq!(output, expected_output);",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let decode_table: [u8; 256] = {",
                "        let mut table = [INVALID_VALUE; 256];",
                "        table[b'A' as usize] = 0; // valid base64 value for 'A'",
                "        table[b'B' as usize] = 1; // valid base64 value for 'B'",
                "        table[b'C' as usize] = 2; // valid base64 value for 'C'",
                "        table[b'D' as usize] = 3; // valid base64 value for 'D'",
                "        table[b'E' as usize] = 4; // valid base64 value for 'E'",
                "        table[b'F' as usize] = 5; // valid base64 value for 'F'",
                "        table[b'G' as usize] = 6; // valid base64 value for 'G'",
                "        table[b'H' as usize] = 7; // valid base64 value for 'H'",
                "        // no valid value for 'I', keeping it INVALID_VALUE",
                "        table",
                "    };",
                "",
                "    let input: &[u8] = b\"ABCDEFGI\"; // 'I' is invalid",
                "    let mut output = [0u8; 6];",
                "",
                "    let result = decode_chunk_8(input, 0, &decode_table, &mut output);",
                "    assert!(result.is_err());",
                "    if let Err(DecodeError::InvalidByte(index, byte)) = result {",
                "        assert_eq!(index, 6);",
                "        assert_eq!(byte, b'I');",
                "    } else {",
                "        panic!(\"Expected DecodeError::InvalidByte\");",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let input: [u8; 8] = [0, 1, 2, 3, 4, 5, 6, 7];",
                "    let index_at_start_of_input: usize = 0;",
                "",
                "    let mut decode_table: [u8; 256] = [INVALID_VALUE; 256];",
                "    decode_table[0] = 0; // Valid byte",
                "    decode_table[1] = 1; // Valid byte",
                "    decode_table[2] = INVALID_VALUE; // Invalid byte",
                "",
                "    let mut output: [u8; 6] = [0; 6];",
                "",
                "    let result = decode_chunk_8(&input, index_at_start_of_input, &decode_table, &mut output);",
                "    assert!(result.is_err());",
                "    if let Err(DecodeError::InvalidByte(idx, byte)) = result {",
                "        assert_eq!(idx, index_at_start_of_input + 2);",
                "        assert_eq!(byte, 2);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 181,
                    "start_column": 8,
                    "end_line": 181,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 187,
                    "start_column": 8,
                    "end_line": 187,
                    "end_column": 31,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 196,
                    "start_column": 8,
                    "end_line": 196,
                    "end_column": 31,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 205,
                    "start_column": 8,
                    "end_line": 205,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 214,
                    "start_column": 8,
                    "end_line": 214,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 223,
                    "start_column": 8,
                    "end_line": 223,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 232,
                    "start_column": 8,
                    "end_line": 232,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 241,
                    "start_column": 8,
                    "end_line": 241,
                    "end_column": 31,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/base64/rusty-unit-0/src/engine/general_purpose/decode.rs"
}