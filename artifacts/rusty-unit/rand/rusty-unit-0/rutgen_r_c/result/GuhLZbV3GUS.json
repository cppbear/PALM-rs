{
    "function_name": "rand_core::block::<block::BlockRng<R> as RngCore>::next_u32",
    "tests": 5,
    "tests_lines": [
        26,
        26,
        32,
        29,
        25
    ],
    "oracles": 5,
    "oracles_compiled": 5,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 5,
    "tests_compiled_rate": 100.0,
    "oracles_run": 5,
    "oracles_passed": 2,
    "oracles_passed_rate": 40.0,
    "tests_run": 5,
    "tests_passed": 2,
    "tests_passed_rate": 40.0,
    "lines": 8,
    "lines_covered": 8,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        186,
        187,
        188,
        189,
        191,
        192,
        193,
        194
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct MockBlockRngCore {",
                "        count: usize,",
                "    }",
                "",
                "    impl BlockRngCore for MockBlockRngCore {",
                "        type Item = u32;",
                "        type Results = Vec<u32>;",
                "",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            for i in 0..self.count {",
                "                results.push(i as u32);",
                "            }",
                "        }",
                "    }",
                "",
                "    let core = MockBlockRngCore { count: 5 };",
                "    let mut rng = BlockRng {",
                "        results: Vec::with_capacity(5),",
                "        index: 5,",
                "        core,",
                "    };",
                "",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0); // Expect first value after reset",
                "}"
            ],
            [
                186,
                187,
                188,
                189,
                191,
                192,
                193,
                194
            ]
        ],
        [
            [
                "{",
                "    struct MockBlockRngCore {",
                "        count: usize,",
                "    }",
                "",
                "    impl BlockRngCore for MockBlockRngCore {",
                "        type Item = u32;",
                "        type Results = Vec<u32>;",
                "",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            for i in 0..self.count {",
                "                results.push(i as u32);",
                "            }",
                "        }",
                "    }",
                "",
                "    let core = MockBlockRngCore { count: 5 };",
                "    let mut rng = BlockRng {",
                "        results: vec![0, 1, 2, 3, 4],",
                "        index: 0,",
                "        core,",
                "    };",
                "",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0); // Expecting the first value in the results",
                "}"
            ],
            [
                186,
                187,
                189,
                191,
                192,
                193,
                194
            ]
        ],
        [
            [
                "{",
                "    struct MockBlockRngCore {",
                "        count: usize,",
                "        call_count: usize,",
                "    }",
                "",
                "    impl BlockRngCore for MockBlockRngCore {",
                "        type Item = u32;",
                "        type Results = Vec<u32>;",
                "",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            results.clear(); // Clear previous values",
                "            for i in 0..self.count {",
                "                results.push((self.call_count * self.count + i) as u32);",
                "            }",
                "            self.call_count += 1;",
                "        }",
                "    }",
                "",
                "    let core = MockBlockRngCore { count: 3, call_count: 0 };",
                "    let mut rng = BlockRng {",
                "        results: Vec::new(),",
                "        index: 3,",
                "        core,",
                "    };",
                "",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0); // Expecting the first new generated value",
                "    rng.next_u32(); // Advance index",
                "    let next_result = rng.next_u32();",
                "    assert_eq!(next_result, 1); // Expecting the next value in the new results",
                "}"
            ],
            [
                186,
                187,
                188,
                189,
                191,
                192,
                193,
                194
            ]
        ],
        [
            [
                "{",
                "    struct TestCore {",
                "        values: [u32; 5],",
                "        current: usize,",
                "    }",
                "",
                "    impl BlockRngCore for TestCore {",
                "        type Item = u32;",
                "        type Results = [u32; 5];",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            results.copy_from_slice(&self.values);",
                "        }",
                "    }",
                "",
                "    let core = TestCore {",
                "        values: [1, 2, 3, 4, 5],",
                "        current: 0,",
                "    };",
                "",
                "    let mut block_rng = BlockRng::new(core);",
                "    block_rng.results = [0; 5]; // Initialize results",
                "    block_rng.index = 0; // Set index to 0 to start",
                "",
                "    assert_eq!(block_rng.next_u32(), 1);",
                "    assert_eq!(block_rng.next_u32(), 2);",
                "    assert_eq!(block_rng.next_u32(), 3);",
                "    assert_eq!(block_rng.next_u32(), 4);",
                "    assert_eq!(block_rng.next_u32(), 5); // Should fill and return again",
                "}"
            ],
            [
                186,
                187,
                189,
                191,
                192,
                193,
                194
            ]
        ],
        [
            [
                "{",
                "    struct TestCore {",
                "        values: [u32; 3],",
                "    }",
                "",
                "    impl BlockRngCore for TestCore {",
                "        type Item = u32;",
                "        type Results = [u32; 3];",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            results.copy_from_slice(&self.values);",
                "        }",
                "    }",
                "",
                "    let core = TestCore {",
                "        values: [10, 20, 30],",
                "    };",
                "",
                "    let mut block_rng = BlockRng::new(core);",
                "    block_rng.results = [0; 3]; // Initialize results",
                "    block_rng.index = 3; // Set index to trigger generation",
                "",
                "    assert_eq!(block_rng.next_u32(), 10); // Should generate new values and return 10",
                "    assert_eq!(block_rng.next_u32(), 20);",
                "    assert_eq!(block_rng.next_u32(), 30);",
                "}"
            ],
            [
                186,
                187,
                188,
                189,
                191,
                192,
                193,
                194
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 187,
            "start_column": 12,
            "end_line": 187,
            "end_column": 53,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct MockBlockRngCore {",
                "        count: usize,",
                "    }",
                "",
                "    impl BlockRngCore for MockBlockRngCore {",
                "        type Item = u32;",
                "        type Results = Vec<u32>;",
                "",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            for i in 0..self.count {",
                "                results.push(i as u32);",
                "            }",
                "        }",
                "    }",
                "",
                "    let core = MockBlockRngCore { count: 5 };",
                "    let mut rng = BlockRng {",
                "        results: Vec::with_capacity(5),",
                "        index: 5,",
                "        core,",
                "    };",
                "",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0); // Expect first value after reset",
                "}"
            ],
            [
                {
                    "start_line": 187,
                    "start_column": 12,
                    "end_line": 187,
                    "end_column": 53,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct MockBlockRngCore {",
                "        count: usize,",
                "    }",
                "",
                "    impl BlockRngCore for MockBlockRngCore {",
                "        type Item = u32;",
                "        type Results = Vec<u32>;",
                "",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            for i in 0..self.count {",
                "                results.push(i as u32);",
                "            }",
                "        }",
                "    }",
                "",
                "    let core = MockBlockRngCore { count: 5 };",
                "    let mut rng = BlockRng {",
                "        results: vec![0, 1, 2, 3, 4],",
                "        index: 0,",
                "        core,",
                "    };",
                "",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0); // Expecting the first value in the results",
                "}"
            ],
            [
                {
                    "start_line": 187,
                    "start_column": 12,
                    "end_line": 187,
                    "end_column": 53,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    struct MockBlockRngCore {",
                "        count: usize,",
                "        call_count: usize,",
                "    }",
                "",
                "    impl BlockRngCore for MockBlockRngCore {",
                "        type Item = u32;",
                "        type Results = Vec<u32>;",
                "",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            results.clear(); // Clear previous values",
                "            for i in 0..self.count {",
                "                results.push((self.call_count * self.count + i) as u32);",
                "            }",
                "            self.call_count += 1;",
                "        }",
                "    }",
                "",
                "    let core = MockBlockRngCore { count: 3, call_count: 0 };",
                "    let mut rng = BlockRng {",
                "        results: Vec::new(),",
                "        index: 3,",
                "        core,",
                "    };",
                "",
                "    let result = rng.next_u32();",
                "    assert_eq!(result, 0); // Expecting the first new generated value",
                "    rng.next_u32(); // Advance index",
                "    let next_result = rng.next_u32();",
                "    assert_eq!(next_result, 1); // Expecting the next value in the new results",
                "}"
            ],
            [
                {
                    "start_line": 187,
                    "start_column": 12,
                    "end_line": 187,
                    "end_column": 53,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestCore {",
                "        values: [u32; 5],",
                "        current: usize,",
                "    }",
                "",
                "    impl BlockRngCore for TestCore {",
                "        type Item = u32;",
                "        type Results = [u32; 5];",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            results.copy_from_slice(&self.values);",
                "        }",
                "    }",
                "",
                "    let core = TestCore {",
                "        values: [1, 2, 3, 4, 5],",
                "        current: 0,",
                "    };",
                "",
                "    let mut block_rng = BlockRng::new(core);",
                "    block_rng.results = [0; 5]; // Initialize results",
                "    block_rng.index = 0; // Set index to 0 to start",
                "",
                "    assert_eq!(block_rng.next_u32(), 1);",
                "    assert_eq!(block_rng.next_u32(), 2);",
                "    assert_eq!(block_rng.next_u32(), 3);",
                "    assert_eq!(block_rng.next_u32(), 4);",
                "    assert_eq!(block_rng.next_u32(), 5); // Should fill and return again",
                "}"
            ],
            [
                {
                    "start_line": 187,
                    "start_column": 12,
                    "end_line": 187,
                    "end_column": 53,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestCore {",
                "        values: [u32; 3],",
                "    }",
                "",
                "    impl BlockRngCore for TestCore {",
                "        type Item = u32;",
                "        type Results = [u32; 3];",
                "        fn generate(&mut self, results: &mut Self::Results) {",
                "            results.copy_from_slice(&self.values);",
                "        }",
                "    }",
                "",
                "    let core = TestCore {",
                "        values: [10, 20, 30],",
                "    };",
                "",
                "    let mut block_rng = BlockRng::new(core);",
                "    block_rng.results = [0; 3]; // Initialize results",
                "    block_rng.index = 3; // Set index to trigger generation",
                "",
                "    assert_eq!(block_rng.next_u32(), 10); // Should generate new values and return 10",
                "    assert_eq!(block_rng.next_u32(), 20);",
                "    assert_eq!(block_rng.next_u32(), 30);",
                "}"
            ],
            [
                {
                    "start_line": 187,
                    "start_column": 12,
                    "end_line": 187,
                    "end_column": 53,
                    "positive": true,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/rand/rusty-unit-0/rand_core/src/block.rs"
}