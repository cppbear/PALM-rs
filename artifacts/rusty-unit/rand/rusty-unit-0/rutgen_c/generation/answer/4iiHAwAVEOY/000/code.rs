// Answer 0

#[test]
fn test_new_with_valid_key_and_nonce() {
    let key: [u8; 32] = [
        0x01, 0x02, 0x03, 0x04, 
        0x05, 0x06, 0x07, 0x08, 
        0x09, 0x0A, 0x0B, 0x0C, 
        0x0D, 0x0E, 0x0F, 0x10, 
        0x11, 0x12, 0x13, 0x14, 
        0x15, 0x16, 0x17, 0x18, 
        0x19, 0x1A, 0x1B, 0x1C, 
        0x1D, 0x1E, 0x1F, 0x20,
    ];
    let nonce: &[u8] = &[0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B];
    
    let chacha = ChaCha::new(&key, nonce);
    
    assert_eq!(chacha.b.is_empty(), false);
    assert_eq!(chacha.c.is_empty(), false);
    assert_eq!(chacha.d.is_empty(), false);
}

#[test]
#[should_panic]
fn test_new_with_invalid_key_length() {
    let key: [u8; 32] = [
        0x01, 0x02, 0x03, 0x04, 
        0x05, 0x06, 0x07, 0x08, 
        0x09, 0x0A, 0x0B, 0x0C, 
        0x0D, 0x0E, 0x0F, 0x10, 
        0x11, 0x12, 0x13, 0x14, 
        0x15, 0x16, 0x17, 0x18, 
        0x19, 0x1A, 0x1B, 0x1C, 
        0x1D, 0x1E, 0x1F, // Missing last byte to make it 32
    ];
    let nonce: &[u8] = &[0x00; 12]; // valid nonce

    let _chacha = ChaCha::new(&key, nonce); // should panic due to invalid key length
}

#[test]
fn test_new_with_zero_nonce() {
    let key: [u8; 32] = [
        0x01, 0x02, 0x03, 0x04, 
        0x05, 0x06, 0x07, 0x08, 
        0x09, 0x0A, 0x0B, 0x0C, 
        0x0D, 0x0E, 0x0F, 0x10, 
        0x11, 0x12, 0x13, 0x14, 
        0x15, 0x16, 0x17, 0x18, 
        0x19, 0x1A, 0x1B, 0x1C, 
        0x1D, 0x1E, 0x1F, 0x20,
    ];
    let nonce: &[u8] = &[0; 12]; // nonce of zeros

    let chacha = ChaCha::new(&key, nonce);

    assert_eq!(chacha.b.is_empty(), false);
    assert_eq!(chacha.c.is_empty(), false);
    assert_eq!(chacha.d.is_empty(), false);
}

