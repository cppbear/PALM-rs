{
    "function_name": "rand_pcg::pcg128cm::output_dxsm",
    "tests": 1,
    "tests_lines": [
        35
    ],
    "oracles": 1,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 1,
    "tests_compiled_rate": 100.0,
    "oracles_run": 1,
    "oracles_passed": 0,
    "oracles_passed_rate": 0.0,
    "tests_run": 1,
    "tests_passed": 0,
    "tests_passed_rate": 0.0,
    "lines": 14,
    "lines_covered": 14,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        174,
        175,
        176,
        177
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    const MULTIPLIER: u64 = 0x5851f42b4c957f2d;",
                "",
                "    // Test case 1: Basic input",
                "    let state1: u128 = 0x00000000000000000000000000000001;",
                "    let result1 = output_dxsm(state1);",
                "    let expected1: u64 = (MULTIPLIER.wrapping_mul(1)) ^ (MULTIPLIER >> 48);",
                "    assert_eq!(result1, expected1);",
                "",
                "    // Test case 2: State with a higher value",
                "    let state2: u128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;",
                "    let result2 = output_dxsm(state2);",
                "    let lo2 = state2 as u64 | 1;",
                "    let hi2 = (state2 >> 64) as u64;",
                "    let intermediate_hi2 = hi2 ^ (hi2 >> 32);",
                "    let hi2 = intermediate_hi2.wrapping_mul(MULTIPLIER);",
                "    let expected2 = hi2 ^ (hi2 >> 48).wrapping_mul(lo2);",
                "    assert_eq!(result2, expected2);",
                "",
                "    // Test case 3: State is zero",
                "    let state3: u128 = 0x00000000000000000000000000000000;",
                "    let result3 = output_dxsm(state3);",
                "    let expected3: u64 = (MULTIPLIER.wrapping_mul(1)) ^ (MULTIPLIER >> 48);",
                "    assert_eq!(result3, expected3);",
                "",
                "    // Test case 4: State with maximum low part",
                "    let state4: u128 = 0x0000000000000000FFFFFFFFFFFFFFFF;",
                "    let result4 = output_dxsm(state4);",
                "    let lo4 = state4 as u64 | 1;",
                "    let hi4 = (state4 >> 64) as u64;",
                "    let intermediate_hi4 = hi4 ^ (hi4 >> 32);",
                "    let hi4 = intermediate_hi4.wrapping_mul(MULTIPLIER);",
                "    let expected4 = hi4 ^ (hi4 >> 48).wrapping_mul(lo4);",
                "    assert_eq!(result4, expected4);",
                "}"
            ],
            [
                164,
                165,
                166,
                167,
                168,
                169,
                170,
                171,
                172,
                173,
                174,
                175,
                176,
                177
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    const MULTIPLIER: u64 = 0x5851f42b4c957f2d;",
                "",
                "    // Test case 1: Basic input",
                "    let state1: u128 = 0x00000000000000000000000000000001;",
                "    let result1 = output_dxsm(state1);",
                "    let expected1: u64 = (MULTIPLIER.wrapping_mul(1)) ^ (MULTIPLIER >> 48);",
                "    assert_eq!(result1, expected1);",
                "",
                "    // Test case 2: State with a higher value",
                "    let state2: u128 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;",
                "    let result2 = output_dxsm(state2);",
                "    let lo2 = state2 as u64 | 1;",
                "    let hi2 = (state2 >> 64) as u64;",
                "    let intermediate_hi2 = hi2 ^ (hi2 >> 32);",
                "    let hi2 = intermediate_hi2.wrapping_mul(MULTIPLIER);",
                "    let expected2 = hi2 ^ (hi2 >> 48).wrapping_mul(lo2);",
                "    assert_eq!(result2, expected2);",
                "",
                "    // Test case 3: State is zero",
                "    let state3: u128 = 0x00000000000000000000000000000000;",
                "    let result3 = output_dxsm(state3);",
                "    let expected3: u64 = (MULTIPLIER.wrapping_mul(1)) ^ (MULTIPLIER >> 48);",
                "    assert_eq!(result3, expected3);",
                "",
                "    // Test case 4: State with maximum low part",
                "    let state4: u128 = 0x0000000000000000FFFFFFFFFFFFFFFF;",
                "    let result4 = output_dxsm(state4);",
                "    let lo4 = state4 as u64 | 1;",
                "    let hi4 = (state4 >> 64) as u64;",
                "    let intermediate_hi4 = hi4 ^ (hi4 >> 32);",
                "    let hi4 = intermediate_hi4.wrapping_mul(MULTIPLIER);",
                "    let expected4 = hi4 ^ (hi4 >> 48).wrapping_mul(lo4);",
                "    assert_eq!(result4, expected4);",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/rand/rusty-unit-0/rand_pcg/src/pcg128cm.rs"
}