{
  "name": "rand_pcg::pcg128::pcg128::Mcg128Xsl64::advance",
  "name_with_impl": "rand_pcg::pcg128::{impl#4}::advance",
  "mod_info": {
    "name": "pcg128",
    "loc": "rand_pcg/src/lib.rs:92:1:92:12"
  },
  "visible": true,
  "loc": "rand_pcg/src/pcg128.rs:191:5:208:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: mdelta > 0 is true\n",
        "// constraint: (mdelta & 1) != 0 is true\n",
        "// constraint: mdelta > 0 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "mdelta: 1 to 2^128-1, mdelta: 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(12345);",
                "    rng.advance(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(12345);",
                  "    rng.advance(1);",
                  "    assert_eq!(rng.state, expected_state_after_advance_1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(12345);",
                  "    rng.advance(1);",
                  "    let mut rng = Mcg128Xsl64::new(12345);",
                  "    rng.advance(1);",
                  "    assert_eq!(rng.state, expected_state_after_advance_1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling rand_pcg v0.9.0 (/home/utgen/workspace/rand/rand_pcg)\nerror[E0425]: cannot find value `expected_state_after_advance_1` in this scope\n   --> rand_pcg/src/pcg128.rs:285:27\n    |\n285 |     assert_eq!(rng.state, expected_state_after_advance_1);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `rand_pcg` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(12345);",
                "    let large_mdelta: u128 = u128::MAX - 1; // edge case near the upper bound",
                "    rng.advance(large_mdelta);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(12345);",
                  "    let large_mdelta: u128 = u128::MAX - 1;",
                  "    rng.advance(large_mdelta);",
                  "    assert_eq!(rng.state, expected_state_for_large_mdelta);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(12345);",
                  "    let large_mdelta: u128 = u128::MAX - 1; // edge case near the upper bound",
                  "    rng.advance(large_mdelta);",
                  "    let mut rng = Mcg128Xsl64::new(12345);",
                  "    let large_mdelta: u128 = u128::MAX - 1;",
                  "    rng.advance(large_mdelta);",
                  "    assert_eq!(rng.state, expected_state_for_large_mdelta);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling rand_pcg v0.9.0 (/home/utgen/workspace/rand/rand_pcg)\nerror[E0425]: cannot find value `expected_state_for_large_mdelta` in this scope\n   --> rand_pcg/src/pcg128.rs:287:27\n    |\n287 |     assert_eq!(rng.state, expected_state_for_large_mdelta);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `rand_pcg` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(67890);",
                "    rng.advance(2); // mdelta is even, (mdelta & 1) != 0 will be triggered in the next iteration",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(67890);",
                  "    rng.state = 67890 | 1;",
                  "    rng.advance(2);",
                  "    assert_eq!(rng.state, /* expected state after advancing 2 steps */);"
                ],
                [
                  "    let mut rng = Mcg128Xsl64::new(67890);",
                  "    rng.state = 67890 | 1;",
                  "    rng.advance(2);",
                  "    assert!(rng.state > 67890);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(67890);",
                  "    rng.advance(2); // mdelta is even, (mdelta & 1) != 0 will be triggered in the next iteration",
                  "    let mut rng = Mcg128Xsl64::new(67890);",
                  "    rng.state = 67890 | 1;",
                  "    rng.advance(2);",
                  "    assert_eq!(rng.state, /* expected state after advancing 2 steps */);",
                  "}"
                ],
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(67890);",
                  "    rng.advance(2); // mdelta is even, (mdelta & 1) != 0 will be triggered in the next iteration",
                  "    let mut rng = Mcg128Xsl64::new(67890);",
                  "    rng.state = 67890 | 1;",
                  "    rng.advance(2);",
                  "    assert!(rng.state > 67890);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling rand_pcg v0.9.0 (/home/utgen/workspace/rand/rand_pcg)\nerror: unexpected end of macro invocation\n   --> rand_pcg/src/pcg128.rs:286:26\n    |\n286 |     assert_eq!(rng.state, /* expected state after advancing 2 steps */);\n    |                          ^ missing tokens in macro arguments\n    |\nnote: while trying to match meta-variable `$right:expr`\n   --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/macros/mod.rs:37:18\n\nerror: could not compile `rand_pcg` (lib test) due to 1 previous error\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(13579);",
                "    rng.advance(0); // mdelta == 0 should trigger a panic since it doesn't satisfy the constraint",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(13579);",
                  "    rng.advance(0);",
                  "    assert!(panic_occurred);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(13579);",
                  "    rng.advance(0); // mdelta == 0 should trigger a panic since it doesn't satisfy the constraint",
                  "    let mut rng = Mcg128Xsl64::new(13579);",
                  "    rng.advance(0);",
                  "    assert!(panic_occurred);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling rand_pcg v0.9.0 (/home/utgen/workspace/rand/rand_pcg)\nerror[E0425]: cannot find value `panic_occurred` in this scope\n   --> rand_pcg/src/pcg128.rs:286:13\n    |\n286 |     assert!(panic_occurred);\n    |             ^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `rand_pcg` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: mdelta > 0 is true\n",
        "// constraint: (mdelta & 1) != 0 is false\n",
        "// constraint: mdelta > 0 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "mdelta = 1, mdelta = 2, mdelta = 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(42);",
                "    rng.advance(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(1);",
                  "    assert!(rng.state != initial_state);"
                ],
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(1);",
                  "    assert!(rng.state == initial_state.wrapping_mul(MULTIPLIER).wrapping_add(0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(1);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(1);",
                  "    assert!(rng.state != initial_state);",
                  "}"
                ],
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(1);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(1);",
                  "    assert!(rng.state == initial_state.wrapping_mul(MULTIPLIER).wrapping_add(0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(42);",
                "    rng.advance(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    assert_eq!(rng.state, expected_state_after_advance_2);"
                ],
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    assert!(rng.state > 0);"
                ],
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    assert!(rng.state != 42);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    assert_eq!(rng.state, expected_state_after_advance_2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    assert!(rng.state > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(2);",
                  "    assert!(rng.state != 42);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling rand_pcg v0.9.0 (/home/utgen/workspace/rand/rand_pcg)\nerror[E0425]: cannot find value `expected_state_after_advance_2` in this scope\n   --> rand_pcg/src/pcg128.rs:285:27\n    |\n285 |     assert_eq!(rng.state, expected_state_after_advance_2);\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nFor more information about this error, try `rustc --explain E0425`.\nerror: could not compile `rand_pcg` (lib test) due to 1 previous error\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(42);",
                "    rng.advance(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(0);",
                  "    assert_eq!(rng.state, 42 | 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(0);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(0);",
                  "    assert_eq!(rng.state, 42 | 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: mdelta > 0 is false, with bound mdelta == 0\n"
      ],
      "input_infer": "mdelta = 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(42);",
                "    rng.advance(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(0);",
                  "    assert_eq!(rng.state, initial_state);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    rng.advance(0);",
                  "    let mut rng = Mcg128Xsl64::new(42);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(0);",
                  "    assert_eq!(rng.state, initial_state);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut rng = Mcg128Xsl64::new(u128::MAX);",
                "    rng.advance(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut rng = Mcg128Xsl64::new(u128::MAX);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(0);",
                  "    assert_eq!(rng.state, initial_state);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut rng = Mcg128Xsl64::new(u128::MAX);",
                  "    rng.advance(0);",
                  "    let mut rng = Mcg128Xsl64::new(u128::MAX);",
                  "    let initial_state = rng.state;",
                  "    rng.advance(0);",
                  "    assert_eq!(rng.state, initial_state);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}