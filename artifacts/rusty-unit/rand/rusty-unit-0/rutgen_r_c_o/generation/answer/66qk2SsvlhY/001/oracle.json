[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: 0u32.into(),",
          "        b: 0u32.into(),",
          "        c: 0u32.into(),",
          "        d: 0u32.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 0u32.into());"
          ],
          [
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.b, 0u32.into());"
          ],
          [
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.c, 0u32.into());"
          ],
          [
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.d, 0u32.into());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: 0u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 0u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: 0u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.b, 0u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: 0u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.c, 0u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: 0u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State {",
            "    a: 0u32.into(),",
            "    b: 0u32.into(),",
            "    c: 0u32.into(),",
            "    d: 0u32.into(),",
            "    };",
            "    let result = round(state);",
            "    assert_eq!(result.d, 0u32.into());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: u32::MAX.into(),",
          "        b: u32::MAX.into(),",
          "        c: u32::MAX.into(),",
          "        d: u32::MAX.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, expected_a);"
          ],
          [
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, expected_b);"
          ],
          [
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, expected_c);"
          ],
          [
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, expected_d);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: u32::MAX.into(),",
            "        b: u32::MAX.into(),",
            "        c: u32::MAX.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, expected_a);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: u32::MAX.into(),",
            "        b: u32::MAX.into(),",
            "        c: u32::MAX.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, expected_b);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: u32::MAX.into(),",
            "        b: u32::MAX.into(),",
            "        c: u32::MAX.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, expected_c);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: u32::MAX.into(),",
            "        b: u32::MAX.into(),",
            "        c: u32::MAX.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: u32::MAX.into(), b: u32::MAX.into(), c: u32::MAX.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, expected_d);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: 123456789u32.into(),",
          "        b: 987654321u32.into(),",
          "        c: 555555555u32.into(),",
          "        d: 111111111u32.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.a, 123456789u32.into());"
          ],
          [
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.b, 987654321u32.into());"
          ],
          [
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.c, 555555555u32.into());"
          ],
          [
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.d, 111111111u32.into());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: 123456789u32.into(),",
            "        b: 987654321u32.into(),",
            "        c: 555555555u32.into(),",
            "        d: 111111111u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.a, 123456789u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 123456789u32.into(),",
            "        b: 987654321u32.into(),",
            "        c: 555555555u32.into(),",
            "        d: 111111111u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.b, 987654321u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 123456789u32.into(),",
            "        b: 987654321u32.into(),",
            "        c: 555555555u32.into(),",
            "        d: 111111111u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.c, 555555555u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 123456789u32.into(),",
            "        b: 987654321u32.into(),",
            "        c: 555555555u32.into(),",
            "        d: 111111111u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 123456789u32.into(), b: 987654321u32.into(), c: 555555555u32.into(), d: 111111111u32.into(), };",
            "    assert_eq!(state.d, 111111111u32.into());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: 0u32.into(),",
          "        b: 123456789u32.into(),",
          "        c: u32::MAX.into(),",
          "        d: 999999999u32.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 123456789);"
          ],
          [
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, 123456789 ^ (999999999 + 123456789).rotate_each_word_right20());"
          ],
          [
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, u32::MAX + ((999999999 ^ 123456789).rotate_each_word_right16()));"
          ],
          [
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, (999999999 ^ (123456789 + 123456789 ^ (999999999 ^ 123456789).rotate_each_word_right16())).rotate_each_word_right24());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 123456789u32.into(),",
            "        c: u32::MAX.into(),",
            "        d: 999999999u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 123456789);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 123456789u32.into(),",
            "        c: u32::MAX.into(),",
            "        d: 999999999u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, 123456789 ^ (999999999 + 123456789).rotate_each_word_right20());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 123456789u32.into(),",
            "        c: u32::MAX.into(),",
            "        d: 999999999u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, u32::MAX + ((999999999 ^ 123456789).rotate_each_word_right16()));",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 0u32.into(),",
            "        b: 123456789u32.into(),",
            "        c: u32::MAX.into(),",
            "        d: 999999999u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 0u32.into(), b: 123456789u32.into(), c: u32::MAX.into(), d: 999999999u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, (999999999 ^ (123456789 + 123456789 ^ (999999999 ^ 123456789).rotate_each_word_right16())).rotate_each_word_right24());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: 1u32.into(),",
          "        b: 0u32.into(),",
          "        c: 0u32.into(),",
          "        d: u32::MAX.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 1u32);"
          ],
          [
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, u32::MAX);"
          ],
          [
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, u32::MAX);"
          ],
          [
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, 0u32);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 1u32);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, u32::MAX);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, u32::MAX);",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 0u32.into(),",
            "        c: 0u32.into(),",
            "        d: u32::MAX.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 0u32.into(), c: 0u32.into(), d: u32::MAX.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, 0u32);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: 1u32.into(),",
          "        b: 2u32.into(),",
          "        c: 3u32.into(),",
          "        d: 4u32.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 3.into());"
          ],
          [
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, 0.into());"
          ],
          [
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, 4.into());"
          ],
          [
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, 7.into());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 2u32.into(),",
            "        c: 3u32.into(),",
            "        d: 4u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 3.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 2u32.into(),",
            "        c: 3u32.into(),",
            "        d: 4u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, 0.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 2u32.into(),",
            "        c: 3u32.into(),",
            "        d: 4u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, 4.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 1u32.into(),",
            "        b: 2u32.into(),",
            "        c: 3u32.into(),",
            "        d: 4u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 1u32.into(), b: 2u32.into(), c: 3u32.into(), d: 4u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, 7.into());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let state = State {",
          "        a: 4000000000u32.into(),",
          "        b: 3000000000u32.into(),",
          "        c: 2000000000u32.into(),",
          "        d: 1000000000u32.into(),",
          "    };",
          "    round(state);",
          "}"
        ],
        "oracles": [
          [
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 7000000000u32.into());"
          ],
          [
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, (3000000000u32 ^ (2000000000u32 + (1000000000u32 ^ 7000000000u32))).rotate_each_word_right20().into());"
          ],
          [
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, (2000000000u32 + (1000000000u32 ^ 7000000000u32.rotate_each_word_right24())).into());"
          ],
          [
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, ((1000000000u32 ^ 7000000000u32).rotate_each_word_right16()).into());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let state = State {",
            "        a: 4000000000u32.into(),",
            "        b: 3000000000u32.into(),",
            "        c: 2000000000u32.into(),",
            "        d: 1000000000u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.a, 7000000000u32.into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 4000000000u32.into(),",
            "        b: 3000000000u32.into(),",
            "        c: 2000000000u32.into(),",
            "        d: 1000000000u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.b, (3000000000u32 ^ (2000000000u32 + (1000000000u32 ^ 7000000000u32))).rotate_each_word_right20().into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 4000000000u32.into(),",
            "        b: 3000000000u32.into(),",
            "        c: 2000000000u32.into(),",
            "        d: 1000000000u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.c, (2000000000u32 + (1000000000u32 ^ 7000000000u32.rotate_each_word_right24())).into());",
            "}"
          ],
          [
            "{",
            "    let state = State {",
            "        a: 4000000000u32.into(),",
            "        b: 3000000000u32.into(),",
            "        c: 2000000000u32.into(),",
            "        d: 1000000000u32.into(),",
            "    };",
            "    round(state);",
            "    let state = State { a: 4000000000u32.into(), b: 3000000000u32.into(), c: 2000000000u32.into(), d: 1000000000u32.into() };",
            "    let result = round(state);",
            "    assert_eq!(result.d, ((1000000000u32 ^ 7000000000u32).rotate_each_word_right16()).into());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]