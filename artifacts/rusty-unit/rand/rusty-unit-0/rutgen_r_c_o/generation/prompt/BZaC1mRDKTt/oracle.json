{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/coin_flipper.rs\n// crate name is rand\nuse crate::RngCore;\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {}\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n        while n < d {\n            let c = n.leading_zeros().saturating_sub(d.leading_zeros() + 1).clamp(1, 32);\n            if self.flip_c_heads(c) {\n                n = n.saturating_mul(2_usize.pow(c));\n            } else {\n                if c == 1 {\n                    let next_n = n.wrapping_add(n).wrapping_sub(d);\n                    if next_n == 0 || next_n > n {\n                        return false;\n                    }\n                    n = next_n;\n                } else {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {\n        debug_assert!(c <= 32);\n        loop {\n            let zeros = self.chunk.leading_zeros();\n            if zeros < c {\n                self.chunk = self.chunk.wrapping_shl(zeros + 1);\n                self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);\n                return false;\n            } else {\n                if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {\n                    self.chunk_remaining = new_remaining;\n                    self.chunk <<= c;\n                    return true;\n                } else {\n                    c -= self.chunk_remaining;\n                    self.chunk = self.rng.next_u32();\n                    self.chunk_remaining = 32;\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Returns true with a probability of n / d\n/// Uses an expected two bits of randomness\nfn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n    // Explanation:\n    // We are trying to return true with a probability of n / d\n    // If n >= d, we can just return true\n    // Otherwise there are two possibilities 2n < d and 2n >= d\n    // In either case we flip a coin.\n    // If 2n < d\n    //  If it comes up tails, return false\n    //  If it comes up heads, double n and start again\n    //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n    // (if 2n was greater than d we would effectively round it down to 1\n    // by returning true)\n    // If 2n >= d\n    //  If it comes up tails, set n to 2n - d and start again\n    //  If it comes up heads, return true\n    //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n    //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n    //  before restarting which is equivalent to returning false.\n\n    // As a performance optimization we can flip multiple coins at once\n    // This is efficient because we can use the `lzcnt` intrinsic\n    // We can check up to 32 flips at once but we only receive one bit of information\n    // - all heads or at least one tail.\n\n    // Let c be the number of coins to flip. 1 <= c <= 32\n    // If 2n < d, n * 2^c < d\n    // If the result is all heads, then set n to n * 2^c\n    // If there was at least one tail, return false\n    // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n    // Ideally, c will be as high as possible within these constraints\n\n    while n < d {\n        // Find a good value for c by counting leading zeros\n        // This will either give the highest possible c, or 1 less than that\n        let c = n\n            .leading_zeros()\n            .saturating_sub(d.leading_zeros() + 1)\n            .clamp(1, 32);\n\n        if self.flip_c_heads(c) {\n            // All heads\n            // Set n to n * 2^c\n            // If 2n >= d, the while loop will exit and we will return `true`\n            // If n * 2^c > `usize::MAX` we always return `true` anyway\n            n = n.saturating_mul(2_usize.pow(c));\n        } else {\n            // At least one tail\n            if c == 1 {\n                // Calculate 2n - d.\n                // We need to use wrapping as 2n might be greater than `usize::MAX`\n                let next_n = n.wrapping_add(n).wrapping_sub(d);\n                if next_n == 0 || next_n > n {\n                    // This will happen if 2n < d\n                    return false;\n                }\n                n = next_n;\n            } else {\n                // c > 1 so 2n < d so we can return false\n                return false;\n            }\n        }\n    }\n    true\n}\n",
  "depend_pt": ""
}