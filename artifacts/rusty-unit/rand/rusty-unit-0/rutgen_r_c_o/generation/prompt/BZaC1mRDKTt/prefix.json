{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. Omit test oracles and assertions; concentrate on generating test inputs and function calls of the focal function; do not use \"_\" for the return values of the focal function.\n3. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context.\n5. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides.\n6. If the method under test uses generics, instantiate them with suitable types based on the context.\n7. Define any necessary helper structures or implementations directly within the test function when required.\n8. Create a minimal yet comprehensive set of test functions, ensuring each test input satisfies all given constraints, with some explicitly covering edge scenarios.\n9. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/seq/coin_flipper.rs\n// crate name is rand\nuse crate::RngCore;\npub(crate) struct CoinFlipper<R: RngCore> {\n    pub rng: R,\n    chunk: u32,\n    chunk_remaining: u32,\n}\nimpl<R: RngCore> CoinFlipper<R> {\n    pub fn new(rng: R) -> Self {\n        Self {\n            rng,\n            chunk: 0,\n            chunk_remaining: 0,\n        }\n    }\n    #[inline]\n    pub fn random_ratio_one_over(&mut self, d: usize) -> bool {}\n    #[inline]\n    fn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n        while n < d {\n            let c = n.leading_zeros().saturating_sub(d.leading_zeros() + 1).clamp(1, 32);\n            if self.flip_c_heads(c) {\n                n = n.saturating_mul(2_usize.pow(c));\n            } else {\n                if c == 1 {\n                    let next_n = n.wrapping_add(n).wrapping_sub(d);\n                    if next_n == 0 || next_n > n {\n                        return false;\n                    }\n                    n = next_n;\n                } else {\n                    return false;\n                }\n            }\n        }\n        true\n    }\n    fn flip_c_heads(&mut self, mut c: u32) -> bool {\n        debug_assert!(c <= 32);\n        loop {\n            let zeros = self.chunk.leading_zeros();\n            if zeros < c {\n                self.chunk = self.chunk.wrapping_shl(zeros + 1);\n                self.chunk_remaining = self.chunk_remaining.saturating_sub(zeros + 1);\n                return false;\n            } else {\n                if let Some(new_remaining) = self.chunk_remaining.checked_sub(c) {\n                    self.chunk_remaining = new_remaining;\n                    self.chunk <<= c;\n                    return true;\n                } else {\n                    c -= self.chunk_remaining;\n                    self.chunk = self.rng.next_u32();\n                    self.chunk_remaining = 32;\n                }\n            }\n        }\n    }\n}\n\nThe function to be tested is presented as follows:\n/// Returns true with a probability of n / d\n/// Uses an expected two bits of randomness\nfn random_ratio(&mut self, mut n: usize, d: usize) -> bool {\n    // Explanation:\n    // We are trying to return true with a probability of n / d\n    // If n >= d, we can just return true\n    // Otherwise there are two possibilities 2n < d and 2n >= d\n    // In either case we flip a coin.\n    // If 2n < d\n    //  If it comes up tails, return false\n    //  If it comes up heads, double n and start again\n    //  This is fair because (0.5 * 0) + (0.5 * 2n / d) = n / d and 2n is less than d\n    // (if 2n was greater than d we would effectively round it down to 1\n    // by returning true)\n    // If 2n >= d\n    //  If it comes up tails, set n to 2n - d and start again\n    //  If it comes up heads, return true\n    //  This is fair because (0.5 * 1) + (0.5 * (2n - d) / d) = n / d\n    //  Note that if 2n = d and the coin comes up tails, n will be set to 0\n    //  before restarting which is equivalent to returning false.\n\n    // As a performance optimization we can flip multiple coins at once\n    // This is efficient because we can use the `lzcnt` intrinsic\n    // We can check up to 32 flips at once but we only receive one bit of information\n    // - all heads or at least one tail.\n\n    // Let c be the number of coins to flip. 1 <= c <= 32\n    // If 2n < d, n * 2^c < d\n    // If the result is all heads, then set n to n * 2^c\n    // If there was at least one tail, return false\n    // If 2n >= d, the order of results matters so we flip one coin at a time so c = 1\n    // Ideally, c will be as high as possible within these constraints\n\n    while n < d {\n        // Find a good value for c by counting leading zeros\n        // This will either give the highest possible c, or 1 less than that\n        let c = n\n            .leading_zeros()\n            .saturating_sub(d.leading_zeros() + 1)\n            .clamp(1, 32);\n\n        if self.flip_c_heads(c) {\n            // All heads\n            // Set n to n * 2^c\n            // If 2n >= d, the while loop will exit and we will return `true`\n            // If n * 2^c > `usize::MAX` we always return `true` anyway\n            n = n.saturating_mul(2_usize.pow(c));\n        } else {\n            // At least one tail\n            if c == 1 {\n                // Calculate 2n - d.\n                // We need to use wrapping as 2n might be greater than `usize::MAX`\n                let next_n = n.wrapping_add(n).wrapping_sub(d);\n                if next_n == 0 || next_n > n {\n                    // This will happen if 2n < d\n                    return false;\n                }\n                n = next_n;\n            } else {\n                // c > 1 so 2n < d so we can return false\n                return false;\n            }\n        }\n    }\n    true\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}