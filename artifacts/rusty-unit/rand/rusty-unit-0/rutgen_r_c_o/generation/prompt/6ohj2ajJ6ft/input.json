{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// rand_core/src/impls.rs\n// crate name is rand_core\nuse crate::RngCore;\n#[deprecated(since = \"0.9.3\", note = \"use BlockRng instead\")]\npub fn fill_via_u32_chunks(src: &mut [u32], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks(src, dest)\n}\npub(crate) fn fill_via_chunks<T: Observable>(\n    src: &[T],\n    dest: &mut [u8],\n) -> (usize, usize) {\n    let size = core::mem::size_of::<T>();\n    let mut dest = dest.chunks_exact_mut(size);\n    let mut src = src.iter();\n    let zipped = dest.by_ref().zip(src.by_ref());\n    let num_chunks = zipped.len();\n    zipped.for_each(|(dest, src)| dest.copy_from_slice(src.to_le_bytes().as_ref()));\n    let byte_len = num_chunks * size;\n    if let Some(src) = src.next() {\n        let dest = dest.into_remainder();\n        let n = dest.len();\n        if n > 0 {\n            dest.copy_from_slice(&src.to_le_bytes().as_ref()[..n]);\n            return (num_chunks + 1, byte_len + n);\n        }\n    }\n    (num_chunks, byte_len)\n}\n\nThe function to be tested is presented as follows:\n/// Implement `fill_bytes` by reading chunks from the output buffer of a block\n/// based RNG.\n///\n/// The return values are `(consumed_u32, filled_u8)`.\n///\n/// `src` is not modified; it is taken as a `&mut` reference for backward\n/// compatibility with previous versions that did change it.\n///\n/// `filled_u8` is the number of filled bytes in `dest`, which may be less than\n/// the length of `dest`.\n/// `consumed_u32` is the number of words consumed from `src`, which is the same\n/// as `filled_u8 / 4` rounded up.\n///\n/// # Example\n/// (from `IsaacRng`)\n///\n/// ```ignore\n/// fn fill_bytes(&mut self, dest: &mut [u8]) {\n///     let mut read_len = 0;\n///     while read_len < dest.len() {\n///         if self.index >= self.rsl.len() {\n///             self.isaac();\n///         }\n///\n///         let (consumed_u32, filled_u8) =\n///             impls::fill_via_u32_chunks(&mut self.rsl[self.index..],\n///                                        &mut dest[read_len..]);\n///\n///         self.index += consumed_u32;\n///         read_len += filled_u8;\n///     }\n/// }\n/// ```\npub fn fill_via_u32_chunks(src: &mut [u32], dest: &mut [u8]) -> (usize, usize) {\n    fill_via_chunks(src, dest)\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}