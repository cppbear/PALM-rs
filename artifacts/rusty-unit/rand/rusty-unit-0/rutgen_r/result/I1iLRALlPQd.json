{
    "function_name": "rand::rngs::xoshiro256plusplus::<rngs::xoshiro256plusplus::Xoshiro256PlusPlus as rand_core::SeedableRng>::seed_from_u64",
    "tests": 6,
    "tests_lines": [
        25,
        25,
        5,
        7,
        7,
        30
    ],
    "oracles": 6,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 6,
    "tests_compiled_rate": 100.0,
    "oracles_run": 6,
    "oracles_passed": 6,
    "oracles_passed_rate": 100.0,
    "tests_run": 6,
    "tests_passed": 6,
    "tests_passed_rate": 100.0,
    "lines": 13,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        50,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        63,
        64,
        65
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct Xoshiro256PlusPlus {",
                "        s: [u64; 4],",
                "    }",
                "",
                "    impl Xoshiro256PlusPlus {",
                "        fn seed_from_u64(mut state: u64) -> Self {",
                "            const PHI: u64 = 0x9e3779b97f4a7c15;",
                "            let mut s = [0; 4];",
                "            for i in s.iter_mut() {",
                "                state = state.wrapping_add(PHI);",
                "                let mut z = state;",
                "                z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);",
                "                z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);",
                "                z = z ^ (z >> 31);",
                "                *i = z;",
                "            }",
                "            debug_assert_ne!(s, [0; 4]);",
                "            Xoshiro256PlusPlus { s }",
                "        }",
                "    }",
                "",
                "    let rng = Xoshiro256PlusPlus::seed_from_u64(123456789);",
                "    assert_ne!(rng.s, [0; 4]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Xoshiro256PlusPlus {",
                "        s: [u64; 4],",
                "    }",
                "",
                "    impl Xoshiro256PlusPlus {",
                "        fn seed_from_u64(mut state: u64) -> Self {",
                "            const PHI: u64 = 0x9e3779b97f4a7c15;",
                "            let mut s = [0; 4];",
                "            for i in s.iter_mut() {",
                "                state = state.wrapping_add(PHI);",
                "                let mut z = state;",
                "                z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);",
                "                z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);",
                "                z = z ^ (z >> 31);",
                "                *i = z;",
                "            }",
                "            debug_assert_ne!(s, [0; 4]);",
                "            Xoshiro256PlusPlus { s }",
                "        }",
                "    }",
                "",
                "    let rng = Xoshiro256PlusPlus::seed_from_u64(0);",
                "    assert_eq!(rng.s, [0; 4]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let seed: u64 = 123456789; // arbitrary non-zero seed",
                "    let rng = Xoshiro256PlusPlus::seed_from_u64(seed);",
                "    assert_ne!(rng.s, [0; 4]); // state should not be all zeros",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let seed1: u64 = 987654321; // different non-zero seed",
                "    let seed2: u64 = 234567890; // another different non-zero seed",
                "    let rng1 = Xoshiro256PlusPlus::seed_from_u64(seed1);",
                "    let rng2 = Xoshiro256PlusPlus::seed_from_u64(seed2);",
                "    assert_ne!(rng1.s, rng2.s); // different seeds should yield different states",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let seeds = [u64::MAX, 0xFFFFFFFFFFFFFFFF]; // maximum possible seed values",
                "    for &seed in &seeds {",
                "        let rng = Xoshiro256PlusPlus::seed_from_u64(seed);",
                "        assert_ne!(rng.s, [0; 4]); // state should not be all zeros",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Xoshiro256PlusPlus {",
                "        s: [u64; 4],",
                "    }",
                "    ",
                "    impl Xoshiro256PlusPlus {",
                "        fn seed_from_u64(mut state: u64) -> Self {",
                "            const PHI: u64 = 0x9e3779b97f4a7c15;",
                "            let mut s = [0; 4];",
                "            for i in s.iter_mut() {",
                "                state = state.wrapping_add(PHI);",
                "                let mut z = state;",
                "                z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);",
                "                z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);",
                "                z = z ^ (z >> 31);",
                "                *i = z;",
                "            }",
                "            debug_assert_ne!(s, [0; 4]);",
                "            Xoshiro256PlusPlus { s }",
                "        }",
                "    }",
                "",
                "    // Test input that guarantees non-zero state",
                "    let generator = Xoshiro256PlusPlus::seed_from_u64(1);",
                "    assert!(generator.s != [0; 4], \"Expected non-zero state in generator\");",
                "    ",
                "    // Test with a different state to ensure different output",
                "    let generator2 = Xoshiro256PlusPlus::seed_from_u64(2);",
                "    assert!(generator2.s != generator.s, \"Expected different states for different seeds\");",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct Xoshiro256PlusPlus {",
                "        s: [u64; 4],",
                "    }",
                "",
                "    impl Xoshiro256PlusPlus {",
                "        fn seed_from_u64(mut state: u64) -> Self {",
                "            const PHI: u64 = 0x9e3779b97f4a7c15;",
                "            let mut s = [0; 4];",
                "            for i in s.iter_mut() {",
                "                state = state.wrapping_add(PHI);",
                "                let mut z = state;",
                "                z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);",
                "                z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);",
                "                z = z ^ (z >> 31);",
                "                *i = z;",
                "            }",
                "            debug_assert_ne!(s, [0; 4]);",
                "            Xoshiro256PlusPlus { s }",
                "        }",
                "    }",
                "",
                "    let rng = Xoshiro256PlusPlus::seed_from_u64(123456789);",
                "    assert_ne!(rng.s, [0; 4]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Xoshiro256PlusPlus {",
                "        s: [u64; 4],",
                "    }",
                "",
                "    impl Xoshiro256PlusPlus {",
                "        fn seed_from_u64(mut state: u64) -> Self {",
                "            const PHI: u64 = 0x9e3779b97f4a7c15;",
                "            let mut s = [0; 4];",
                "            for i in s.iter_mut() {",
                "                state = state.wrapping_add(PHI);",
                "                let mut z = state;",
                "                z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);",
                "                z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);",
                "                z = z ^ (z >> 31);",
                "                *i = z;",
                "            }",
                "            debug_assert_ne!(s, [0; 4]);",
                "            Xoshiro256PlusPlus { s }",
                "        }",
                "    }",
                "",
                "    let rng = Xoshiro256PlusPlus::seed_from_u64(0);",
                "    assert_eq!(rng.s, [0; 4]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let seed: u64 = 123456789; // arbitrary non-zero seed",
                "    let rng = Xoshiro256PlusPlus::seed_from_u64(seed);",
                "    assert_ne!(rng.s, [0; 4]); // state should not be all zeros",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let seed1: u64 = 987654321; // different non-zero seed",
                "    let seed2: u64 = 234567890; // another different non-zero seed",
                "    let rng1 = Xoshiro256PlusPlus::seed_from_u64(seed1);",
                "    let rng2 = Xoshiro256PlusPlus::seed_from_u64(seed2);",
                "    assert_ne!(rng1.s, rng2.s); // different seeds should yield different states",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let seeds = [u64::MAX, 0xFFFFFFFFFFFFFFFF]; // maximum possible seed values",
                "    for &seed in &seeds {",
                "        let rng = Xoshiro256PlusPlus::seed_from_u64(seed);",
                "        assert_ne!(rng.s, [0; 4]); // state should not be all zeros",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct Xoshiro256PlusPlus {",
                "        s: [u64; 4],",
                "    }",
                "    ",
                "    impl Xoshiro256PlusPlus {",
                "        fn seed_from_u64(mut state: u64) -> Self {",
                "            const PHI: u64 = 0x9e3779b97f4a7c15;",
                "            let mut s = [0; 4];",
                "            for i in s.iter_mut() {",
                "                state = state.wrapping_add(PHI);",
                "                let mut z = state;",
                "                z = (z ^ (z >> 30)).wrapping_mul(0xbf58476d1ce4e5b9);",
                "                z = (z ^ (z >> 27)).wrapping_mul(0x94d049bb133111eb);",
                "                z = z ^ (z >> 31);",
                "                *i = z;",
                "            }",
                "            debug_assert_ne!(s, [0; 4]);",
                "            Xoshiro256PlusPlus { s }",
                "        }",
                "    }",
                "",
                "    // Test input that guarantees non-zero state",
                "    let generator = Xoshiro256PlusPlus::seed_from_u64(1);",
                "    assert!(generator.s != [0; 4], \"Expected non-zero state in generator\");",
                "    ",
                "    // Test with a different state to ensure different output",
                "    let generator2 = Xoshiro256PlusPlus::seed_from_u64(2);",
                "    assert!(generator2.s != generator.s, \"Expected different states for different seeds\");",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/rand/rusty-unit-0/src/rngs/xoshiro256plusplus.rs"
}