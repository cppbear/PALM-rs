{
    "function_name": "rand::seq::increasing_uniform::seq::increasing_uniform::IncreasingUniform<R>::next_index",
    "tests": 4,
    "tests_lines": [
        39,
        36,
        59,
        55
    ],
    "oracles": 4,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 50.0,
    "oracles_run": 2,
    "oracles_passed": 2,
    "oracles_passed_rate": 100.0,
    "tests_run": 2,
    "tests_passed": 2,
    "tests_passed_rate": 100.0,
    "lines": 28,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 2,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        60,
        64,
        68,
        69,
        70,
        73,
        74,
        75,
        76
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct RngStub {",
                "        current: u32,",
                "    }",
                "    ",
                "    impl RngStub {",
                "        fn random_range(&self, range: std::ops::Range<u32>) -> u32 {",
                "            self.current % (range.end - range.start) + range.start",
                "        }",
                "    }",
                "",
                "    struct Sequence {",
                "        n: u32,",
                "        chunk: u32,",
                "        chunk_remaining: u32,",
                "        rng: RngStub,",
                "    }",
                "",
                "    impl Sequence {",
                "        fn new() -> Self {",
                "            Sequence {",
                "                n: 0,",
                "                chunk: 0,",
                "                chunk_remaining: 0,",
                "                rng: RngStub { current: 0 },",
                "            }",
                "        }",
                "",
                "        fn next_index(&mut self) -> usize {",
                "            let next_n = self.n + 1;",
                "            let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {",
                "                let (bound, remaining) = (next_n + 1, 2); // Stub for calculate_bound_u32",
                "                self.chunk = self.rng.random_range(0..bound);",
                "                remaining - 1",
                "            });",
                "",
                "            let result = if next_chunk_remaining == 0 {",
                "                self.chunk as usize",
                "            } else {",
                "                let r = self.chunk % next_n;",
                "                self.chunk /= next_n;",
                "                r as usize",
                "            };",
                "",
                "            self.chunk_remaining = next_chunk_remaining;",
                "            self.n = next_n;",
                "            result",
                "        }",
                "    }",
                "",
                "    let mut sequence = Sequence::new();",
                "    ",
                "    // Setting up an initial state where chunk_remaining becomes 0",
                "    sequence.chunk_remaining = 0; ",
                "    sequence.chunk = 4; // Random chunk value for testing",
                "    let result = sequence.next_index();",
                "    ",
                "    assert!(result < 1); // since n will be 1, return value must be in [0, 1)",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct RngStub {",
                "        current: u32,",
                "    }",
                "",
                "    impl RngStub {",
                "        fn random_range(&self, range: std::ops::Range<u32>) -> u32 {",
                "            self.current % (range.end - range.start) + range.start",
                "        }",
                "    }",
                "",
                "    struct Sequence {",
                "        n: u32,",
                "        chunk: u32,",
                "        chunk_remaining: u32,",
                "        rng: RngStub,",
                "    }",
                "",
                "    impl Sequence {",
                "        fn new() -> Self {",
                "            Sequence {",
                "                n: u32::MAX,",
                "                chunk: 0,",
                "                chunk_remaining: 0,",
                "                rng: RngStub { current: 0 },",
                "            }",
                "        }",
                "",
                "        fn next_index(&mut self) -> usize {",
                "            let next_n = self.n + 1; // This will overflow",
                "            let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {",
                "                let (bound, remaining) = (next_n + 1, 2); // Stub for calculate_bound_u32",
                "                self.chunk = self.rng.random_range(0..bound);",
                "                remaining - 1",
                "            });",
                "",
                "            let result = if next_chunk_remaining == 0 {",
                "                self.chunk as usize",
                "            } else {",
                "                let r = self.chunk % next_n;",
                "                self.chunk /= next_n;",
                "                r as usize",
                "            };",
                "",
                "            self.chunk_remaining = next_chunk_remaining;",
                "            self.n = next_n;",
                "            result",
                "        }",
                "    }",
                "    ",
                "    let mut sequence = Sequence::new();",
                "    ",
                "    // This will trigger panic due to n reaching u32::MAX",
                "    let _ = sequence.next_index();",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 60,
            "start_column": 25,
            "end_line": 60,
            "end_column": 50,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct RngStub {",
                "        current: u32,",
                "    }",
                "    ",
                "    impl RngStub {",
                "        fn random_range(&self, range: std::ops::Range<u32>) -> u32 {",
                "            self.current % (range.end - range.start) + range.start",
                "        }",
                "    }",
                "",
                "    struct Sequence {",
                "        n: u32,",
                "        chunk: u32,",
                "        chunk_remaining: u32,",
                "        rng: RngStub,",
                "    }",
                "",
                "    impl Sequence {",
                "        fn new() -> Self {",
                "            Sequence {",
                "                n: 0,",
                "                chunk: 0,",
                "                chunk_remaining: 0,",
                "                rng: RngStub { current: 0 },",
                "            }",
                "        }",
                "",
                "        fn next_index(&mut self) -> usize {",
                "            let next_n = self.n + 1;",
                "            let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {",
                "                let (bound, remaining) = (next_n + 1, 2); // Stub for calculate_bound_u32",
                "                self.chunk = self.rng.random_range(0..bound);",
                "                remaining - 1",
                "            });",
                "",
                "            let result = if next_chunk_remaining == 0 {",
                "                self.chunk as usize",
                "            } else {",
                "                let r = self.chunk % next_n;",
                "                self.chunk /= next_n;",
                "                r as usize",
                "            };",
                "",
                "            self.chunk_remaining = next_chunk_remaining;",
                "            self.n = next_n;",
                "            result",
                "        }",
                "    }",
                "",
                "    let mut sequence = Sequence::new();",
                "    ",
                "    // Setting up an initial state where chunk_remaining becomes 0",
                "    sequence.chunk_remaining = 0; ",
                "    sequence.chunk = 4; // Random chunk value for testing",
                "    let result = sequence.next_index();",
                "    ",
                "    assert!(result < 1); // since n will be 1, return value must be in [0, 1)",
                "}"
            ],
            [
                {
                    "start_line": 60,
                    "start_column": 25,
                    "end_line": 60,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct RngStub {",
                "        current: u32,",
                "    }",
                "",
                "    impl RngStub {",
                "        fn random_range(&self, range: std::ops::Range<u32>) -> u32 {",
                "            self.current % (range.end - range.start) + range.start",
                "        }",
                "    }",
                "",
                "    struct Sequence {",
                "        n: u32,",
                "        chunk: u32,",
                "        chunk_remaining: u32,",
                "        rng: RngStub,",
                "    }",
                "",
                "    impl Sequence {",
                "        fn new() -> Self {",
                "            Sequence {",
                "                n: u32::MAX,",
                "                chunk: 0,",
                "                chunk_remaining: 0,",
                "                rng: RngStub { current: 0 },",
                "            }",
                "        }",
                "",
                "        fn next_index(&mut self) -> usize {",
                "            let next_n = self.n + 1; // This will overflow",
                "            let next_chunk_remaining = self.chunk_remaining.checked_sub(1).unwrap_or_else(|| {",
                "                let (bound, remaining) = (next_n + 1, 2); // Stub for calculate_bound_u32",
                "                self.chunk = self.rng.random_range(0..bound);",
                "                remaining - 1",
                "            });",
                "",
                "            let result = if next_chunk_remaining == 0 {",
                "                self.chunk as usize",
                "            } else {",
                "                let r = self.chunk % next_n;",
                "                self.chunk /= next_n;",
                "                r as usize",
                "            };",
                "",
                "            self.chunk_remaining = next_chunk_remaining;",
                "            self.n = next_n;",
                "            result",
                "        }",
                "    }",
                "    ",
                "    let mut sequence = Sequence::new();",
                "    ",
                "    // This will trigger panic due to n reaching u32::MAX",
                "    let _ = sequence.next_index();",
                "}"
            ],
            [
                {
                    "start_line": 60,
                    "start_column": 25,
                    "end_line": 60,
                    "end_column": 50,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/rand/rusty-unit-0/src/seq/increasing_uniform.rs"
}