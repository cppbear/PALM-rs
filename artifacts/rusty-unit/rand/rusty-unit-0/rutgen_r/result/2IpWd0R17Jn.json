{
    "function_name": "rand_core::le::read_u32_into",
    "tests": 11,
    "tests_lines": [
        8,
        6,
        6,
        6,
        8,
        7,
        8,
        8,
        8,
        5,
        5
    ],
    "oracles": 11,
    "oracles_compiled": 11,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 11,
    "tests_compiled_rate": 100.0,
    "oracles_run": 11,
    "oracles_passed": 9,
    "oracles_passed_rate": 81.81818181818183,
    "tests_run": 11,
    "tests_passed": 9,
    "tests_passed_rate": 81.81818181818183,
    "lines": 6,
    "lines_covered": 6,
    "lines_coveraged_rate": 100.0,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        24,
        25,
        26,
        27,
        28,
        29
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0];",
                "    let mut dst = [0u32; 4];",
                "    ",
                "    read_u32_into(src, &mut dst);",
                "    ",
                "    assert_eq!(dst, [1, 2, 3, 4]);",
                "}"
            ],
            [
                24,
                25,
                26,
                27,
                28,
                29
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst = [0u32; 3];",
                "    ",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            [
                24,
                25
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 0, 0];  // Not enough bytes for one u32",
                "    let mut dst = [0u32; 1];",
                "",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            [
                24,
                25
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[];",
                "    let mut dst = [0u32; 1]; // One u32 would require 4 bytes",
                "",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            [
                24,
                25
            ]
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // length 16 bytes",
                "    let mut dst: [u32; 4] = [0; 4]; // length 4",
                "",
                "    read_u32_into(&src, &mut dst);",
                "",
                "    assert_eq!(dst, [1, 2, 3, 4]);",
                "}"
            ],
            [
                24,
                25,
                26,
                27,
                28,
                29
            ]
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // length 8 bytes",
                "    let mut dst: [u32; 3] = [0; 3]; // length 3",
                "",
                "    // This should panic because 8 < 4 * 3",
                "    read_u32_into(&src, &mut dst);",
                "}"
            ],
            [
                24,
                25
            ]
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![1, 0, 0, 0]; // length 4 bytes",
                "    let mut dst: [u32; 0] = []; // length 0",
                "",
                "    read_u32_into(&src, &mut dst);",
                "",
                "    assert_eq!(dst.len(), 0);",
                "}"
            ],
            [
                24,
                25,
                26,
                29
            ]
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![]; // length 0 bytes",
                "    let mut dst: [u32; 0] = []; // length 0",
                "",
                "    read_u32_into(&src, &mut dst);",
                "",
                "    assert_eq!(dst.len(), 0);",
                "}"
            ],
            [
                24,
                25,
                26,
                29
            ]
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = (0..u32::MAX).flat_map(|i| i.to_le_bytes()).collect(); // large src",
                "    let mut dst: [u32; 1] = [0]; // length 1",
                "",
                "    read_u32_into(&src[..4], &mut dst); // Use first 4 bytes for a single u32",
                "",
                "    assert_eq!(dst[0], 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 2, 3]; // Length is 3, which is less than 4 * dst.len() where dst.len() = 1.",
                "    let mut dst: [u32; 1] = [0];",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            [
                24,
                25
            ]
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8]; // Sufficient length for dst.len() = 0.",
                "    let mut dst: [u32; 0] = [];",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            [
                24,
                25,
                26,
                29
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0];",
                "    let mut dst = [0u32; 4];",
                "    ",
                "    read_u32_into(src, &mut dst);",
                "    ",
                "    assert_eq!(dst, [1, 2, 3, 4]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 0, 0, 0, 2, 0, 0, 0];",
                "    let mut dst = [0u32; 3];",
                "    ",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 0, 0];  // Not enough bytes for one u32",
                "    let mut dst = [0u32; 1];",
                "",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[];",
                "    let mut dst = [0u32; 1]; // One u32 would require 4 bytes",
                "",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]; // length 16 bytes",
                "    let mut dst: [u32; 4] = [0; 4]; // length 4",
                "",
                "    read_u32_into(&src, &mut dst);",
                "",
                "    assert_eq!(dst, [1, 2, 3, 4]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![1, 0, 0, 0, 2, 0, 0, 0]; // length 8 bytes",
                "    let mut dst: [u32; 3] = [0; 3]; // length 3",
                "",
                "    // This should panic because 8 < 4 * 3",
                "    read_u32_into(&src, &mut dst);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![1, 0, 0, 0]; // length 4 bytes",
                "    let mut dst: [u32; 0] = []; // length 0",
                "",
                "    read_u32_into(&src, &mut dst);",
                "",
                "    assert_eq!(dst.len(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = vec![]; // length 0 bytes",
                "    let mut dst: [u32; 0] = []; // length 0",
                "",
                "    read_u32_into(&src, &mut dst);",
                "",
                "    assert_eq!(dst.len(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: Vec<u8> = (0..u32::MAX).flat_map(|i| i.to_le_bytes()).collect(); // large src",
                "    let mut dst: [u32; 1] = [0]; // length 1",
                "",
                "    read_u32_into(&src[..4], &mut dst); // Use first 4 bytes for a single u32",
                "",
                "    assert_eq!(dst[0], 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 2, 3]; // Length is 3, which is less than 4 * dst.len() where dst.len() = 1.",
                "    let mut dst: [u32; 1] = [0];",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let src: &[u8] = &[1, 2, 3, 4, 5, 6, 7, 8]; // Sufficient length for dst.len() = 0.",
                "    let mut dst: [u32; 0] = [];",
                "    read_u32_into(src, &mut dst);",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/rand/rusty-unit-0/rand_core/src/le.rs"
}