{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/d2s.rs\n// crate name is ryu\nuse crate::common::{log10_pow2, log10_pow5, pow5bits};\n#[cfg(not(feature = \"small\"))]\npub use crate::d2s_full_table::{DOUBLE_POW5_INV_SPLIT, DOUBLE_POW5_SPLIT};\nuse crate::d2s_intrinsics::{\n    div10, div100, div5, mul_shift_all_64, multiple_of_power_of_2, multiple_of_power_of_5,\n};\n#[cfg(feature = \"small\")]\npub use crate::d2s_small_table::{compute_inv_pow5, compute_pow5};\nuse core::mem::MaybeUninit;\npub const DOUBLE_MANTISSA_BITS: u32 = 52;\npub const DOUBLE_EXPONENT_BITS: u32 = 11;\npub const DOUBLE_BIAS: i32 = 1023;\npub const DOUBLE_POW5_INV_BITCOUNT: i32 = 125;\npub const DOUBLE_POW5_BITCOUNT: i32 = 125;\npub struct FloatingDecimal64 {\n    pub mantissa: u64,\n    pub exponent: i32,\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64 {\n    let (e2, m2) = if ieee_exponent == 0 {\n        (1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2, ieee_mantissa)\n    } else {\n        (\n            ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n    let mv = 4 * m2;\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    let mut vr: u64;\n    let mut vp: u64;\n    let mut vm: u64;\n    let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    if e2 >= 0 {\n        let q = log10_pow2(e2) - (e2 > 3) as u32;\n        e10 = q as i32;\n        let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_inv_pow5(q),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n                    DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n                },\n                i as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 21 {\n            let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n            if mv_mod5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n            } else if accept_bounds {\n                vm_is_trailing_zeros = multiple_of_power_of_5(\n                    mv - 1 - mm_shift as u64,\n                    q,\n                );\n            } else {\n                vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n            }\n        }\n    } else {\n        let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n        let j = q as i32 - k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_pow5(i as u32),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n                    DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n                },\n                j as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 1 {\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                vp -= 1;\n            }\n        } else if q < 63 {\n            vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n        }\n    }\n    let mut removed = 0i32;\n    let mut last_removed_digit = 0u8;\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            vm_is_trailing_zeros &= vm_mod10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = vr_mod10 as u8;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            loop {\n                let vm_div10 = div10(vm);\n                let vm_mod10 = (vm as u32)\n                    .wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n                if vm_mod10 != 0 {\n                    break;\n                }\n                let vp_div10 = div10(vp);\n                let vr_div10 = div10(vr);\n                let vr_mod10 = (vr as u32)\n                    .wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = vr_mod10 as u8;\n                vr = vr_div10;\n                vp = vp_div10;\n                vm = vm_div10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            last_removed_digit = 4;\n        }\n        vr\n            + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros))\n                || last_removed_digit >= 5) as u64\n    } else {\n        let mut round_up = false;\n        let vp_div100 = div100(vp);\n        let vm_div100 = div100(vm);\n        if vp_div100 > vm_div100 {\n            let vr_div100 = div100(vr);\n            let vr_mod100 = (vr as u32)\n                .wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n            round_up = vr_mod100 >= 50;\n            vr = vr_div100;\n            vp = vp_div100;\n            vm = vm_div100;\n            removed += 2;\n        }\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            round_up = vr_mod10 >= 5;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        vr + (vr == vm || round_up) as u64\n    };\n    let exp = e10 + removed;\n    FloatingDecimal64 {\n        exponent: exp,\n        mantissa: output,\n    }\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn log10_pow5(e: i32) -> u32 {\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 2620);\n    (e as u32 * 732923) >> 20\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn log10_pow2(e: i32) -> u32 {\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 1650);\n    (e as u32 * 78913) >> 18\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn div100(x: u64) -> u64 {\n    x / 100\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn div10(x: u64) -> u64 {\n    x / 10\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn multiple_of_power_of_2(value: u64, p: u32) -> bool {\n    debug_assert!(value != 0);\n    debug_assert!(p < 64);\n    (value & ((1u64 << p) - 1)) == 0\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn multiple_of_power_of_5(value: u64, p: u32) -> bool {\n    pow5_factor(value) >= p\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub unsafe fn mul_shift_all_64(\n    m: u64,\n    mul: &(u64, u64),\n    j: u32,\n    vp: *mut u64,\n    vm: *mut u64,\n    mm_shift: u32,\n) -> u64 {\n    ptr::write(vp, mul_shift_64(4 * m + 2, mul, j));\n    ptr::write(vm, mul_shift_64(4 * m - 1 - mm_shift as u64, mul, j));\n    mul_shift_64(4 * m, mul, j)\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn div5(x: u64) -> u64 {\n    x / 5\n}\n#[cfg_attr(feature = \"no-panic\", inline)]\npub fn pow5bits(e: i32) -> i32 {\n    debug_assert!(e >= 0);\n    debug_assert!(e <= 3528);\n    (((e as u32 * 1217359) >> 19) + 1) as i32\n}\n\nThe function to be tested is presented as follows:\npub fn d2d(ieee_mantissa: u64, ieee_exponent: u32) -> FloatingDecimal64 {\n    let (e2, m2) = if ieee_exponent == 0 {\n        (\n            // We subtract 2 so that the bounds computation has 2 additional bits.\n            1 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            ieee_mantissa,\n        )\n    } else {\n        (\n            ieee_exponent as i32 - DOUBLE_BIAS - DOUBLE_MANTISSA_BITS as i32 - 2,\n            (1u64 << DOUBLE_MANTISSA_BITS) | ieee_mantissa,\n        )\n    };\n    let even = (m2 & 1) == 0;\n    let accept_bounds = even;\n\n    // Step 2: Determine the interval of valid decimal representations.\n    let mv = 4 * m2;\n    // Implicit bool -> int conversion. True is 1, false is 0.\n    let mm_shift = (ieee_mantissa != 0 || ieee_exponent <= 1) as u32;\n    // We would compute mp and mm like this:\n    // uint64_t mp = 4 * m2 + 2;\n    // uint64_t mm = mv - 1 - mm_shift;\n\n    // Step 3: Convert to a decimal power base using 128-bit arithmetic.\n    let mut vr: u64;\n    let mut vp: u64;\n    let mut vm: u64;\n    let mut vp_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let mut vm_uninit: MaybeUninit<u64> = MaybeUninit::uninit();\n    let e10: i32;\n    let mut vm_is_trailing_zeros = false;\n    let mut vr_is_trailing_zeros = false;\n    if e2 >= 0 {\n        // I tried special-casing q == 0, but there was no effect on performance.\n        // This expression is slightly faster than max(0, log10_pow2(e2) - 1).\n        let q = log10_pow2(e2) - (e2 > 3) as u32;\n        e10 = q as i32;\n        let k = DOUBLE_POW5_INV_BITCOUNT + pow5bits(q as i32) - 1;\n        let i = -e2 + q as i32 + k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_inv_pow5(q),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(q < DOUBLE_POW5_INV_SPLIT.len() as u32);\n                    DOUBLE_POW5_INV_SPLIT.get_unchecked(q as usize)\n                },\n                i as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 21 {\n            // This should use q <= 22, but I think 21 is also safe. Smaller values\n            // may still be safe, but it's more difficult to reason about them.\n            // Only one of mp, mv, and mm can be a multiple of 5, if any.\n            let mv_mod5 = (mv as u32).wrapping_sub(5u32.wrapping_mul(div5(mv) as u32));\n            if mv_mod5 == 0 {\n                vr_is_trailing_zeros = multiple_of_power_of_5(mv, q);\n            } else if accept_bounds {\n                // Same as min(e2 + (~mm & 1), pow5_factor(mm)) >= q\n                // <=> e2 + (~mm & 1) >= q && pow5_factor(mm) >= q\n                // <=> true && pow5_factor(mm) >= q, since e2 >= q.\n                vm_is_trailing_zeros = multiple_of_power_of_5(mv - 1 - mm_shift as u64, q);\n            } else {\n                // Same as min(e2 + 1, pow5_factor(mp)) >= q.\n                vp -= multiple_of_power_of_5(mv + 2, q) as u64;\n            }\n        }\n    } else {\n        // This expression is slightly faster than max(0, log10_pow5(-e2) - 1).\n        let q = log10_pow5(-e2) - (-e2 > 1) as u32;\n        e10 = q as i32 + e2;\n        let i = -e2 - q as i32;\n        let k = pow5bits(i) - DOUBLE_POW5_BITCOUNT;\n        let j = q as i32 - k;\n        vr = unsafe {\n            mul_shift_all_64(\n                m2,\n                #[cfg(feature = \"small\")]\n                &compute_pow5(i as u32),\n                #[cfg(not(feature = \"small\"))]\n                {\n                    debug_assert!(i < DOUBLE_POW5_SPLIT.len() as i32);\n                    DOUBLE_POW5_SPLIT.get_unchecked(i as usize)\n                },\n                j as u32,\n                vp_uninit.as_mut_ptr(),\n                vm_uninit.as_mut_ptr(),\n                mm_shift,\n            )\n        };\n        vp = unsafe { vp_uninit.assume_init() };\n        vm = unsafe { vm_uninit.assume_init() };\n        if q <= 1 {\n            // {vr,vp,vm} is trailing zeros if {mv,mp,mm} has at least q trailing 0 bits.\n            // mv = 4 * m2, so it always has at least two trailing 0 bits.\n            vr_is_trailing_zeros = true;\n            if accept_bounds {\n                // mm = mv - 1 - mm_shift, so it has 1 trailing 0 bit iff mm_shift == 1.\n                vm_is_trailing_zeros = mm_shift == 1;\n            } else {\n                // mp = mv + 2, so it always has at least one trailing 0 bit.\n                vp -= 1;\n            }\n        } else if q < 63 {\n            // TODO(ulfjack): Use a tighter bound here.\n            // We want to know if the full product has at least q trailing zeros.\n            // We need to compute min(p2(mv), p5(mv) - e2) >= q\n            // <=> p2(mv) >= q && p5(mv) - e2 >= q\n            // <=> p2(mv) >= q (because -e2 >= q)\n            vr_is_trailing_zeros = multiple_of_power_of_2(mv, q);\n        }\n    }\n\n    // Step 4: Find the shortest decimal representation in the interval of valid representations.\n    let mut removed = 0i32;\n    let mut last_removed_digit = 0u8;\n    // On average, we remove ~2 digits.\n    let output = if vm_is_trailing_zeros || vr_is_trailing_zeros {\n        // General case, which happens rarely (~0.7%).\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            vm_is_trailing_zeros &= vm_mod10 == 0;\n            vr_is_trailing_zeros &= last_removed_digit == 0;\n            last_removed_digit = vr_mod10 as u8;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        if vm_is_trailing_zeros {\n            loop {\n                let vm_div10 = div10(vm);\n                let vm_mod10 = (vm as u32).wrapping_sub(10u32.wrapping_mul(vm_div10 as u32));\n                if vm_mod10 != 0 {\n                    break;\n                }\n                let vp_div10 = div10(vp);\n                let vr_div10 = div10(vr);\n                let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n                vr_is_trailing_zeros &= last_removed_digit == 0;\n                last_removed_digit = vr_mod10 as u8;\n                vr = vr_div10;\n                vp = vp_div10;\n                vm = vm_div10;\n                removed += 1;\n            }\n        }\n        if vr_is_trailing_zeros && last_removed_digit == 5 && vr % 2 == 0 {\n            // Round even if the exact number is .....50..0.\n            last_removed_digit = 4;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + ((vr == vm && (!accept_bounds || !vm_is_trailing_zeros)) || last_removed_digit >= 5)\n            as u64\n    } else {\n        // Specialized for the common case (~99.3%). Percentages below are relative to this.\n        let mut round_up = false;\n        let vp_div100 = div100(vp);\n        let vm_div100 = div100(vm);\n        // Optimization: remove two digits at a time (~86.2%).\n        if vp_div100 > vm_div100 {\n            let vr_div100 = div100(vr);\n            let vr_mod100 = (vr as u32).wrapping_sub(100u32.wrapping_mul(vr_div100 as u32));\n            round_up = vr_mod100 >= 50;\n            vr = vr_div100;\n            vp = vp_div100;\n            vm = vm_div100;\n            removed += 2;\n        }\n        // Loop iterations below (approximately), without optimization above:\n        // 0: 0.03%, 1: 13.8%, 2: 70.6%, 3: 14.0%, 4: 1.40%, 5: 0.14%, 6+: 0.02%\n        // Loop iterations below (approximately), with optimization above:\n        // 0: 70.6%, 1: 27.8%, 2: 1.40%, 3: 0.14%, 4+: 0.02%\n        loop {\n            let vp_div10 = div10(vp);\n            let vm_div10 = div10(vm);\n            if vp_div10 <= vm_div10 {\n                break;\n            }\n            let vr_div10 = div10(vr);\n            let vr_mod10 = (vr as u32).wrapping_sub(10u32.wrapping_mul(vr_div10 as u32));\n            round_up = vr_mod10 >= 5;\n            vr = vr_div10;\n            vp = vp_div10;\n            vm = vm_div10;\n            removed += 1;\n        }\n        // We need to take vr + 1 if vr is outside bounds or we need to round up.\n        vr + (vr == vm || round_up) as u64\n    };\n    let exp = e10 + removed;\n\n    FloatingDecimal64 {\n        exponent: exp,\n        mantissa: output,\n    }\n}\n",
  "depend_pt": ""
}