[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 1000;",
          "    let i: u32 = 0;",
          "    let j: i32 = 33;",
          "    mul_pow5_div_pow2(m, i, j);",
          "}"
        ],
        "oracles": [
          [
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    assert!(j > 32);"
          ],
          [
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert_eq!(result, expected_value_for_small_feature);"
          ],
          [
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);"
          ],
          [
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    let factor = unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1 };",
            "    let result = mul_shift_32(m, factor, j);",
            "    assert_eq!(result, expected_value_for_non_small_feature);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let m: u32 = 1000;",
            "    let i: u32 = 0;",
            "    let j: i32 = 33;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    assert!(j > 32);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 1000;",
            "    let i: u32 = 0;",
            "    let j: i32 = 33;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert_eq!(result, expected_value_for_small_feature);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 1000;",
            "    let i: u32 = 0;",
            "    let j: i32 = 33;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 1000;",
            "    let i: u32 = 0;",
            "    let j: i32 = 33;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    let factor = unsafe { d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1 };",
            "    let result = mul_shift_32(m, factor, j);",
            "    assert_eq!(result, expected_value_for_non_small_feature);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 5000;",
          "    let i: u32 = 1;",
          "    let j: i32 = 45;",
          "    mul_pow5_div_pow2(m, i, j);",
          "}"
        ],
        "oracles": [
          [
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(result <= u32::max_value());"
          ],
          [
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(j > 32);"
          ],
          [
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);"
          ],
          [
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(result == mul_shift_32(m, d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1, j));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(result <= u32::max_value());",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(j > 32);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 5000;",
            "    let i: u32 = 1;",
            "    let j: i32 = 45;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert!(result == mul_shift_32(m, d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1, j));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 1_000_000;",
          "    let i: u32 = 2;",
          "    let j: i32 = 50;",
          "    mul_pow5_div_pow2(m, i, j);",
          "}"
        ],
        "oracles": [
          [
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let factor = pow5.1;",
            "    let expected = mul_shift_32(m, factor, j);",
            "    assert_eq!(mul_pow5_div_pow2(m, i, j), expected);"
          ],
          [
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let factor = pow5.1;",
            "    let expected = mul_shift_32(m, factor, j);",
            "    debug_assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);",
            "    let factor = d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1;",
            "    let expected = mul_shift_32(m, factor, j);",
            "    assert_eq!(mul_pow5_div_pow2(m, i, j), expected);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let m: u32 = 1_000_000;",
            "    let i: u32 = 2;",
            "    let j: i32 = 50;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let factor = pow5.1;",
            "    let expected = mul_shift_32(m, factor, j);",
            "    assert_eq!(mul_pow5_div_pow2(m, i, j), expected);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 1_000_000;",
            "    let i: u32 = 2;",
            "    let j: i32 = 50;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let factor = pow5.1;",
            "    let expected = mul_shift_32(m, factor, j);",
            "    debug_assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);",
            "    let factor = d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1;",
            "    let expected = mul_shift_32(m, factor, j);",
            "    assert_eq!(mul_pow5_div_pow2(m, i, j), expected);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 4_294_967_295; // maximum u32 value",
          "    let i: u32 = d2s::DOUBLE_POW5_SPLIT.len() as u32 - 1; // boundary case",
          "    let j: i32 = 63;",
          "    mul_pow5_div_pow2(m, i, j);",
          "}"
        ],
        "oracles": [],
        "codes": [],
        "can_compile": [],
        "repaired": []
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 0; // minimum m value",
          "    let i: u32 = 3; // valid i value",
          "    let j: i32 = 34;",
          "    mul_pow5_div_pow2(m, i, j);",
          "}"
        ],
        "oracles": [
          [
            "    let m: u32 = 0;",
            "    let i: u32 = 3;",
            "    let j: i32 = 34;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert_eq!(result, expected_value_for_m0_i3_j34);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let m: u32 = 0; // minimum m value",
            "    let i: u32 = 3; // valid i value",
            "    let j: i32 = 34;",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 0;",
            "    let i: u32 = 3;",
            "    let j: i32 = 34;",
            "    let result = mul_pow5_div_pow2(m, i, j);",
            "    assert_eq!(result, expected_value_for_m0_i3_j34);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let m: u32 = 123; ",
          "    let i: u32 = 10; // a valid i value within the range",
          "    let j: i32 = 59; ",
          "    mul_pow5_div_pow2(m, i, j);",
          "}"
        ],
        "oracles": [
          [
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert_eq!(result, expected_value);"
          ],
          [
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);"
          ],
          [
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    let factor = d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1;",
            "    let bits0 = m as u64 * (factor as u32) as u64;",
            "    let bits1 = m as u64 * ((factor >> 32) as u32) as u64;",
            "    let sum = (bits0 >> 32) + bits1;",
            "    let shifted_sum = sum >> (j - 32);",
            "    assert!(shifted_sum <= u32::max_value() as u64);"
          ],
          [
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    let factor = d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1;",
            "    let bits0 = m as u64 * (factor as u32) as u64;",
            "    let bits1 = m as u64 * ((factor >> 32) as u32) as u64;",
            "    let sum = (bits0 >> 32) + bits1;",
            "    let shifted_sum = sum >> (j - 32);",
            "    assert_eq!(shifted_sum as u32, expected_value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let m: u32 = 123; ",
            "    let i: u32 = 10; // a valid i value within the range",
            "    let j: i32 = 59; ",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert_eq!(result, expected_value);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 123; ",
            "    let i: u32 = 10; // a valid i value within the range",
            "    let j: i32 = 59; ",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    assert!(i < d2s::DOUBLE_POW5_SPLIT.len() as u32);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 123; ",
            "    let i: u32 = 10; // a valid i value within the range",
            "    let j: i32 = 59; ",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    let factor = d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1;",
            "    let bits0 = m as u64 * (factor as u32) as u64;",
            "    let bits1 = m as u64 * ((factor >> 32) as u32) as u64;",
            "    let sum = (bits0 >> 32) + bits1;",
            "    let shifted_sum = sum >> (j - 32);",
            "    assert!(shifted_sum <= u32::max_value() as u64);",
            "}"
          ],
          [
            "{",
            "    let m: u32 = 123; ",
            "    let i: u32 = 10; // a valid i value within the range",
            "    let j: i32 = 59; ",
            "    mul_pow5_div_pow2(m, i, j);",
            "    let m: u32 = 123;",
            "    let i: u32 = 10;",
            "    let j: i32 = 59;",
            "    let pow5 = unsafe { d2s::compute_pow5(i) };",
            "    let result = mul_shift_32(m, pow5.1, j);",
            "    let factor = d2s::DOUBLE_POW5_SPLIT.get_unchecked(i as usize).1;",
            "    let bits0 = m as u64 * (factor as u32) as u64;",
            "    let bits1 = m as u64 * ((factor >> 32) as u32) as u64;",
            "    let sum = (bits0 >> 32) + bits1;",
            "    let shifted_sum = sum >> (j - 32);",
            "    assert_eq!(shifted_sum as u32, expected_value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]