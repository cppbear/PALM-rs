{
    "function_name": "itoa::udiv128::udivmod_1e19",
    "tests": 9,
    "tests_lines": [
        6,
        6,
        6,
        6,
        6,
        10,
        10,
        10,
        5
    ],
    "oracles": 9,
    "oracles_compiled": 9,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 9,
    "tests_compiled_rate": 100.0,
    "oracles_run": 9,
    "oracles_passed": 4,
    "oracles_passed_rate": 44.44444444444444,
    "tests_run": 9,
    "tests_passed": 4,
    "tests_passed_rate": 44.44444444444444,
    "lines": 10,
    "lines_covered": 10,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        34,
        35,
        37,
        38,
        40,
        43,
        44,
        45,
        47,
        48
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let n: u128 = 0; // n < 1 << 83, expect (0, 0)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 0);",
                "    assert_eq!(rem, 0);",
                "}"
            ],
            [
                34,
                35,
                37,
                38,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 18_000_000_000_000_000_000; // n < 1 << 83, expect (0, 18_000_000_000_000_000_000)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 0);",
                "    assert_eq!(rem, 18_000_000_000_000_000_000);",
                "}"
            ],
            [
                34,
                35,
                37,
                38,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 1_000_000_000_000_000_000; // Expect (0, 1_000_000_000_000_000_000)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 0);",
                "    assert_eq!(rem, 1_000_000_000_000_000_000);",
                "}"
            ],
            [
                34,
                35,
                37,
                38,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 20_000_000_000_000_000_000; // Expect (1, 0)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 1);",
                "    assert_eq!(rem, 0);",
                "}"
            ],
            [
                34,
                35,
                37,
                38,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = (1 << 82) + 10; // n < 1 << 83, expect (approx. 5, 10)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 5);",
                "    assert_eq!(rem, 10);",
                "}"
            ],
            [
                34,
                35,
                37,
                38,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 1 << 83; // Boundary condition where n is exactly 2^83",
                "    let expected_quot: u128 = 156927543384667019095894735580191660403 >> 62; // Expected quotient calculated from the definition",
                "    let expected_rem: u64 = (n - expected_quot * 10_000_000_000_000_000_000u128) as u64; // Expected remainder from the same context",
                "",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    ",
                "    assert_eq!(quot, expected_quot);",
                "    assert_eq!(rem, expected_rem);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let n: u128 = (1 << 83) + 1; // Just over the boundary condition",
                "    let expected_quot: u128 = (n / 10_000_000_000_000_000_000u128); // Direct division gives expected quotient",
                "    let expected_rem: u64 = (n % 10_000_000_000_000_000_000u128) as u64; // Modulus gives expected remainder",
                "",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    ",
                "    assert_eq!(quot, expected_quot);",
                "    assert_eq!(rem, expected_rem);",
                "}"
            ],
            [
                34,
                35,
                37,
                40,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 0; // Edge case where n is 0",
                "    let expected_quot: u128 = 0; // Quotient should be 0",
                "    let expected_rem: u64 = 0; // Remainder should also be 0",
                "",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    ",
                "    assert_eq!(quot, expected_quot);",
                "    assert_eq!(rem, expected_rem);",
                "}"
            ],
            [
                34,
                35,
                37,
                38,
                43,
                44,
                45,
                47,
                48
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = u128::MAX; // Panic condition, should not actually execute successfully",
                "",
                "    let _ = udivmod_1e19(n); // This should panic or trigger debug assertions",
                "}"
            ],
            [
                34,
                35,
                37,
                40,
                43,
                44,
                45,
                47,
                48
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 37,
            "start_column": 19,
            "end_line": 37,
            "end_column": 30,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let n: u128 = 0; // n < 1 << 83, expect (0, 0)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 0);",
                "    assert_eq!(rem, 0);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 18_000_000_000_000_000_000; // n < 1 << 83, expect (0, 18_000_000_000_000_000_000)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 0);",
                "    assert_eq!(rem, 18_000_000_000_000_000_000);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 1_000_000_000_000_000_000; // Expect (0, 1_000_000_000_000_000_000)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 0);",
                "    assert_eq!(rem, 1_000_000_000_000_000_000);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 20_000_000_000_000_000_000; // Expect (1, 0)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 1);",
                "    assert_eq!(rem, 0);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = (1 << 82) + 10; // n < 1 << 83, expect (approx. 5, 10)",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    assert_eq!(quot, 5);",
                "    assert_eq!(rem, 10);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 1 << 83; // Boundary condition where n is exactly 2^83",
                "    let expected_quot: u128 = 156927543384667019095894735580191660403 >> 62; // Expected quotient calculated from the definition",
                "    let expected_rem: u64 = (n - expected_quot * 10_000_000_000_000_000_000u128) as u64; // Expected remainder from the same context",
                "",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    ",
                "    assert_eq!(quot, expected_quot);",
                "    assert_eq!(rem, expected_rem);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = (1 << 83) + 1; // Just over the boundary condition",
                "    let expected_quot: u128 = (n / 10_000_000_000_000_000_000u128); // Direct division gives expected quotient",
                "    let expected_rem: u64 = (n % 10_000_000_000_000_000_000u128) as u64; // Modulus gives expected remainder",
                "",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    ",
                "    assert_eq!(quot, expected_quot);",
                "    assert_eq!(rem, expected_rem);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = 0; // Edge case where n is 0",
                "    let expected_quot: u128 = 0; // Quotient should be 0",
                "    let expected_rem: u64 = 0; // Remainder should also be 0",
                "",
                "    let (quot, rem) = udivmod_1e19(n);",
                "    ",
                "    assert_eq!(quot, expected_quot);",
                "    assert_eq!(rem, expected_rem);",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let n: u128 = u128::MAX; // Panic condition, should not actually execute successfully",
                "",
                "    let _ = udivmod_1e19(n); // This should panic or trigger debug assertions",
                "}"
            ],
            [
                {
                    "start_line": 37,
                    "start_column": 19,
                    "end_line": 37,
                    "end_column": 30,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/itoa/rusty-unit-0/src/udiv128.rs"
}