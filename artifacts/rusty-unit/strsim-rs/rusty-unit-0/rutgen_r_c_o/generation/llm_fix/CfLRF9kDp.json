{
  "name": "strsim::GrowingHashmapChar<ValueType>::allocate",
  "name_with_impl": "strsim::{impl#5}::allocate",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1307:2"
  },
  "visible": true,
  "loc": "src/lib.rs:502:5:505:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [],
      "input_infer": "0 <= self.mask <= 7, 0 <= self.map.len() <= 8\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    hashmap.allocate();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.mask, 7);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[3], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[4], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[5], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[6], GrowingHashmapMapElemChar::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[7], GrowingHashmapMapElemChar::default());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.mask, 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[3], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[4], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[5], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[6], GrowingHashmapMapElemChar::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[7], GrowingHashmapMapElemChar::default());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[0], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[0], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[0], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[1], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[1], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[1], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[2], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[2], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[2], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[3], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[3], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[3], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[4], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[4], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[4], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[5], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[5], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[5], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[6], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[6], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[6], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0369]: binary operation `==` cannot be applied to type `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[7], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     GrowingHashmapMapElemChar<i32>\n     |     GrowingHashmapMapElemChar<_>\n     |\nnote: an implementation of `PartialEq<GrowingHashmapMapElemChar<_>>` might be missing for `GrowingHashmapMapElemChar<i32>`\n    --> src/lib.rs:428:1\n     |\n428  | struct GrowingHashmapMapElemChar<ValueType> {\n     | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq<GrowingHashmapMapElemChar<_>>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(PartialEq)]`\n     |\n428  + #[derive(PartialEq)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<i32>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[7], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<i32>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<i32>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<i32>` or manually `impl Debug for GrowingHashmapMapElemChar<i32>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `GrowingHashmapMapElemChar<i32>` with `#[derive(Debug)]`\n     |\n428  + #[derive(Debug)]\n429  | struct GrowingHashmapMapElemChar<ValueType> {\n     |\n\nerror[E0277]: `GrowingHashmapMapElemChar<_>` doesn't implement `Debug`\n    --> src/lib.rs:1328:5\n     |\n1328 |     assert_eq!(hashmap.map.as_ref().unwrap()[7], GrowingHashmapMapElemChar::default());\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `GrowingHashmapMapElemChar<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `Debug` is not implemented for `GrowingHashmapMapElemChar<_>`\n     = note: add `#[derive(Debug)]` to `GrowingHashmapMapElemChar<_>` or manually `impl Debug for GrowingHashmapMapElemChar<_>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `strsim` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 4,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    hashmap.allocate();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 5,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    hashmap.allocate();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.mask, 7);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].key, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 5,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.mask, 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 5,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 5,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 5,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 5,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    hashmap.allocate();",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 5, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 8,",
                "        fill: 8,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    hashmap.allocate();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: Some(vec![]),",
                "    };",
                "    hashmap.allocate();",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            }
          ]
        }
      ]
    }
  ]
}