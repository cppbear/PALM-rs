{
  "name": "strsim::GrowingHashmapChar<ValueType>::lookup",
  "name_with_impl": "strsim::{impl#5}::lookup",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1307:2"
  },
  "visible": true,
  "loc": "src/lib.rs:509:5:532:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\") is \n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is true\n",
        "// expected return value/type: i\n"
      ],
      "input_infer": "0 to mask, inclusive\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 31,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                "    };",
                "    let result = hashmap.lookup(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]) };",
                  "    let result = hashmap.lookup(0);",
                  "    assert_eq!(result, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]) };",
                  "    let result = hashmap.lookup(0);",
                  "    assert_eq!(result, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 31,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 0, value: 0 },",
                "            GrowingHashmapMapElemChar { key: 1, value: 1 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 2 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(3);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert_eq!(result, 3);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].value == Default::default());"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].key == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 2 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(3);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert_eq!(result, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 2 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(3);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 2 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(3);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 0, fill: 0, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].key == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 31,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 0, value: 0 },",
                "            GrowingHashmapMapElemChar { key: 1, value: 1 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 2 },",
                "            GrowingHashmapMapElemChar { key: 3, value: 0 },",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(3);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar { key: 3, value: 0 }, GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(3);",
                  "    assert_eq!(result, 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 2 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 0 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(3);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }, GrowingHashmapMapElemChar { key: 1, value: 1 }, GrowingHashmapMapElemChar { key: 2, value: 2 }, GrowingHashmapMapElemChar { key: 3, value: 0 }, GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(3);",
                  "    assert_eq!(result, 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 2,",
                "        fill: 3,",
                "        mask: 31,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 0, value: 42 },",
                "            GrowingHashmapMapElemChar { key: 1, value: 43 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 44 },",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 3, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 42 }, GrowingHashmapMapElemChar { key: 1, value: 43 }, GrowingHashmapMapElemChar { key: 2, value: 44 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert_eq!(result, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 42 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 43 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 44 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 3, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 42 }, GrowingHashmapMapElemChar { key: 1, value: 43 }, GrowingHashmapMapElemChar { key: 2, value: 44 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert_eq!(result, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 31,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 0, value: 1 },",
                "            GrowingHashmapMapElemChar { key: 1, value: 0 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 0 },",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.lookup(2), 2);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2].value, 0);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2].key, 2);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.used, 1);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.fill, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 0 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.lookup(2), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 0 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2].value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 0 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2].key, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 0 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.used, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 31,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 1 },",
                  "            GrowingHashmapMapElemChar { key: 1, value: 0 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 0 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 31, map: Some(vec![ GrowingHashmapMapElemChar { key: 0, value: 1 }, GrowingHashmapMapElemChar { key: 1, value: 0 }, GrowingHashmapMapElemChar { key: 2, value: 0 }, GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(hashmap.fill, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\") is \n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].key == key is true\n",
        "// expected return value/type: i\n"
      ],
      "input_infer": "0 <= key <= 2^32 - 1, self.mask > 0, map != None, map[i].value != Default::default(), map[i].key == key\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                "    };",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; ",
                "    let _ = hashmap.lookup(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]) };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;",
                  "    let index = hashmap.lookup(0);",
                  "    assert_eq!(index, hashmap.lookup(0));"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]) };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;",
                  "    let index = hashmap.lookup(0);",
                  "    assert!(hashmap.map.as_ref().unwrap()[index].value != Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]) };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;",
                  "    let index = hashmap.lookup(0);",
                  "    assert!(hashmap.map.as_ref().unwrap()[index].key == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; ",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]) };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;",
                  "    let index = hashmap.lookup(0);",
                  "    assert_eq!(index, hashmap.lookup(0));",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; ",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]) };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;",
                  "    let index = hashmap.lookup(0);",
                  "    assert!(hashmap.map.as_ref().unwrap()[index].value != Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; ",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]) };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;",
                  "    let index = hashmap.lookup(0);",
                  "    assert!(hashmap.map.as_ref().unwrap()[index].key == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].value = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(0)].key = 0;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 2,",
                "        fill: 2,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                "    };",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; ",
                "    let _ = hashmap.lookup(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;",
                  "    let result = hashmap.lookup(1);",
                  "    assert_eq!(result, hashmap.lookup(1));"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;",
                  "    let result = hashmap.lookup(1);",
                  "    assert!(hashmap.map.as_ref().unwrap()[hashmap.lookup(1)].key == 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;",
                  "    let result = hashmap.lookup(1);",
                  "    assert!(hashmap.map.as_ref().unwrap()[hashmap.lookup(1)].value == 10);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 2,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; ",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;",
                  "    let result = hashmap.lookup(1);",
                  "    assert_eq!(result, hashmap.lookup(1));",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 2,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; ",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;",
                  "    let result = hashmap.lookup(1);",
                  "    assert!(hashmap.map.as_ref().unwrap()[hashmap.lookup(1)].key == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 2,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; ",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;",
                  "    let result = hashmap.lookup(1);",
                  "    assert!(hashmap.map.as_ref().unwrap()[hashmap.lookup(1)].value == 10);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `result`\n    --> src/lib.rs:1328:9\n     |\n1328 |     let result = hashmap.lookup(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 3 warnings emitted\n"
                },
                {
                  "Err": "    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `result`\n    --> src/lib.rs:1328:9\n     |\n1328 |     let result = hashmap.lookup(1);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_result`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].value = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(1)].key = 1;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 3,",
                "        fill: 3,",
                "        mask: 31,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                "    };",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10; ",
                "    let _ = hashmap.lookup(10);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10;",
                  "    let result = hashmap.lookup(10);",
                  "    assert_eq!(result, hashmap.lookup(10));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10; ",
                  "    let _ = hashmap.lookup(10);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10;",
                  "    let result = hashmap.lookup(10);",
                  "    assert_eq!(result, hashmap.lookup(10));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1326:35\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1326:34\n     |\n1326 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].value = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1327:35\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1327:34\n     |\n1327 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(10)].key = 10;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 4 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 3,",
                "        fill: 3,",
                "        mask: 31,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                "    };",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                "    let _ = hashmap.lookup(5);",
                "    let _ = hashmap.lookup(20);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.lookup(5), hashmap.lookup(5));"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.lookup(20), hashmap.lookup(20));"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(5)].value, 15);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(5)].key, 5);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(20)].value, 25);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(20)].key, 20);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                  "    let _ = hashmap.lookup(5);",
                  "    let _ = hashmap.lookup(20);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.lookup(5), hashmap.lookup(5));",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                  "    let _ = hashmap.lookup(5);",
                  "    let _ = hashmap.lookup(20);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.lookup(20), hashmap.lookup(20));",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                  "    let _ = hashmap.lookup(5);",
                  "    let _ = hashmap.lookup(20);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(5)].value, 15);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                  "    let _ = hashmap.lookup(5);",
                  "    let _ = hashmap.lookup(20);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(5)].key, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                  "    let _ = hashmap.lookup(5);",
                  "    let _ = hashmap.lookup(20);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(20)].value, 25);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 31,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; ",
                  "    let _ = hashmap.lookup(5);",
                  "    let _ = hashmap.lookup(20);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 3, mask: 31, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 32]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(20)].key, 20);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20; \n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].value = 15;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(5)].key = 5;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].value = 25;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |     -----------                  -^^^^^^^------------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                   ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(20)].key = 20;\n     |                                  ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 4,",
                "        fill: 4,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                "    };",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                "    let _ = hashmap.lookup(2);",
                "    let _ = hashmap.lookup(7);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.lookup(2), hashmap.lookup(2));"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.lookup(7), hashmap.lookup(7));"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(2)].value, 30);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(2)].key, 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(7)].value, 35);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(7)].key, 7);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                  "    let _ = hashmap.lookup(2);",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.lookup(2), hashmap.lookup(2));",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                  "    let _ = hashmap.lookup(2);",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.lookup(7), hashmap.lookup(7));",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                  "    let _ = hashmap.lookup(2);",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(2)].value, 30);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                  "    let _ = hashmap.lookup(2);",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(2)].key, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                  "    let _ = hashmap.lookup(2);",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(7)].value, 35);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]),",
                  "    };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; ",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; ",
                  "    let _ = hashmap.lookup(2);",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 4, fill: 4, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 0 }; 16]), };",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;",
                  "    hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(7)].key, 7);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1322:35\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1322:34\n     |\n1322 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1323:35\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1323:34\n     |\n1323 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1324:35\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1324:34\n     |\n1324 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1325:35\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1325:34\n     |\n1325 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7; \n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1329:35\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1329:34\n     |\n1329 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].value = 30;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1330:35\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1330:34\n     |\n1330 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(2)].key = 2;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1331:35\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1331:34\n     |\n1331 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].value = 35;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |     -----------                  -^^^^^^^-----------\n     |     |                            ||\n     |     |                            |immutable borrow occurs here\n     |     |                            mutable borrow later used here\n     |     mutable borrow occurs here\n     |\nhelp: try adding a local storing this...\n    --> src/lib.rs:1332:35\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                   ^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n    --> src/lib.rs:1332:34\n     |\n1332 |     hashmap.map.as_mut().unwrap()[hashmap.lookup(7)].key = 7;\n     |                                  ^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 8 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\") is \n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].key == key is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is true\n",
        "// expected return value/type: i\n"
      ],
      "input_infer": "0-1000, 2000-3000, 4000-5000\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<i32> {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 1000, value: 10 }, ",
                "                       GrowingHashmapMapElemChar::default(); 15]),",
                "    };",
                "    let index = hashmap.lookup(1000);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 1000, value: 10 }, GrowingHashmapMapElemChar::default(); 15]) };",
                  "    assert_eq!(index, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 1000, value: 10 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(1000);",
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 1000, value: 10 }, GrowingHashmapMapElemChar::default(); 15]) };",
                  "    assert_eq!(index, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nerror: no rules expected the token `;`\n    --> src/lib.rs:1324:182\n     |\n1324 | ...e: 10 }, GrowingHashmapMapElemChar::default(); 15]) };\n     |                                                 ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<i32> {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                "                       GrowingHashmapMapElemChar::default(); 15]),",
                "    };",
                "    let index = hashmap.lookup(3000);",
                "}"
              ],
              "oracles": [
                [
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert_eq!(index, expected_index);"
                ],
                [
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[index].value == Default::default());"
                ],
                [
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[index].key != 3000);"
                ],
                [
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[map.len() - 1].value == Default::default());"
                ],
                [
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[0].key == 2000);"
                ],
                [
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[0].value == 20);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(3000);",
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert_eq!(index, expected_index);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(3000);",
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[index].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(3000);",
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[index].key != 3000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(3000);",
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[map.len() - 1].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(3000);",
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[0].key == 2000);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 2000, value: 20 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(3000);",
                  "    let map = hashmap.map.as_ref().unwrap();",
                  "    let expected_index = 1;",
                  "    assert!(map[0].value == 20);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1321:60\n     |\n1321 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<i32> {",
                "        used: 2,",
                "        fill: 2,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar { key: 4000, value: 30 }, ",
                "                       GrowingHashmapMapElemChar { key: 1000, value: 10 }, ",
                "                       GrowingHashmapMapElemChar::default(); 15]),",
                "    };",
                "    let index = hashmap.lookup(1000);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 4000, value: 30 }, GrowingHashmapMapElemChar { key: 1000, value: 10 }, GrowingHashmapMapElemChar::default(); 15]) };",
                  "    let index = hashmap.lookup(1000);",
                  "    assert_eq!(index, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 2,",
                  "        fill: 2,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar { key: 4000, value: 30 }, ",
                  "                       GrowingHashmapMapElemChar { key: 1000, value: 10 }, ",
                  "                       GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(1000);",
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 2, fill: 2, mask: 15, map: Some(vec![GrowingHashmapMapElemChar { key: 4000, value: 30 }, GrowingHashmapMapElemChar { key: 1000, value: 10 }, GrowingHashmapMapElemChar::default(); 15]) };",
                  "    let index = hashmap.lookup(1000);",
                  "    assert_eq!(index, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror: no rules expected the token `;`\n    --> src/lib.rs:1322:60\n     |\n1322 |                        GrowingHashmapMapElemChar::default(); 15]),\n     |                                                            ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nerror: no rules expected the token `;`\n    --> src/lib.rs:1325:234\n     |\n1325 | ...e: 10 }, GrowingHashmapMapElemChar::default(); 15]) };\n     |                                                 ^ no rules expected this token in macro call\n     |\n     = note: while trying to match sequence start\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 2 previous errors; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<i32> {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 15,",
                "        map: Some(vec![GrowingHashmapMapElemChar::default(); 15]),",
                "    };",
                "    let index = hashmap.lookup(5000);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar::default(); 15]), };",
                  "    hashmap.map.as_ref().expect(\"callers have to ensure map is allocated\");",
                  "    let index = hashmap.lookup(5000);",
                  "    assert!(index >= 0 && index <= hashmap.mask as usize);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar::default(); 15]), };",
                  "    hashmap.map.as_ref().expect(\"callers have to ensure map is allocated\");",
                  "    let index = hashmap.lookup(5000);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[index].value, Default::default());"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar::default(); 15]), };",
                  "    hashmap.map.as_ref().expect(\"callers have to ensure map is allocated\");",
                  "    let index = hashmap.lookup(5000);",
                  "    assert_ne!(hashmap.map.as_ref().unwrap()[index].key, 5000);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(5000);",
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar::default(); 15]), };",
                  "    hashmap.map.as_ref().expect(\"callers have to ensure map is allocated\");",
                  "    let index = hashmap.lookup(5000);",
                  "    assert!(index >= 0 && index <= hashmap.mask as usize);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(5000);",
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar::default(); 15]), };",
                  "    hashmap.map.as_ref().expect(\"callers have to ensure map is allocated\");",
                  "    let index = hashmap.lookup(5000);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[index].value, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<i32> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 15,",
                  "        map: Some(vec![GrowingHashmapMapElemChar::default(); 15]),",
                  "    };",
                  "    let index = hashmap.lookup(5000);",
                  "    let mut hashmap = GrowingHashmapChar::<i32> { used: 1, fill: 1, mask: 15, map: Some(vec![GrowingHashmapMapElemChar::default(); 15]), };",
                  "    hashmap.map.as_ref().expect(\"callers have to ensure map is allocated\");",
                  "    let index = hashmap.lookup(5000);",
                  "    assert_ne!(hashmap.map.as_ref().unwrap()[index].key, 5000);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let index = hashmap.lookup(1000);",
                "}"
              ],
              "oracles": [
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.map.is_none(), true);"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(index, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let index = hashmap.lookup(1000);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.map.is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let index = hashmap.lookup(1000);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(index, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\") is \n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].key == key is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].key == key is true\n",
        "// expected return value/type: i\n"
      ],
      "input_infer": "0 <= key <= 4294967295, 0 <= i <= mask, mask > 0\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0b111, // Example mask value",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                "            GrowingHashmapMapElemChar::default(), // Default value",
                "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                "            GrowingHashmapMapElemChar::default(), // Default value",
                "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                "            GrowingHashmapMapElemChar::default(), // Default value",
                "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                "        ]),",
                "    };",
                "    let _ = hashmap.lookup(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(map_size == 8);"
                ],
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(1) == 0);"
                ],
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(2) == 1);"
                ],
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(3) == 3);"
                ],
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(4) == 5);"
                ],
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(5) == 7);"
                ],
                [
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(0) == 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(map_size == 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(1) == 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(2) == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(3) == 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(4) == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(5) == 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0b111, // Example mask value",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(), // Default value",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let map_size = hashmap.map.as_ref().unwrap().len();",
                  "    assert!(hashmap.lookup(0) == 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 3,",
                "        fill: 3,",
                "        mask: 0b111,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                "        ]),",
                "    };",
                "    let _ = hashmap.lookup(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let hashmap = GrowingHashmapChar::<usize> {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 0b111,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "    GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "    ]),",
                  "    };",
                  "    let index = hashmap.lookup(2);",
                  "    assert_eq!(index, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(2);",
                  "    let hashmap = GrowingHashmapChar::<usize> {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 0b111,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "    GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "    ]),",
                  "    };",
                  "    let index = hashmap.lookup(2);",
                  "    assert_eq!(index, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 4,",
                "        fill: 4,",
                "        mask: 0b111,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                "        ]),",
                "    };",
                "    let _ = hashmap.lookup(7);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 4, fill: 4, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]), };",
                  "    let result = hashmap.lookup(7);",
                  "    assert_eq!(result, 3);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 4, fill: 4, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]), };",
                  "    let result = hashmap.lookup(7);",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].value == Default::default());"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 4, fill: 4, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]), };",
                  "    let result = hashmap.lookup(7);",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].key == 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 4, fill: 4, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]), };",
                  "    let result = hashmap.lookup(7);",
                  "    assert_eq!(result, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 4, fill: 4, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]), };",
                  "    let result = hashmap.lookup(7);",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 4,",
                  "        fill: 4,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(7);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 4, fill: 4, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]), };",
                  "    let result = hashmap.lookup(7);",
                  "    assert!(hashmap.map.as_ref().unwrap()[3].key == 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 3,",
                "        fill: 3,",
                "        mask: 0b111,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                "            // Collision with existing value",
                "            GrowingHashmapMapElemChar { key: 1, value: 25 },",
                "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                "        ]),",
                "    };",
                "    let _ = hashmap.lookup(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    assert_eq!(index, 3);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(2);",
                  "    assert_eq!(index, 1);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(3);",
                  "    assert_eq!(index, 2);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(3);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(4);",
                  "    assert_eq!(index, 4);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            // Collision with existing value",
                  "            GrowingHashmapMapElemChar { key: 1, value: 25 },",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    assert_eq!(index, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            // Collision with existing value",
                  "            GrowingHashmapMapElemChar { key: 1, value: 25 },",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(2);",
                  "    assert_eq!(index, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            // Collision with existing value",
                  "            GrowingHashmapMapElemChar { key: 1, value: 25 },",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(3);",
                  "    assert_eq!(index, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 30 },",
                  "            // Collision with existing value",
                  "            GrowingHashmapMapElemChar { key: 1, value: 25 },",
                  "            GrowingHashmapMapElemChar { key: 4, value: 40 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 50 },",
                  "            GrowingHashmapMapElemChar { key: 6, value: 60 },",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(3);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 10 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar { key: 3, value: 30 }, GrowingHashmapMapElemChar { key: 1, value: 25 }, GrowingHashmapMapElemChar { key: 4, value: 40 }, GrowingHashmapMapElemChar { key: 5, value: 50 }, GrowingHashmapMapElemChar { key: 6, value: 60 }, ]) };",
                  "    let index = hashmap.lookup(4);",
                  "    assert_eq!(index, 4);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 1,",
                "        fill: 1,",
                "        mask: 0b111,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 0, value: 100 }, // Key is zero",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let _ = hashmap.lookup(0);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    assert_eq!(result, 0);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap2 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap2.lookup(1), 0);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap2 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let mut hashmap3 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 2, value: 300 }, GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result3 = hashmap3.lookup(2);",
                  "    assert_eq!(result3, 2);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap2 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let mut hashmap3 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 2, value: 300 }, GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result3 = hashmap3.lookup(2);",
                  "    let mut hashmap4 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 10, value: 400 }, GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result4 = hashmap4.lookup(10);",
                  "    assert_eq!(result4, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 100 }, // Key is zero",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    assert_eq!(result, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 100 }, // Key is zero",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap2 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap2.lookup(1), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 100 }, // Key is zero",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap2 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let mut hashmap3 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 2, value: 300 }, GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result3 = hashmap3.lookup(2);",
                  "    assert_eq!(result3, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 1,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 0, value: 100 }, // Key is zero",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(0);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(0);",
                  "    let mut hashmap2 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let mut hashmap3 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 2, value: 300 }, GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result3 = hashmap3.lookup(2);",
                  "    let mut hashmap4 = GrowingHashmapChar::<usize> { used: 1, fill: 1, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 10, value: 400 }, GrowingHashmapMapElemChar { key: 1, value: 200 }, GrowingHashmapMapElemChar { key: 0, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result4 = hashmap4.lookup(10);",
                  "    assert_eq!(result4, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 3,",
                "        fill: 3,",
                "        mask: 0b111,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 4294967295, value: 100 }, // Maximum key value",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let _ = hashmap.lookup(4294967295);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 4294967295, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(4294967295);",
                  "    assert_eq!(result, expected_index);  // Replace expected_index with the correct value based on the logic of the lookup function."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 0b111,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4294967295, value: 100 }, // Maximum key value",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _ = hashmap.lookup(4294967295);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 3, fill: 3, mask: 0b111, map: Some(vec![GrowingHashmapMapElemChar { key: 4294967295, value: 100 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let result = hashmap.lookup(4294967295);",
                  "    assert_eq!(result, expected_index);  // Replace expected_index with the correct value based on the logic of the lookup function.",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nerror[E0425]: cannot find value `expected_index` in this scope\n    --> src/lib.rs:1333:24\n     |\n1333 |     assert_eq!(result, expected_index);  // Replace expected_index with the correct value based on the logic of the lookup function.\n     |                        ^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"callers have to ensure map is allocated\") is \n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].key == key is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].key == key is false\n",
        "// constraint: map[i] is \n",
        "// constraint: map[i].value == Default::default() is true\n",
        "// expected return value/type: i\n"
      ],
      "input_infer": "1 <= key <= 2^32 - 1, 0 <= self.mask <= (2^32 - 1), 0 <= map.len() <= self.mask + 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 1,",
                "        fill: 2,",
                "        mask: 3,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 2, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    let result = hashmap.lookup(1);",
                  "    assert_eq!(result, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 2,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(1);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 2, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]), };",
                  "    let result = hashmap.lookup(1);",
                  "    assert_eq!(result, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 1,",
                "        fill: 2,",
                "        mask: 3,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                "            GrowingHashmapMapElemChar { key: 3, value: 15 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 2, mask: 3, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 3, value: 15 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(result, 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 1,",
                  "        fill: 2,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 3, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 1, fill: 2, mask: 3, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 3, value: 15 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(result, 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 2,",
                "        fill: 3,",
                "        mask: 4,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar { key: 3, value: 20 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 3, mask: 4, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 3, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(result, 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 3,",
                  "        mask: 4,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar { key: 3, value: 20 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(2);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 3, mask: 4, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar { key: 3, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), ]) };",
                  "    assert_eq!(result, 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap = GrowingHashmapChar::<usize> {",
                "        used: 2,",
                "        fill: 4,",
                "        mask: 3,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let result = hashmap.lookup(5);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert_eq!(result, 2);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[result].key == 5);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[result].value == 15);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.used == 2);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.fill == 4);"
                ],
                [
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.mask == 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(5);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert_eq!(result, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(5);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[result].key == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(5);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[result].value == 15);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(5);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.used == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(5);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.fill == 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 3,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 5 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 10 },",
                  "            GrowingHashmapMapElemChar { key: 5, value: 15 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let result = hashmap.lookup(5);",
                  "    let mut hashmap = GrowingHashmapChar::<usize> { used: 2, fill: 4, mask: 3, map: Some(vec![ GrowingHashmapMapElemChar { key: 1, value: 5 }, GrowingHashmapMapElemChar { key: 2, value: 10 }, GrowingHashmapMapElemChar { key: 5, value: 15 }, GrowingHashmapMapElemChar::default(), ]), };",
                  "    assert!(hashmap.mask == 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hashmap = GrowingHashmapChar::<usize> {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let result = std::panic::catch_unwind(|| {",
                "        hashmap.lookup(1);",
                "    });",
                "    assert!(result.is_err());",
                "}"
              ],
              "oracles": [
                [
                  "    let hashmap = GrowingHashmapChar::<usize> {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    hashmap.lookup(1);",
                  "    });",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hashmap = GrowingHashmapChar::<usize> {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let result = std::panic::catch_unwind(|| {",
                  "        hashmap.lookup(1);",
                  "    });",
                  "    assert!(result.is_err());",
                  "    let hashmap = GrowingHashmapChar::<usize> {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    let result = std::panic::catch_unwind(|| {",
                  "    hashmap.lookup(1);",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}