{
  "name": "strsim::GrowingHashmapChar<ValueType>::get_mut",
  "name_with_impl": "strsim::{impl#5}::get_mut",
  "mod_info": {
    "name": "",
    "loc": "src/lib.rs:1:1:1307:2"
  },
  "visible": true,
  "loc": "src/lib.rs:471:5:500:6",
  "fn_tests": [
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.map.is_none() is true\n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\") is \n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i] is \n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i]\n            .value\n            == Default::default() is false\n",
        "// constraint: self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\") is \n",
        "// constraint: self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\")[i] is \n",
        "// expected return value/type: &mut elem.value\n"
      ],
      "input_infer": "1 <= key <= 4\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let _value = hashmap.get_mut(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.mask, 7);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been created above\")[i].value, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    assert_eq!(hashmap.used, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    assert_eq!(hashmap.fill, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(elem.key, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(elem.value, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(*hashmap.get_mut(1), 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(hashmap.used, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(hashmap.fill, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been created above\")[i].value, 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    assert_eq!(hashmap.mask, 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been created above\")[i].value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    assert_eq!(hashmap.used, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    assert_eq!(hashmap.fill, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(elem.key, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(elem.value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(*hashmap.get_mut(1), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(hashmap.used, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(hashmap.fill, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let i = hashmap.lookup(1);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been created above\")[i].value, 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1326:16\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1326 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1326:16\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1326 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1326:9\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1326:16\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1326 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 3 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1326:9\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1326:16\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1326 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 3 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1326:9\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1326:16\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1326 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 3 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1326:9\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1326:16\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1326 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1326 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let _value1 = hashmap.get_mut(2);",
                "    *hashmap.get_mut(2) = 5;",
                "    let _value2 = hashmap.get_mut(2);",
                "}"
              ],
              "oracles": [
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_ref().unwrap().len() > 0);"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_ref().unwrap()[2 as usize].value == Default::default());"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.used == 1);"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.fill == 1);"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_ref().unwrap()[2 as usize].key == 2);"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_mut().unwrap()[2 as usize].value == 5);"
                ],
                [
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(*hashmap.get_mut(2) == 5);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_ref().unwrap().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_ref().unwrap()[2 as usize].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.used == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.fill == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_ref().unwrap()[2 as usize].key == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(hashmap.map.as_mut().unwrap()[2 as usize].value == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(2);",
                  "    *hashmap.get_mut(2) = 5;",
                  "    let _value2 = hashmap.get_mut(2);",
                  "    let hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 0,",
                  "    fill: 0,",
                  "    mask: 0,",
                  "    map: None,",
                  "    };",
                  "    assert!(*hashmap.get_mut(2) == 5);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0596]: cannot borrow `hashmap.map` as mutable, as `hashmap` is not declared as mutable\n    --> src/lib.rs:1331:13\n     |\n1331 |     assert!(hashmap.map.as_mut().unwrap()[2 as usize].value == 5);\n     |             ^^^^^^^^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0596]: cannot borrow `hashmap` as mutable, as it is not declared as mutable\n    --> src/lib.rs:1331:14\n     |\n1331 |     assert!(*hashmap.get_mut(2) == 5);\n     |              ^^^^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1325 |     let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {\n     |         +++\n\nFor more information about this error, try `rustc --explain E0596`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let _value1 = hashmap.get_mut(3);",
                "    let _value2 = hashmap.get_mut(4);",
                "    *hashmap.get_mut(3) = 10;",
                "    *hashmap.get_mut(4) = 15;",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been allocated\").len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.used, 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.fill, 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    assert_eq!(*value1, Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    let value2 = hashmap.get_mut(4);",
                  "    assert_eq!(*value2, Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    let value2 = hashmap.get_mut(4);",
                  "    let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];",
                  "    assert_eq!(elem3.value, 10);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    let value2 = hashmap.get_mut(4);",
                  "    let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];",
                  "    let elem4 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(4)];",
                  "    assert_eq!(elem4.value, 15);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been allocated\").len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.used, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    assert_eq!(hashmap.fill, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    assert_eq!(*value1, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    let value2 = hashmap.get_mut(4);",
                  "    assert_eq!(*value2, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    let value2 = hashmap.get_mut(4);",
                  "    let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];",
                  "    assert_eq!(elem3.value, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let _value1 = hashmap.get_mut(3);",
                  "    let _value2 = hashmap.get_mut(4);",
                  "    *hashmap.get_mut(3) = 10;",
                  "    *hashmap.get_mut(4) = 15;",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    let value1 = hashmap.get_mut(3);",
                  "    let value2 = hashmap.get_mut(4);",
                  "    let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];",
                  "    let elem4 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(4)];",
                  "    assert_eq!(elem4.value, 15);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value1`\n    --> src/lib.rs:1327:9\n     |\n1327 |     let value1 = hashmap.get_mut(3);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_value1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `value2`\n    --> src/lib.rs:1328:9\n     |\n1328 |     let value2 = hashmap.get_mut(4);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_value2`\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1329:17\n     |\n1329 |     let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1329 |     let elem3 = &hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];\n     |                 +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1329 |     let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)].clone();\n     |                                                                                                     ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 4 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 4 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value1`\n    --> src/lib.rs:1327:9\n     |\n1327 |     let value1 = hashmap.get_mut(3);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_value1`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `value2`\n    --> src/lib.rs:1328:9\n     |\n1328 |     let value2 = hashmap.get_mut(4);\n     |         ^^^^^^ help: if this is intentional, prefix it with an underscore: `_value2`\n\nwarning: unused variable: `elem3`\n    --> src/lib.rs:1329:9\n     |\n1329 |     let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_elem3`\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1329:17\n     |\n1329 |     let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1329 |     let elem3 = &hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)];\n     |                 +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1329 |     let elem3 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(3)].clone();\n     |                                                                                                     ++++++++\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1330:17\n     |\n1330 |     let elem4 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(4)];\n     |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1330 |     let elem4 = &hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(4)];\n     |                 +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1330 |     let elem4 = hashmap.map.as_ref().expect(\"map should have been created above\")[hashmap.lookup(4)].clone();\n     |                                                                                                     ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 5 warnings\nerror: could not compile `strsim` (lib test) due to 2 previous errors; 5 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 3,",
                "        fill: 3,",
                "        mask: 7,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let _value = hashmap.get_mut(1);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.used, 3);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.fill, 3);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.mask, 7);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].key, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 100);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1].key, 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1].value, 200);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    let value = hashmap.get_mut(1);",
                  "    assert_eq!(*value, 100);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    let value = hashmap.get_mut(1);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 100);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.used, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.fill, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.mask, 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].key, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1].key, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1].value, 200);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    let value = hashmap.get_mut(1);",
                  "    assert_eq!(*value, 100);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 3,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "            GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let _value = hashmap.get_mut(1);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "    used: 3,",
                  "    fill: 3,",
                  "    mask: 7,",
                  "    map: Some(vec![",
                  "    GrowingHashmapMapElemChar { key: 1, value: 100 },",
                  "    GrowingHashmapMapElemChar { key: 2, value: 200 },",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    GrowingHashmapMapElemChar::default(),",
                  "    ]),",
                  "    };",
                  "    let value = hashmap.get_mut(1);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 100);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: self.map.is_none() is false\n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\") is \n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i] is \n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i]\n            .value\n            == Default::default() is true\n",
        "// constraint: self.fill * 3 >= (self.mask + 1) * 2 is true, with bound self.fill * 3 == (self.mask + 1) * 2\n",
        "// constraint: self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\") is \n",
        "// constraint: self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\")[i] is \n",
        "// expected return value/type: &mut elem.value\n"
      ],
      "input_infer": "self.fill in [4, 5]; self.mask in [7, 8]; key in [0, 7]; self.used in [2, 3]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 2,",
                "        fill: 4,",
                "        mask: 7,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar::default(), ",
                "            GrowingHashmapMapElemChar::default(), ",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let key = 3;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    assert!(hashmap.map.as_ref().expect(\"map should have been created above\")[i].value == Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    hashmap.fill += 1;",
                  "    assert!(hashmap.fill * 3 >= (hashmap.mask + 1) * 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    hashmap.fill += 1;",
                  "    hashmap.grow((hashmap.used + 1) * 2);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(elem.key, 3);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    hashmap.fill += 1;",
                  "    hashmap.grow((hashmap.used + 1) * 2);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    let return_value = hashmap.get_mut(3);",
                  "    assert!(return_value == &mut elem.value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 3;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 3;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    assert!(hashmap.map.as_ref().expect(\"map should have been created above\")[i].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 3;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    hashmap.fill += 1;",
                  "    assert!(hashmap.fill * 3 >= (hashmap.mask + 1) * 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 3;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    hashmap.fill += 1;",
                  "    hashmap.grow((hashmap.used + 1) * 2);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    assert_eq!(elem.key, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 3;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let i = hashmap.lookup(3);",
                  "    hashmap.fill += 1;",
                  "    hashmap.grow((hashmap.used + 1) * 2);",
                  "    let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];",
                  "    let return_value = hashmap.get_mut(3);",
                  "    assert!(return_value == &mut elem.value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1337:16\n     |\n1337 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1337 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1337 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 3 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1337:16\n     |\n1337 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1337 |     let elem = &hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1337 |     let elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i].clone();\n     |                                                                                    ++++++++\n\nerror[E0596]: cannot borrow `elem.value` as mutable, as `elem` is not declared as mutable\n    --> src/lib.rs:1339:29\n     |\n1339 |     assert!(return_value == &mut elem.value);\n     |                             ^^^^^^^^^^^^^^^ cannot borrow as mutable\n     |\nhelp: consider changing this to be mutable\n     |\n1337 |     let mut elem = hashmap.map.as_mut().expect(\"map should have been created above\")[i];\n     |         +++\n\nSome errors have detailed explanations: E0507, E0596.\nFor more information about an error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 3,",
                "        fill: 5,",
                "        mask: 8,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar::default(), ",
                "            GrowingHashmapMapElemChar::default(), ",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let key = 7;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 6);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 4);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[7].key, key);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().unwrap()[7].value != Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[7].value, *value);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.fill * 3 >= (hashmap.mask + 1) * 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 6);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[7].key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().unwrap()[7].value != Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[7].value, *value);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    let key = 7;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.fill * 3 >= (hashmap.mask + 1) * 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0502]: cannot borrow `hashmap.map` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1336:16\n     |\n1335 |     let value = hashmap.get_mut(key);\n     |                 ------- mutable borrow occurs here\n1336 |     assert_eq!(hashmap.map.as_ref().unwrap()[7].value, *value);\n     |     -----------^^^^^^^^^^^------------------------------------\n     |     |          |\n     |     |          immutable borrow occurs here\n     |     mutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 3 warnings emitted\n"
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 2,",
                "        fill: 4,",
                "        mask: 7,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                "            GrowingHashmapMapElemChar::default(), ",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let key = 0;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap.fill, 4);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap.used, 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap.mask, 7);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    assert_eq!(i, 5);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    assert_eq!(elem.key, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    assert_eq!(elem.value, Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(*value, Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 5);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 3);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().unwrap()[i].value != Default::default());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap.fill, 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap.used, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    assert_eq!(hashmap.mask, 7);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    assert_eq!(i, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    assert_eq!(elem.key, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    assert_eq!(elem.value, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(*value, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 2,",
                  "        fill: 4,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 4, value: 10 }, ",
                  "            GrowingHashmapMapElemChar::default(), ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 0;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar { key: 4, value: 10 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]),};",
                  "    let i = hashmap.lookup(key);",
                  "    let elem = hashmap.map.as_ref().unwrap()[i];",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().unwrap()[i].value != Default::default());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> src/lib.rs:1333:9\n     |\n1333 |     let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar {...\n     |         ----^^^^^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1335:16\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1335 |     let elem = &hashmap.map.as_ref().unwrap()[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i].clone();\n     |                                                ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 4 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 4 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n    --> src/lib.rs:1333:9\n     |\n1333 |     let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 2, fill: 4, mask: 7, map: Some(vec![GrowingHashmapMapElemChar {...\n     |         ----^^^^^^^\n     |         |\n     |         help: remove this `mut`\n     |\n     = note: `#[warn(unused_mut)]` on by default\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1335:16\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1335 |     let elem = &hashmap.map.as_ref().unwrap()[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i].clone();\n     |                                                ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 4 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 4 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1335:9\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1335:16\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1335 |     let elem = &hashmap.map.as_ref().unwrap()[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i].clone();\n     |                                                ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 4 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 4 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1335:9\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1336:9\n     |\n1336 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1335:16\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1335 |     let elem = &hashmap.map.as_ref().unwrap()[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i].clone();\n     |                                                ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 5 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 5 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1335:9\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1336:9\n     |\n1336 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1335:16\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1335 |     let elem = &hashmap.map.as_ref().unwrap()[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i].clone();\n     |                                                ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 5 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 5 warnings emitted\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1332:9\n     |\n1332 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `elem`\n    --> src/lib.rs:1335:9\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |         ^^^^ help: if this is intentional, prefix it with an underscore: `_elem`\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1336:9\n     |\n1336 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n\nerror[E0507]: cannot move out of index of `Vec<GrowingHashmapMapElemChar<i32>>`\n    --> src/lib.rs:1335:16\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i];\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `GrowingHashmapMapElemChar<i32>`, which does not implement the `Copy` trait\n     |\nhelp: consider borrowing here\n     |\n1335 |     let elem = &hashmap.map.as_ref().unwrap()[i];\n     |                +\nhelp: consider cloning the value if the performance cost is acceptable\n     |\n1335 |     let elem = hashmap.map.as_ref().unwrap()[i].clone();\n     |                                                ++++++++\n\nFor more information about this error, try `rustc --explain E0507`.\nwarning: `strsim` (lib test) generated 5 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 5 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                "        used: 3,",
                "        fill: 5,",
                "        mask: 8,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "            GrowingHashmapMapElemChar::default(),",
                "        ]),",
                "    };",
                "    let key = 5;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 15);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1].value, 20);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2].value, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.fill, 5);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.used, 3);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[2].value == Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert!(hashmap.fill * 3 >= (hashmap.mask + 1) * 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert!(value.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert_eq!(*value, 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert_eq!(hashmap.used, 4);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert_eq!(hashmap.fill, 6);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[0].value, 15);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[1].value, 20);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[2].value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.fill, 5);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert_eq!(hashmap.used, 3);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert!(hashmap.map.as_ref().unwrap()[2].value == Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    assert!(hashmap.fill * 3 >= (hashmap.mask + 1) * 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert!(value.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert_eq!(*value, 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert_eq!(hashmap.used, 4);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar {",
                  "        used: 3,",
                  "        fill: 5,",
                  "        mask: 8,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar { key: 1, value: 15 }, ",
                  "            GrowingHashmapMapElemChar { key: 2, value: 20 }, ",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "            GrowingHashmapMapElemChar::default(),",
                  "        ]),",
                  "    };",
                  "    let key = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<i32> = GrowingHashmapChar { used: 3, fill: 5, mask: 8, map: Some(vec![GrowingHashmapMapElemChar { key: 1, value: 15 }, GrowingHashmapMapElemChar { key: 2, value: 20 }, GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(), GrowingHashmapMapElemChar::default(),]), };",
                  "    let value = hashmap.get_mut(5);",
                  "    assert_eq!(hashmap.fill, 6);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method named `is_some` found for mutable reference `&mut i32` in the current scope\n    --> src/lib.rs:1335:19\n     |\n1335 |     assert!(value.is_some());\n     |                   ^^^^^^^ method not found in `&mut i32`\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: self.map.is_none() is false\n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\") is \n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i] is \n",
        "// constraint: self\n            .map\n            .as_ref()\n            .expect(\"map should have been created above\")[i]\n            .value\n            == Default::default() is true\n",
        "// constraint: self.fill * 3 >= (self.mask + 1) * 2 is false\n",
        "// constraint: self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\") is \n",
        "// constraint: self\n            .map\n            .as_mut()\n            .expect(\"map should have been created above\")[i] is \n",
        "// expected return value/type: &mut elem.value\n"
      ],
      "input_infer": "0 <= key <= 7\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let key: u32 = 5;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().unwrap()[hashmap.lookup(key)].value != Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(key)].key, key);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(value, &mut hashmap.map.as_mut().unwrap()[hashmap.lookup(key)].value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().unwrap()[hashmap.lookup(key)].value != Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[hashmap.lookup(key)].key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let key: u32 = 5;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(value, &mut hashmap.map.as_mut().unwrap()[hashmap.lookup(key)].value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1323:9\n     |\n1323 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `hashmap.map` as mutable more than once at a time\n    --> src/lib.rs:1328:28\n     |\n1327 |     let value = hashmap.get_mut(key);\n     |                 ------- first mutable borrow occurs here\n1328 |     assert_eq!(value, &mut hashmap.map.as_mut().unwrap()[hashmap.lookup(key)].value);\n     |     -----------------------^^^^^^^^^^^----------------------------------------------\n     |     |                      |\n     |     |                      second mutable borrow occurs here\n     |     first borrow later used here\n\nerror[E0502]: cannot borrow `hashmap` as immutable because it is also borrowed as mutable\n    --> src/lib.rs:1328:58\n     |\n1327 |     let value = hashmap.get_mut(key);\n     |                 ------- mutable borrow occurs here\n1328 |     assert_eq!(value, &mut hashmap.map.as_mut().unwrap()[hashmap.lookup(key)].value);\n     |     -----------------------------------------------------^^^^^^^--------------------\n     |     |                                                    |\n     |     |                                                    immutable borrow occurs here\n     |     mutable borrow later used here\n\nSome errors have detailed explanations: E0499, E0502.\nFor more information about an error, try `rustc --explain E0499`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 0,",
                "        map: None,",
                "    };",
                "    let key: u32 = 3;",
                "    let value1 = hashmap.get_mut(key);",
                "    *value1 = 10;",
                "    let value2 = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let value1 = hashmap.get_mut(3);",
                  "    *value1 = 10;",
                  "    let value2 = hashmap.get_mut(3);",
                  "    assert_eq!(*value2, 10);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 0,",
                  "        map: None,",
                  "    };",
                  "    let key: u32 = 3;",
                  "    let value1 = hashmap.get_mut(key);",
                  "    *value1 = 10;",
                  "    let value2 = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 0, map: None };",
                  "    hashmap.allocate();",
                  "    let value1 = hashmap.get_mut(3);",
                  "    *value1 = 10;",
                  "    let value2 = hashmap.get_mut(3);",
                  "    assert_eq!(*value2, 10);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 7,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar::default(); 8",
                "        ]),",
                "    };",
                "    hashmap.fill = 5; // Manually set fill to a state",
                "    let key: u32 = 2;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().expect(\"map should have been created above\").len() > 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value, Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.fill * 3 < (hashmap.mask + 1) * 2);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_mut().expect(\"map should have been created above\").len() > 0);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_mut().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value != Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(value, &mut hashmap.map.as_mut().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_ref().expect(\"map should have been created above\").len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.fill * 3 < (hashmap.mask + 1) * 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_mut().expect(\"map should have been created above\").len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert!(hashmap.map.as_mut().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value != Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    hashmap.fill = 5; // Manually set fill to a state",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]) };",
                  "    hashmap.fill = 5;",
                  "    let key: u32 = 2;",
                  "    let value = hashmap.get_mut(key);",
                  "    assert_eq!(value, &mut hashmap.map.as_mut().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused variable: `value`\n    --> src/lib.rs:1326:9\n     |\n1326 |     let value = hashmap.get_mut(key);\n     |         ^^^^^ help: if this is intentional, prefix it with an underscore: `_value`\n     |\n     = note: `#[warn(unused_variables)]` on by default\n\nerror[E0499]: cannot borrow `hashmap.map` as mutable more than once at a time\n    --> src/lib.rs:1331:28\n     |\n1330 |     let value = hashmap.get_mut(key);\n     |                 ------- first mutable borrow occurs here\n1331 |     assert_eq!(value, &mut hashmap.map.as_mut().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value);\n     |     -----------------------^^^^^^^^^^^---------------------------------------------------------------------------------------------------\n     |     |                      |\n     |     |                      second mutable borrow occurs here\n     |     first borrow later used here\n\nerror[E0503]: cannot use `hashmap.mask` because it was mutably borrowed\n    --> src/lib.rs:1331:109\n     |\n1330 |     let value = hashmap.get_mut(key);\n     |                 ------- `hashmap` is borrowed here\n1331 |     assert_eq!(value, &mut hashmap.map.as_mut().expect(\"map should have been created above\")[key as usize & hashmap.mask as usize].value);\n     |     --------------------------------------------------------------------------------------------------------^^^^^^^^^^^^-----------------\n     |     |                                                                                                       |\n     |     |                                                                                                       use of borrowed `hashmap`\n     |     borrow later used here\n\nSome errors have detailed explanations: E0499, E0503.\nFor more information about an error, try `rustc --explain E0499`.\nwarning: `strsim` (lib test) generated 3 warnings\nerror: could not compile `strsim` (lib test) due to 2 previous errors; 3 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 3,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar::default(); 4",
                "        ]),",
                "    };",
                "    hashmap.fill = 3; // at max capacity to trigger resize",
                "    let key: u32 = 1;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                "        used: 0,",
                "        fill: 0,",
                "        mask: 7,",
                "        map: Some(vec![",
                "            GrowingHashmapMapElemChar::default(); 8",
                "        ]),",
                "    };",
                "    let key: u32 = 6;",
                "    let value = hashmap.get_mut(key);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 1);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    let i = hashmap.lookup(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[i].key, key);"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    let i = hashmap.lookup(key);",
                  "    assert_ne!(hashmap.map.as_ref().unwrap()[i].value, Default::default());"
                ],
                [
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    let i = hashmap.lookup(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[i].value, value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert!(hashmap.map.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.used, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.fill, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap().len(), 8);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    let i = hashmap.lookup(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[i].key, key);",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    let i = hashmap.lookup(key);",
                  "    assert_ne!(hashmap.map.as_ref().unwrap()[i].value, Default::default());",
                  "}"
                ],
                [
                  "{",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar {",
                  "        used: 0,",
                  "        fill: 0,",
                  "        mask: 7,",
                  "        map: Some(vec![",
                  "            GrowingHashmapMapElemChar::default(); 8",
                  "        ]),",
                  "    };",
                  "    let key: u32 = 6;",
                  "    let value = hashmap.get_mut(key);",
                  "    let mut hashmap: GrowingHashmapChar<u32> = GrowingHashmapChar { used: 0, fill: 0, mask: 7, map: Some(vec![GrowingHashmapMapElemChar::default(); 8]), };",
                  "    let key: u32 = 6;",
                  "    hashmap.get_mut(key);",
                  "    let i = hashmap.lookup(key);",
                  "    assert_eq!(hashmap.map.as_ref().unwrap()[i].value, value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling strsim v0.11.1 (/home/abezbm/rust-utgen-test-crates-new/strsim-rs)\nwarning: unused macro definition: `assert_delta`\n   --> src/lib.rs:760:18\n    |\n760 |     macro_rules! assert_delta {\n    |                  ^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `ntest::timeout`\n    --> src/lib.rs:1312:8\n     |\n1312 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n    --> src/lib.rs:1330:56\n     |\n1330 |     assert_eq!(hashmap.map.as_ref().unwrap()[i].value, value);\n     |                                                        ^^^^^ expected `u32`, found `&mut u32`\n     |\nhelp: consider dereferencing the borrow\n     |\n1330 |     assert_eq!(hashmap.map.as_ref().unwrap()[i].value, *value);\n     |                                                        +\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `strsim` (lib test) generated 2 warnings\nerror: could not compile `strsim` (lib test) due to 1 previous error; 2 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}