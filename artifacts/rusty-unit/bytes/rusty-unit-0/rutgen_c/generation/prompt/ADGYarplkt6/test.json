{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/buf/uninit_slice.rs\n// crate name is bytes\nuse core::fmt;\nuse core::mem::MaybeUninit;\nuse core::ops::{\n    Index, IndexMut, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo,\n    RangeToInclusive,\n};\nmacro_rules! impl_index {\n    ($($t:ty),*) => {\n        $(impl Index <$t > for UninitSlice { type Output = UninitSlice; #[inline] fn\n        index(& self, index : $t) -> & UninitSlice { UninitSlice::uninit_ref(& self\n        .0[index]) } } impl IndexMut <$t > for UninitSlice { #[inline] fn index_mut(& mut\n        self, index : $t) -> & mut UninitSlice { UninitSlice::uninit(& mut self.0[index])\n        } })*\n    };\n}\nimpl_index!(\n    Range < usize >, RangeFrom < usize >, RangeFull, RangeInclusive < usize >, RangeTo <\n    usize >, RangeToInclusive < usize >\n);\n#[repr(transparent)]\npub struct UninitSlice([MaybeUninit<u8>]);\nimpl UninitSlice {\n    #[inline]\n    pub fn new(slice: &mut [u8]) -> &mut UninitSlice {\n        unsafe {\n            &mut *(slice as *mut [u8] as *mut [MaybeUninit<u8>] as *mut UninitSlice)\n        }\n    }\n    #[inline]\n    pub fn uninit(slice: &mut [MaybeUninit<u8>]) -> &mut UninitSlice {}\n    fn uninit_ref(slice: &[MaybeUninit<u8>]) -> &UninitSlice {}\n    #[inline]\n    pub unsafe fn from_raw_parts_mut<'a>(\n        ptr: *mut u8,\n        len: usize,\n    ) -> &'a mut UninitSlice {}\n    #[inline]\n    pub fn write_byte(&mut self, index: usize, byte: u8) {}\n    #[inline]\n    pub fn copy_from_slice(&mut self, src: &[u8]) {}\n    #[inline]\n    pub fn as_mut_ptr(&mut self) -> *mut u8 {}\n    #[inline]\n    pub unsafe fn as_uninit_slice_mut(&mut self) -> &mut [MaybeUninit<u8>] {}\n    #[inline]\n    pub fn len(&self) -> usize {}\n}\n\nThe function to be tested is presented as follows:\n/// Creates a `&mut UninitSlice` wrapping a slice of initialised memory.\n///\n/// # Examples\n///\n/// ```\n/// use bytes::buf::UninitSlice;\n///\n/// let mut buffer = [0u8; 64];\n/// let slice = UninitSlice::new(&mut buffer[..]);\n/// ```\npub fn new(slice: &mut [u8]) -> &mut UninitSlice {\n    unsafe { &mut *(slice as *mut [u8] as *mut [MaybeUninit<u8>] as *mut UninitSlice) }\n}\n",
  "depend_pt": ""
}