{
    "function_name": "bytes::bytes::shallow_clone_vec",
    "tests": 4,
    "tests_lines": [
        14,
        18,
        8,
        14
    ],
    "oracles": 4,
    "oracles_compiled": 4,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 4,
    "tests_compiled_rate": 100.0,
    "oracles_run": 4,
    "oracles_passed": 1,
    "oracles_passed_rate": 25.0,
    "tests_run": 4,
    "tests_passed": 1,
    "tests_passed_rate": 25.0,
    "lines": 53,
    "lines_covered": 43,
    "lines_coveraged_rate": 81.13207547169812,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1493,
        1494,
        1495,
        1496,
        1497,
        1498,
        1499,
        1500,
        1501,
        1502,
        1503,
        1504,
        1505,
        1506,
        1507,
        1508,
        1509,
        1510,
        1511,
        1512,
        1513,
        1514,
        1515,
        1516,
        1517,
        1518,
        1519,
        1520,
        1521,
        1522,
        1523,
        1524,
        1525,
        1538,
        1539,
        1540,
        1543,
        1544,
        1545,
        1546,
        1547,
        1548,
        1550,
        1551,
        1552,
        1553,
        1554,
        1555,
        1556,
        1557,
        1558,
        1559,
        1562
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = unsafe { alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "    let offset: *const u8 = unsafe { buf.add(0) };",
                "    let len = 10;",
                "",
                "    let cloned_bytes = unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "",
                "    assert_eq!(cloned_bytes.len, len);",
                "    assert_eq!(cloned_bytes.ptr, offset);",
                "    assert!(!cloned_bytes.data.load(Ordering::Relaxed).is_null());",
                "",
                "    unsafe { alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = unsafe { alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "    let offset: *const u8 = unsafe { buf.add(0) };",
                "    let len = 10;",
                "",
                "    // Simulate a successful promotion of buffer to `Arc` by setting",
                "    // the atom pointer directly.",
                "    atom.store(buf as *mut _, Ordering::Release);",
                "",
                "    let cloned_bytes = unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "",
                "    assert_eq!(cloned_bytes.len, len);",
                "    assert_eq!(cloned_bytes.ptr, offset);",
                "    assert!(!cloned_bytes.data.load(Ordering::Relaxed).is_null());",
                "",
                "    unsafe { alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = ptr::null_mut(); // Invalid buffer",
                "    let offset: *const u8 = ptr::null();",
                "    let len = 0;",
                "",
                "    unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = unsafe { alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(0, 1).unwrap()) };",
                "    let offset: *const u8 = ptr::null();",
                "    let len = 0;",
                "",
                "    let cloned_bytes = unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "",
                "    assert_eq!(cloned_bytes.len, len);",
                "    assert_eq!(cloned_bytes.ptr, offset);",
                "    assert!(!cloned_bytes.data.load(Ordering::Relaxed).is_null());",
                "",
                "    unsafe { alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(0, 1).unwrap()) };",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1538,
                1539,
                1540
            ]
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = unsafe { alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "    let offset: *const u8 = unsafe { buf.add(0) };",
                "    let len = 10;",
                "",
                "    let cloned_bytes = unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "",
                "    assert_eq!(cloned_bytes.len, len);",
                "    assert_eq!(cloned_bytes.ptr, offset);",
                "    assert!(!cloned_bytes.data.load(Ordering::Relaxed).is_null());",
                "",
                "    unsafe { alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = unsafe { alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "    let offset: *const u8 = unsafe { buf.add(0) };",
                "    let len = 10;",
                "",
                "    // Simulate a successful promotion of buffer to `Arc` by setting",
                "    // the atom pointer directly.",
                "    atom.store(buf as *mut _, Ordering::Release);",
                "",
                "    let cloned_bytes = unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "",
                "    assert_eq!(cloned_bytes.len, len);",
                "    assert_eq!(cloned_bytes.ptr, offset);",
                "    assert!(!cloned_bytes.data.load(Ordering::Relaxed).is_null());",
                "",
                "    unsafe { alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(10, 1).unwrap()) };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = ptr::null_mut(); // Invalid buffer",
                "    let offset: *const u8 = ptr::null();",
                "    let len = 0;",
                "",
                "    unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(ptr::null_mut());",
                "    let buf: *mut u8 = unsafe { alloc::alloc::alloc(alloc::alloc::Layout::from_size_align(0, 1).unwrap()) };",
                "    let offset: *const u8 = ptr::null();",
                "    let len = 0;",
                "",
                "    let cloned_bytes = unsafe { shallow_clone_vec(&atom, buf as *const (), buf, offset, len) };",
                "",
                "    assert_eq!(cloned_bytes.len, len);",
                "    assert_eq!(cloned_bytes.ptr, offset);",
                "    assert!(!cloned_bytes.data.load(Ordering::Relaxed).is_null());",
                "",
                "    unsafe { alloc::alloc::dealloc(buf, alloc::alloc::Layout::from_size_align(0, 1).unwrap()) };",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes.rs"
}