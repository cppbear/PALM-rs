{
    "function_name": "bytes::bytes_mut::bytes_mut::BytesMut::try_unsplit",
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/bytes",
    "tests": 62,
    "tests_lines": [
        39,
        39,
        39,
        38,
        38,
        38,
        38,
        38,
        19,
        21,
        14,
        9,
        9,
        9,
        9,
        9,
        11,
        11,
        12,
        12,
        12,
        12,
        12,
        11,
        11,
        9,
        9,
        26,
        26,
        26,
        20,
        20,
        20,
        20,
        20,
        16,
        16,
        11,
        11,
        11,
        12,
        12,
        12,
        12,
        12,
        11,
        11,
        11,
        12,
        10,
        10,
        10,
        10,
        10,
        11,
        10,
        10,
        9,
        9,
        9,
        9,
        9
    ],
    "oracles": 21,
    "oracles_compiled": 20,
    "oracles_compiled_rate": 95.23809523809523,
    "tests_compiled": 58,
    "tests_compiled_rate": 93.54838709677419,
    "oracles_run": 20,
    "oracles_passed": 10,
    "oracles_passed_rate": 50.0,
    "tests_run": 58,
    "tests_passed": 23,
    "tests_passed_rate": 39.6551724137931,
    "lines": 15,
    "lines_covered": 9,
    "lines_coveraged_rate": 60.0,
    "branches": 10,
    "branches_covered": 3,
    "branches_coverage_rate": 30.0,
    "codes_lines": [
        993,
        994,
        995,
        996,
        997,
        998,
        999,
        1000,
        1001,
        1002,
        1005,
        1006,
        1007,
        1009,
        1011
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![1, 2, 3],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "            cap: shared_data.vec.capacity(),",
                "            data: &shared_data as *const _ as *mut _,",
                "        }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "    self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = BytesMut::from_vec(vec![1, 2, 3]);",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6;",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    unsafe { self_bytes.set_len(self_bytes.len); }",
                "    assert_eq!(self_bytes.try_unsplit(other_bytes).is_ok(), true);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![1, 2, 3],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "        }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "    self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = BytesMut::from_vec(vec![1, 2, 3]);",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6;",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    unsafe { self_bytes.set_len(self_bytes.len); }",
                "    assert_eq!(self_bytes.len, 6);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "   let mut shared_data = TestShared {",
                "       vec: vec![1, 2, 3],",
                "       original_capacity_repr: 3,",
                "       ref_count: AtomicUsize::new(1),",
                "   };",
                "   BytesMut {",
                "       ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "       len: shared_data.vec.len(),",
                "       cap: shared_data.vec.capacity(),",
                "       data: &shared_data as *const _ as *mut _,",
                "   }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "    self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = BytesMut::from_vec(vec![1, 2, 3]);",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6;",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    unsafe { self_bytes.set_len(self_bytes.len); }",
                "    assert_eq!(self_bytes.cap, 9);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![7, 8, 9],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "           }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "   self_bytes.try_unsplit(other_bytes.clone());",
                "   let self_bytes_capacity = self_bytes.capacity();",
                "   let other_bytes_capacity = other_bytes.capacity();",
                "   let self_bytes_len = self_bytes.len();",
                "   let other_bytes_len = other_bytes.len();",
                "   let result = self_bytes.try_unsplit(other_bytes);",
                "    assert_eq!(result, Ok(()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![7, 8, 9],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "        }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "   self_bytes.try_unsplit(other_bytes.clone()).unwrap();",
                "   let self_bytes_capacity = self_bytes.capacity();",
                "   let other_bytes_capacity = other_bytes.capacity();",
                "   let self_bytes_len = self_bytes.len();",
                "   let other_bytes_len = other_bytes.len();",
                "   let result = self_bytes.try_unsplit(other_bytes).unwrap();",
                "   assert_eq!(self_bytes.len(), self_bytes_len + other_bytes_len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![7, 8, 9],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "           }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "   self_bytes.try_unsplit(other_bytes.clone()).unwrap();",
                "   let self_bytes_capacity = self_bytes.capacity();",
                "   let other_bytes_capacity = other_bytes.capacity();",
                "   let self_bytes_len = self_bytes.len();",
                "   let other_bytes_len = other_bytes.len();",
                "   let result = self_bytes.try_unsplit(other_bytes.clone()).unwrap();",
                "   assert_eq!(self_bytes.ptr.as_ptr(), unsafe { other_bytes.ptr.as_ptr().sub(other_bytes_len) });",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    ",
                "    // To satisfy the constraints self.data == other.data",
                "    // This part assumes that `self_bytes_mut` and `other_bytes_mut` would have the same data reference",
                "    // We will need to set them up accordingly, possibly leveraging shared buffers if such a method exists.",
                "",
                "    unsafe {",
                "        self_bytes_mut.promote_to_shared(1); // Simulating shared reference",
                "    }",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    unsafe { self_bytes_mut.promote_to_shared(1); }",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(MAX_VEC_POS);",
                "    let other_bytes_mut = BytesMut::new();",
                "",
                "    unsafe {",
                "        self_bytes_mut.promote_to_shared(1);",
                "    }",
                "",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(MAX_VEC_POS);",
                "    let other_bytes_mut = BytesMut::new();",
                "    unsafe { self_bytes_mut.promote_to_shared(1); }",
                "    assert_eq!(result, Ok(()));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(matches!(result, Err(_)));",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.err().unwrap().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.len(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.capacity(), 10);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    self_bytes_mut.resize(5, 0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    self_bytes_mut.resize(5, 0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut.clone());",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut.clone());",
                "   assert_eq!(result.err(), Some(other_bytes_mut));",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   assert_eq!(result.is_err(), true);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "    assert_eq!(self_bytes_mut.len(), 5);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "    assert_eq!(self_bytes_mut.capacity(), 10);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "    assert_eq!(self_bytes_mut.spare_capacity_mut().len() > 0, true);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.err().unwrap().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let vec = vec![1, 2, 3, 4];",
                "   let mut other_bytes = BytesMut::from_vec(vec);  ",
                "   unsafe {  ",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "       self_bytes.len = 4;  ",
                "       self_bytes.cap = 16;  ",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "       other_bytes.len = 0;  ",
                "       other_bytes.cap = 0;  ",
                "   }  ",
                "   let result = self_bytes.try_unsplit(other_bytes);  ",
                "   let mut self_bytes = BytesMut::with_capacity(16);  ",
                "   let vec = vec![1, 2, 3, 4];  ",
                "   let mut other_bytes = BytesMut::from_vec(vec);  ",
                "   unsafe {  ",
                "   self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "   self_bytes.len = 4;  ",
                "   self_bytes.cap = 16;  ",
                "   other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "   other_bytes.len = 0;  ",
                "   other_bytes.cap = 0;  ",
                "    }",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let vec = vec![1, 2, 3, 4];",
                "  let mut other_bytes = BytesMut::from_vec(vec);  ",
                "  unsafe {  ",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "       self_bytes.len = 4;  ",
                "       self_bytes.cap = 16;  ",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "       other_bytes.len = 0;  ",
                "       other_bytes.cap = 0;  ",
                "   }  ",
                "   let result = self_bytes.try_unsplit(other_bytes);  ",
                "   let mut self_bytes = BytesMut::with_capacity(16);  ",
                "   let vec = vec![1, 2, 3, 4];  ",
                "   let mut other_bytes = BytesMut::from_vec(vec);  ",
                "   unsafe {  ",
                "   self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "   self_bytes.len = 4;  ",
                "   self_bytes.cap = 16;  ",
                "   other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "   other_bytes.len = 0;  ",
                "   other_bytes.cap = 0;  ",
                "   }  ",
                "    assert_eq!(result.unwrap_err().len(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec); // changed to mutable",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "   }",
                "   ",
                "   let result = self_bytes.try_unsplit(other_bytes);",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let other_bytes = BytesMut::from_vec(vec);",
                "   assert_eq!(other_bytes.capacity(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "  let mut self_bytes = BytesMut::with_capacity(10);  ",
                "  let vec = vec![1, 2, 3];  ",
                "  let mut other_bytes = BytesMut::from_vec(vec);  ",
                "  ",
                "  unsafe {  ",
                "      self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "      self_bytes.len = 3;  ",
                "      self_bytes.cap = 10;  ",
                "      ",
                "      other_bytes.len = 0; // Ensuring capacity is 0  ",
                "      other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "  }  ",
                "  ",
                "  let result = self_bytes.try_unsplit(other_bytes);  ",
                "  let mut self_bytes = BytesMut::with_capacity(10);  ",
                "  let vec = vec![1, 2, 3];  ",
                "  let mut other_bytes = BytesMut::from_vec(vec);  ",
                "  unsafe { assert_eq!(self_bytes.ptr.as_ptr().add(self_bytes.len), other_bytes.ptr.as_ptr()); }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec); // Changed to mutable",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "    }",
                "    ",
                "    let result = self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::with_capacity(10);",
                "    let vec = vec![1, 2, 3];",
                "    let other_bytes = BytesMut::from_vec(vec);",
                "    assert_eq!(self_bytes.kind(), KIND_ARC);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec);",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "   }",
                "   ",
                "   let result = self_bytes.try_unsplit(other_bytes);",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec);",
                "    assert_ne!(other_bytes.kind(), KIND_ARC);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec);",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "   }",
                "    ",
                "    let result = self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::with_capacity(10);",
                "    let vec = vec![1, 2, 3];",
                "    let other_bytes = BytesMut::from_vec(vec);",
                "    assert_eq!(result, Err(other_bytes));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "",
                "    unsafe {",
                "        self_bytes.len = 8;",
                "        self_bytes.cap = 8;",
                "    }",
                "    ",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "    unsafe { self_bytes.len = 8; self_bytes.cap = 8; }",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "",
                "    unsafe {",
                "        self_bytes.len = 8;",
                "        self_bytes.cap = 8;",
                "    }",
                "    ",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "    unsafe { self_bytes.len = 8; self_bytes.cap = 8; }",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    assert_eq!(self_bytes_mut.len(), 8);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    assert_eq!(self_bytes_mut.capacity(), 16);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    assert!(other_bytes_mut.is_empty());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.err().unwrap().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.len(), 15);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.capacity(), 32);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    assert_eq!(self_bytes_mut.len(), 5);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    assert_eq!(self_bytes_mut.capacity(), 10);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    assert!(self_bytes_mut.kind() == KIND_VEC);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.unwrap_err().capacity(), 5);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.unwrap_err().len(), 0);",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    self_bytes_mut.resize(5, 0);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    self_bytes_mut.resize(5, 0);",
                "    assert_eq!(result, Err(other_bytes_mut));",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(15);",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   self_bytes_mut = BytesMut::with_capacity(10);",
                "   other_bytes_mut = BytesMut::with_capacity(15);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   assert!(result.is_err());",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(15);  ",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   other_bytes_mut = BytesMut::with_capacity(15);  ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   assert_eq!(result.unwrap_err().capacity(), 15);  ",
                "}"
            ],
            [
                993,
                994,
                996,
                997,
                998,
                999,
                1009,
                1011
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert_eq!(other_bytes_mut.capacity(), 0);",
                "}"
            ],
            []
        ],
        [
            [
                "   {  ",
                "       let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);  ",
                "       let other_bytes_mut = BytesMut::with_capacity(1);  ",
                "       ",
                "       let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "       let self_bytes_mut = BytesMut::with_capacity(usize::MAX);  ",
                "       let other_bytes_mut = BytesMut::with_capacity(1);  ",
                "       assert!(self_bytes_mut.ptr.as_ptr() != other_bytes_mut.ptr.as_ptr());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert!(result.is_err());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert!(result.err().is_some());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert_eq!(result.err().unwrap(), other_bytes_mut);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 994,
            "start_column": 12,
            "end_line": 994,
            "end_column": 33,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 999,
            "start_column": 12,
            "end_line": 999,
            "end_column": 37,
            "positive": false,
            "negative": true
        },
        {
            "start_line": 1000,
            "start_column": 16,
            "end_line": 1000,
            "end_column": 39,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1001,
            "start_column": 16,
            "end_line": 1001,
            "end_column": 40,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1002,
            "start_column": 16,
            "end_line": 1002,
            "end_column": 39,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![1, 2, 3],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "            cap: shared_data.vec.capacity(),",
                "            data: &shared_data as *const _ as *mut _,",
                "        }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "    self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = BytesMut::from_vec(vec![1, 2, 3]);",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6;",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    unsafe { self_bytes.set_len(self_bytes.len); }",
                "    assert_eq!(self_bytes.try_unsplit(other_bytes).is_ok(), true);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![1, 2, 3],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "        }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "    self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = BytesMut::from_vec(vec![1, 2, 3]);",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6;",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    unsafe { self_bytes.set_len(self_bytes.len); }",
                "    assert_eq!(self_bytes.len, 6);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "   let mut shared_data = TestShared {",
                "       vec: vec![1, 2, 3],",
                "       original_capacity_repr: 3,",
                "       ref_count: AtomicUsize::new(1),",
                "   };",
                "   BytesMut {",
                "       ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "       len: shared_data.vec.len(),",
                "       cap: shared_data.vec.capacity(),",
                "       data: &shared_data as *const _ as *mut _,",
                "   }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "    self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = BytesMut::from_vec(vec![1, 2, 3]);",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6;",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    unsafe { self_bytes.set_len(self_bytes.len); }",
                "    assert_eq!(self_bytes.cap, 9);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![7, 8, 9],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "           }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "   self_bytes.try_unsplit(other_bytes.clone());",
                "   let self_bytes_capacity = self_bytes.capacity();",
                "   let other_bytes_capacity = other_bytes.capacity();",
                "   let self_bytes_len = self_bytes.len();",
                "   let other_bytes_len = other_bytes.len();",
                "   let result = self_bytes.try_unsplit(other_bytes);",
                "    assert_eq!(result, Ok(()));",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![7, 8, 9],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "        }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "   self_bytes.try_unsplit(other_bytes.clone()).unwrap();",
                "   let self_bytes_capacity = self_bytes.capacity();",
                "   let other_bytes_capacity = other_bytes.capacity();",
                "   let self_bytes_len = self_bytes.len();",
                "   let other_bytes_len = other_bytes.len();",
                "   let result = self_bytes.try_unsplit(other_bytes).unwrap();",
                "   assert_eq!(self_bytes.len(), self_bytes_len + other_bytes_len);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestShared {",
                "        vec: Vec<u8>,",
                "        original_capacity_repr: usize,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    let mut self_bytes = BytesMut::new();",
                "    let other_bytes = {",
                "           let mut shared_data = TestShared {",
                "               vec: vec![7, 8, 9],",
                "               original_capacity_repr: 3,",
                "               ref_count: AtomicUsize::new(1),",
                "           };",
                "           BytesMut {",
                "               ptr: NonNull::new(shared_data.vec.as_mut_ptr()).unwrap(),",
                "               len: shared_data.vec.len(),",
                "               cap: shared_data.vec.capacity(),",
                "               data: &shared_data as *const _ as *mut _,",
                "           }",
                "    };",
                "",
                "    self_bytes.len = 3;",
                "    self_bytes.cap = 6; // Ensure capacity is enough",
                "    self_bytes.ptr = NonNull::new(vec![4, 5, 6].as_mut_ptr()).unwrap();",
                "    ",
                "    unsafe {",
                "        self_bytes.set_len(self_bytes.len);",
                "    }",
                "    ",
                "   self_bytes.try_unsplit(other_bytes.clone()).unwrap();",
                "   let self_bytes_capacity = self_bytes.capacity();",
                "   let other_bytes_capacity = other_bytes.capacity();",
                "   let self_bytes_len = self_bytes.len();",
                "   let other_bytes_len = other_bytes.len();",
                "   let result = self_bytes.try_unsplit(other_bytes.clone()).unwrap();",
                "   assert_eq!(self_bytes.ptr.as_ptr(), unsafe { other_bytes.ptr.as_ptr().sub(other_bytes_len) });",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    ",
                "    // To satisfy the constraints self.data == other.data",
                "    // This part assumes that `self_bytes_mut` and `other_bytes_mut` would have the same data reference",
                "    // We will need to set them up accordingly, possibly leveraging shared buffers if such a method exists.",
                "",
                "    unsafe {",
                "        self_bytes_mut.promote_to_shared(1); // Simulating shared reference",
                "    }",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    unsafe { self_bytes_mut.promote_to_shared(1); }",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(MAX_VEC_POS);",
                "    let other_bytes_mut = BytesMut::new();",
                "",
                "    unsafe {",
                "        self_bytes_mut.promote_to_shared(1);",
                "    }",
                "",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(MAX_VEC_POS);",
                "    let other_bytes_mut = BytesMut::new();",
                "    unsafe { self_bytes_mut.promote_to_shared(1); }",
                "    assert_eq!(result, Ok(()));",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(matches!(result, Err(_)));",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.err().unwrap().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.capacity(), 10);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    self_bytes_mut.resize(5, 0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    self_bytes_mut.resize(5, 0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut.clone());",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut.clone());",
                "   assert_eq!(result.err(), Some(other_bytes_mut));",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   assert_eq!(result.is_err(), true);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "    assert_eq!(self_bytes_mut.len(), 5);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);",
                "   self_bytes_mut.resize(5, 0);",
                "   other_bytes_mut.resize(5, 1);",
                "    assert_eq!(self_bytes_mut.capacity(), 10);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(0);  ",
                "   self_bytes_mut.resize(5, 0);  ",
                "   other_bytes_mut.resize(5, 1);  ",
                "    assert_eq!(self_bytes_mut.spare_capacity_mut().len() > 0, true);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0);",
                "    let other_bytes_mut = BytesMut::with_capacity(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.err().unwrap().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let empty_other = BytesMut::new();",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let vec = vec![1, 2, 3, 4];",
                "   let mut other_bytes = BytesMut::from_vec(vec);  ",
                "   unsafe {  ",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "       self_bytes.len = 4;  ",
                "       self_bytes.cap = 16;  ",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "       other_bytes.len = 0;  ",
                "       other_bytes.cap = 0;  ",
                "   }  ",
                "   let result = self_bytes.try_unsplit(other_bytes);  ",
                "   let mut self_bytes = BytesMut::with_capacity(16);  ",
                "   let vec = vec![1, 2, 3, 4];  ",
                "   let mut other_bytes = BytesMut::from_vec(vec);  ",
                "   unsafe {  ",
                "   self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "   self_bytes.len = 4;  ",
                "   self_bytes.cap = 16;  ",
                "   other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "   other_bytes.len = 0;  ",
                "   other_bytes.cap = 0;  ",
                "    }",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(16);",
                "    let vec = vec![1, 2, 3, 4];",
                "  let mut other_bytes = BytesMut::from_vec(vec);  ",
                "  unsafe {  ",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "       self_bytes.len = 4;  ",
                "       self_bytes.cap = 16;  ",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "       other_bytes.len = 0;  ",
                "       other_bytes.cap = 0;  ",
                "   }  ",
                "   let result = self_bytes.try_unsplit(other_bytes);  ",
                "   let mut self_bytes = BytesMut::with_capacity(16);  ",
                "   let vec = vec![1, 2, 3, 4];  ",
                "   let mut other_bytes = BytesMut::from_vec(vec);  ",
                "   unsafe {  ",
                "   self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "   self_bytes.len = 4;  ",
                "   self_bytes.cap = 16;  ",
                "   other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "   other_bytes.len = 0;  ",
                "   other_bytes.cap = 0;  ",
                "   }  ",
                "    assert_eq!(result.unwrap_err().len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec); // changed to mutable",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "   }",
                "   ",
                "   let result = self_bytes.try_unsplit(other_bytes);",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let other_bytes = BytesMut::from_vec(vec);",
                "   assert_eq!(other_bytes.capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "  let mut self_bytes = BytesMut::with_capacity(10);  ",
                "  let vec = vec![1, 2, 3];  ",
                "  let mut other_bytes = BytesMut::from_vec(vec);  ",
                "  ",
                "  unsafe {  ",
                "      self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);  ",
                "      self_bytes.len = 3;  ",
                "      self_bytes.cap = 10;  ",
                "      ",
                "      other_bytes.len = 0; // Ensuring capacity is 0  ",
                "      other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);  ",
                "  }  ",
                "  ",
                "  let result = self_bytes.try_unsplit(other_bytes);  ",
                "  let mut self_bytes = BytesMut::with_capacity(10);  ",
                "  let vec = vec![1, 2, 3];  ",
                "  let mut other_bytes = BytesMut::from_vec(vec);  ",
                "  unsafe { assert_eq!(self_bytes.ptr.as_ptr().add(self_bytes.len), other_bytes.ptr.as_ptr()); }",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec); // Changed to mutable",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "    }",
                "    ",
                "    let result = self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::with_capacity(10);",
                "    let vec = vec![1, 2, 3];",
                "    let other_bytes = BytesMut::from_vec(vec);",
                "    assert_eq!(self_bytes.kind(), KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec);",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "   }",
                "   ",
                "   let result = self_bytes.try_unsplit(other_bytes);",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec);",
                "    assert_ne!(other_bytes.kind(), KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes = BytesMut::with_capacity(10);",
                "   let vec = vec![1, 2, 3];",
                "   let mut other_bytes = BytesMut::from_vec(vec);",
                "   ",
                "   unsafe {",
                "       self_bytes.ptr = NonNull::new_unchecked(other_bytes.ptr.as_ptr() as *mut u8);",
                "       self_bytes.len = 3;",
                "       self_bytes.cap = 10;",
                "       ",
                "       other_bytes.len = 0; // Ensuring capacity is 0",
                "       other_bytes.ptr = NonNull::new_unchecked(self_bytes.ptr.as_ptr() as *mut u8);",
                "   }",
                "    ",
                "    let result = self_bytes.try_unsplit(other_bytes);",
                "    let mut self_bytes = BytesMut::with_capacity(10);",
                "    let vec = vec![1, 2, 3];",
                "    let other_bytes = BytesMut::from_vec(vec);",
                "    assert_eq!(result, Err(other_bytes));",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "",
                "    unsafe {",
                "        self_bytes.len = 8;",
                "        self_bytes.cap = 8;",
                "    }",
                "    ",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "    unsafe { self_bytes.len = 8; self_bytes.cap = 8; }",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "",
                "    unsafe {",
                "        self_bytes.len = 8;",
                "        self_bytes.cap = 8;",
                "    }",
                "    ",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    let mut self_bytes = BytesMut::with_capacity(8);",
                "    let empty_other = BytesMut::new();",
                "    unsafe { self_bytes.len = 8; self_bytes.cap = 8; }",
                "    let result = self_bytes.try_unsplit(empty_other);",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    assert_eq!(self_bytes_mut.len(), 8);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    assert_eq!(self_bytes_mut.capacity(), 16);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    assert!(other_bytes_mut.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8); // self.len = 8, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::new(); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(16);",
                "    self_bytes_mut.resize(8, 0u8);",
                "    let other_bytes_mut = BytesMut::new();",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.err().unwrap().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.len(), 15);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8); // self.len = 15, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::zeroed(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(32);",
                "    self_bytes_mut.resize(15, 0u8);",
                "    let other_bytes_mut = BytesMut::zeroed(0);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(self_bytes_mut.capacity(), 32);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    assert_eq!(self_bytes_mut.len(), 5);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    assert_eq!(self_bytes_mut.capacity(), 10);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    assert!(self_bytes_mut.kind() == KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "",
                "    let _result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    self_bytes_mut.resize(5, 0u8); // self.len = 5, self.kind() == KIND_VEC",
                "    let other_bytes_mut = BytesMut::with_capacity(0); // other.capacity() == 0",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   self_bytes_mut = BytesMut::with_capacity(10);",
                "   let other_bytes_mut = BytesMut::new();",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.unwrap_err().capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.unwrap_err().capacity(), 5);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    assert_eq!(result.unwrap_err().len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    self_bytes_mut.resize(5, 0);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "    let other_bytes_mut = BytesMut::with_capacity(5);",
                "    self_bytes_mut.resize(5, 0);",
                "    assert_eq!(result, Err(other_bytes_mut));",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);",
                "   let mut other_bytes_mut = BytesMut::with_capacity(15);",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   self_bytes_mut = BytesMut::with_capacity(10);",
                "   other_bytes_mut = BytesMut::with_capacity(15);",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "   assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   let mut other_bytes_mut = BytesMut::with_capacity(15);  ",
                "   ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   self_bytes_mut = BytesMut::with_capacity(10);  ",
                "   other_bytes_mut = BytesMut::with_capacity(15);  ",
                "   let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "   assert_eq!(result.unwrap_err().capacity(), 15);  ",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert_eq!(other_bytes_mut.capacity(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "   {  ",
                "       let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);  ",
                "       let other_bytes_mut = BytesMut::with_capacity(1);  ",
                "       ",
                "       let result = self_bytes_mut.try_unsplit(other_bytes_mut);  ",
                "       let self_bytes_mut = BytesMut::with_capacity(usize::MAX);  ",
                "       let other_bytes_mut = BytesMut::with_capacity(1);  ",
                "       assert!(self_bytes_mut.ptr.as_ptr() != other_bytes_mut.ptr.as_ptr());  ",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert!(result.is_err());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert!(result.err().is_some());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    ",
                "    let result = self_bytes_mut.try_unsplit(other_bytes_mut);",
                "    let self_bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let other_bytes_mut = BytesMut::with_capacity(1);",
                "    assert_eq!(result.err().unwrap(), other_bytes_mut);",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ]
}