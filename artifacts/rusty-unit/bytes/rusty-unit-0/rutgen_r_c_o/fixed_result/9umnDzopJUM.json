{
    "function_name": "bytes::bytes::shallow_clone_vec",
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/bytes",
    "tests": 79,
    "tests_lines": [
        13,
        13,
        13,
        13,
        13,
        13,
        17,
        17,
        17,
        17,
        14,
        14,
        14,
        14,
        19,
        19,
        15,
        24,
        25,
        25,
        25,
        25,
        28,
        29,
        29,
        29,
        29,
        24,
        24,
        24,
        24,
        24,
        24,
        32,
        33,
        33,
        24,
        24,
        24,
        24,
        21,
        21,
        21,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        17,
        18,
        19,
        19,
        19,
        16,
        17,
        18,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16
    ],
    "oracles": 20,
    "oracles_compiled": 14,
    "oracles_compiled_rate": 70.0,
    "tests_compiled": 40,
    "tests_compiled_rate": 50.63291139240506,
    "oracles_run": 14,
    "oracles_passed": 5,
    "oracles_passed_rate": 35.714285714285715,
    "tests_run": 40,
    "tests_passed": 8,
    "tests_passed_rate": 20.0,
    "lines": 53,
    "lines_covered": 43,
    "lines_coveraged_rate": 81.13207547169812,
    "branches": 1,
    "branches_covered": 1,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1493,
        1494,
        1495,
        1496,
        1497,
        1498,
        1499,
        1500,
        1501,
        1502,
        1503,
        1504,
        1505,
        1506,
        1507,
        1508,
        1509,
        1510,
        1511,
        1512,
        1513,
        1514,
        1515,
        1516,
        1517,
        1518,
        1519,
        1520,
        1521,
        1522,
        1523,
        1524,
        1525,
        1538,
        1539,
        1540,
        1543,
        1544,
        1545,
        1546,
        1547,
        1548,
        1550,
        1551,
        1552,
        1553,
        1554,
        1555,
        1556,
        1557,
        1558,
        1559,
        1562
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   assert!(atom.compare_exchange(std::ptr::null_mut(), buf as _, Ordering::AcqRel, Ordering::Acquire).is_err());",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   ",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "   ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "    assert!(result.ptr == offset);",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   assert!(result.len == len);",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf.cast::<u8>(), offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf.cast::<u8>(), offset, len) };",
                "    assert!(result.data.load(Ordering::Relaxed) != std::ptr::null_mut());",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(std::ptr::null_mut());",
                "    let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "   ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "  let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                "  let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer  ",
                "  let offset = buf as *const u8;  ",
                "  let len = 10; // Set to valid length  ",
                "  ",
                "  let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };  ",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let offset = buf as *const u8;",
                "  let len = 10; // Set to valid length  ",
                "  let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };  ",
                "  assert!(!result.ptr.is_null());  // Update assertion as result should not be null",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // cast to *mut u8",
                "   let offset = buf as *const u8;",
                "   let len = 0; // Not valid",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf, offset, len) };",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // cast to *mut u8",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let offset = buf as *const u8;",
                "   let len = 0;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf, offset, len) };",
                "   assert_eq!(result.len, 0);",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // valid non-null pointer",
                "    let offset = buf as *const u8;",
                "    let len = 0; // Not valid",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let offset = buf as *const u8;",
                "   let len = 0;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "    assert!(result.data.load(Ordering::Relaxed).is_null());",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "  let atom: std::sync::atomic::AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "  let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // changed to *mut u8",
                "  let offset = buf as *const u8;",
                "  let len = usize::MAX; // Edge case",
                "",
                "  let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf, offset, len) };",
                "  let atom: std::sync::atomic::AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "  let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // changed to *mut u8",
                "  let offset = buf as *const u8;",
                "  let len = usize::MAX; // Edge case",
                "  let shared = Box::new(Shared {",
                "  buf,",
                "  cap: offset_from(offset, buf) + len,",
                "  ref_cnt: AtomicUsize::new(2),",
                "  });",
                "  let shared_ptr = Box::into_raw(shared);",
                "  assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer  ",
                "   let offset = buf as *const u8;  ",
                "   let len = usize::MAX; // Edge case  ",
                " ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };  ",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer  ",
                "   let offset = buf as *const u8;  ",
                "   let len = usize::MAX; // Edge case  ",
                "   let shared = Box::new(Shared {  ",
                "   buf: buf as *mut u8,  ",
                "   cap: offset_from(offset, buf as *const u8) + len,  ",
                "   ref_cnt: AtomicUsize::new(2),  ",
                "   });  ",
                "   let shared_ptr = Box::into_raw(shared);  ",
                "   assert!(atom.compare_exchange(std::ptr::null_mut(), shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_err());",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                " let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                " let buf = Box::into_raw(Box::new(vec![0u8; 1_000_000])); // valid non-null pointer  ",
                " let offset = buf as *const u8;  ",
                " let len = 100_000;  ",
                "",
                " let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf.cast::<u8>(), offset, len) };  ",
                " let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                " let buf = Box::into_raw(Box::new(vec![0u8; 1_000_000])); // valid non-null pointer  ",
                " let offset = buf as *const u8;  ",
                " let len = 100_000;  ",
                " let shared_ptr = Box::into_raw(Box::new(Shared { buf: buf.cast::<u8>(), cap: offset_from(offset, buf as *const u8) + len, ref_cnt: AtomicUsize::new(2) }));  ",
                " debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");  ",
                " assert!(atom.compare_exchange(std::ptr::null_mut(), shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_err());",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 10];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = NonNull::from(&mut buffer).cast::<()>().as_ptr();",
                "  let atom = AtomicPtr::new(atom_ptr);",
                "   let offset: *const u8 = buf_ptr;",
                "   let len: usize = 5;",
                "   ",
                "   unsafe {",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);",
                "   }",
                "   let mut buffer: Vec<u8> = vec![0u8; 10];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = NonNull::from(&mut buffer).cast::<()>().as_ptr();",
                "  let atom = AtomicPtr::new(atom_ptr.cast::<u8>());",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = 5;  ",
                "   let shared = Box::new(Shared { buf: buf_ptr, cap: offset_from(offset, buf_ptr) + len, ref_cnt: AtomicUsize::new(2) });  ",
                "   let shared_ptr = Box::into_raw(shared);  ",
                "   assert!(0 == (shared_ptr as usize & KIND_MASK));  ",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 1];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = NonNull::from(&buffer).as_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = 1;  ",
                " ",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);  ",
                "   }  ",
                "   let mut buffer: Vec<u8> = vec![0u8; 1];  ",
                "   let buf_ptr = buffer.as_mut_ptr();  ",
                "   let atom_ptr: *mut () = NonNull::from(&buffer).as_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 1;",
                "    let shared = Box::new(Shared {",
                "    buf: buf_ptr,",
                "    cap: offset_from(offset, buf_ptr) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert_eq!(0, shared_ptr as usize & KIND_MASK);",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 1];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = NonNull::from(buffer.as_mut_slice()).cast::<()>().as_ptr();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 1;",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);",
                "    }",
                "    let mut buffer: Vec<u8> = vec![0u8; 1];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = NonNull::from(buffer.as_mut_slice()).cast::<()>().as_ptr();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 1;",
                "    let shared = Box::new(Shared {",
                "    buf: buf_ptr,",
                "    cap: offset_from(offset, buf_ptr) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared_ptr = Box::into_raw(shared);",
                "   let result = unsafe { shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len) };",
                "   assert_eq!(result.data.load(Ordering::Relaxed), shared_ptr as _);",
                "}"
            ],
            [
                1493,
                1494,
                1495,
                1496,
                1497,
                1498,
                1499,
                1500,
                1501,
                1502,
                1503,
                1504,
                1505,
                1506,
                1507,
                1508,
                1509,
                1510,
                1511,
                1512,
                1513,
                1514,
                1515,
                1516,
                1517,
                1518,
                1519,
                1520,
                1521,
                1522,
                1523,
                1524,
                1525,
                1538,
                1539,
                1540,
                1543,
                1544,
                1545,
                1546,
                1547,
                1548,
                1562
            ]
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr();",
                "   let atom = AtomicPtr::new(atom_ptr.cast::<()>()); // Cast to AtomicPtr<()> for compatibility",
                "   let offset: *const u8 = buf_ptr;",
                "   let len: usize = max_len;",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, atom_ptr.cast::<()>(), buf_ptr, offset, len); // Cast to *const () for compatibility",
                "   }",
                "   let max_len: usize = usize::MAX - 1;",
                "   let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr();",
                "    let atom = AtomicPtr::new(atom_ptr);",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert!(max_len > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = max_len;  ",
                " ",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);  ",
                "   }  ",
                "   let max_len: usize = usize::MAX - 1;  ",
                "   let mut buffer: Vec<u8> = vec![0u8; max_len];  ",
                "   let buf_ptr = buffer.as_mut_ptr();  ",
                "  let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert!(!buffer.is_empty());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr() as *mut Vec<u8>;  ",
                " let atom: AtomicPtr<()> = AtomicPtr::new(atom_ptr.cast());  ",
                " let offset: *const u8 = buf_ptr;  ",
                " let len: usize = max_len;  ",
                "",
                "  unsafe {",
                "      shallow_clone_vec(&atom, atom_ptr as *const (), buf_ptr, offset, len);",
                "   }",
                "   let max_len: usize = usize::MAX - 1;",
                "  let mut buffer: Vec<u8> = vec![0u8; max_len];  ",
                "  let buf_ptr = buffer.as_mut_ptr();  ",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr() as *mut Vec<u8>;  ",
                "  let atom = AtomicPtr::new(atom_ptr);  ",
                "  let offset: *const u8 = buf_ptr;  ",
                "  let len: usize = max_len;  ",
                "  assert_eq!(atom_ptr as *const (), buffer.as_ptr() as *const ());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr(); // changed to mutable  ",
                "   let atom = AtomicPtr::new(atom_ptr as *mut ());  ",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = max_len;  ",
                "",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, atom_ptr as *mut (), buf_ptr, offset, len);  ",
                "  }  ",
                "  let max_len: usize = usize::MAX - 1;  ",
                "  let mut buffer: Vec<u8> = vec![0u8; max_len];  ",
                "  let buf_ptr = buffer.as_mut_ptr();  ",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr(); // changed to mutable  ",
                "   let atom = AtomicPtr::new(atom_ptr);",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert_eq!(buffer.len(), max_len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();",
                "  let atom = AtomicPtr::new(atom_ptr);",
                "   let offset: *const u8 = buf_ptr;",
                "   let len: usize = max_len;",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);",
                "   }",
                "   let max_len: usize = usize::MAX - 1;",
                "   let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert_eq!(offset, buf_ptr);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr();  // Changed to *mut Vec<u8>",
                " let atom = AtomicPtr::new(atom_ptr.cast());  // Cast to *mut ()  ",
                " let offset: *const u8 = buf_ptr;  ",
                " let len: usize = max_len;  ",
                " ",
                " unsafe {  ",
                "     shallow_clone_vec(&atom, atom_ptr.cast(), buf_ptr, offset, len);  // No additional cast needed for atom  ",
                "  }",
                "  let max_len: usize = usize::MAX - 1;",
                "  let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "  let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr();  // Changed to *mut Vec<u8>",
                "   let atom = AtomicPtr::new(atom_ptr);  // No cast needed",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert!(len <= max_len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 10];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = NonNull::from(&buffer).as_ptr() as *mut ();",
                "  let atom = AtomicPtr::new(atom_ptr);",
                "  let offset: *const u8 = buf_ptr;",
                "  let len: usize = 5;",
                "  ",
                "  unsafe {",
                "      // Simulating concurrent modifications by modifying the atom's pointer",
                "      atom.store(NonNull::dangling().as_ptr() as *mut (), Ordering::Relaxed);",
                "      shallow_clone_vec(&atom, atom_ptr.cast(), buf_ptr, offset, len);",
                "   }",
                "   let mut buffer: Vec<u8> = vec![0u8; 10];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr();",
                "   let atom = AtomicPtr::new(atom_ptr);",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 5;",
                "    let shared = Box::new(Shared {",
                "    buf: buf_ptr,",
                "    cap: offset_from(offset, buf_ptr) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "   debug_assert!(0 == (shared as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "   let result = atom.compare_exchange(atom.as_ptr() as _, shared as _, Ordering::AcqRel, Ordering::Acquire);",
                "   let actual = result.unwrap_err();",
                "   assert!(actual as usize == atom_ptr as usize);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "    let shared = Box::new(Shared {",
                "    buf,",
                "    cap: offset_from(offset, buf) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert!(shared as usize & KIND_MASK == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "    let shared = Box::new(Shared {",
                "    buf,",
                "    cap: offset_from(offset, buf) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "    let shared = Box::new(Shared {",
                "    buf,",
                "    cap: offset_from(offset, buf) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert_eq!(atom.load(Ordering::Acquire), buf as _);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast(), buf, offset, len);",
                "   }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert_eq!(0, (shared_ptr as usize & KIND_MASK));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "    let len: usize = 8; // length of 8",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf as *const (), buf, offset, len);",
                "   }",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) };",
                "   let len: usize = 8;",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "   let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "   let shared_ptr = Box::into_raw(shared);",
                "   assert!(atom.compare_exchange(buf as *const () as _, shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast(), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(atom.load(Ordering::Acquire) as usize == buf as usize);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "    let len: usize = 8; // length of 8",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(offset as usize == buf as usize + 3);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "   ",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast::<()>(), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(len == 8);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast::<()>(), buf, offset, len);",
                "   }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(!atom.load(Ordering::Acquire).is_null());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "    let len: usize = 15; // length of 15",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) };",
                "    let len: usize = 15;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) }));",
                "   let shared_ptr: usize = shared as usize;",
                "   assert!(0 == (shared_ptr & KIND_MASK));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "    let len: usize = 15; // length of 15",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) };",
                "    let len: usize = 15;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) }));  ",
                "   let shared_ptr: usize = shared as usize;  ",
                "   assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "   let len: usize = 15; // length of 15  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());  ",
                " ",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);  ",
                "   }  ",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(10) };  ",
                "   let len: usize = 15;  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());  ",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) })) as *mut Shared;  ",
                "   let shared_ptr: usize = shared as usize;  ",
                "   assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "    let len: usize = 15; // length of 15",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) };",
                "    let len: usize = 15;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) }));  ",
                "   let shared_ptr: usize = shared as usize;  ",
                "   let actual: *mut () = atom.load(Ordering::Acquire);  ",
                "   assert!(actual as usize != buf as usize);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
                "    let len: usize = 12; // length of 12",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) };",
                "    let len: usize = 12;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
                "    assert!(result.ptr == offset);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
                "    let len: usize = 12; // length of 12",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) };",
                "    let len: usize = 12;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
                "    assert!(result.len == len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
                "    let len: usize = 12; // length of 12",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) };",
                "    let len: usize = 12;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
                "    assert_eq!(atom.load(Ordering::Relaxed) as usize, shared_ptr as usize);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
                "   let len: usize = 25; // length of 25",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
                "",
                "   unsafe {",
                "       let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);",
                "   }",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(20) };",
                "   let len: usize = 25;",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
                "   let shared: *const u8 = unsafe { buf.add(15) }; // Define shared pointer correctly",
                "   let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
                "   let len: usize = 25; // length of 25  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                " ",
                "   unsafe {  ",
                "       let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);  ",
                "   }  ",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(20) };  ",
                "   let len: usize = 25;  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                "   let shared: *mut u8 = Box::into_raw(Box::new([0u8; 25])) as *mut u8;  ",
                "   let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };  ",
                "  let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(offset as _, shared as _, Ordering::AcqRel, Ordering::Acquire);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20  ",
                "   let len: usize = 25; // length of 25  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                " ",
                "   unsafe {  ",
                "       let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);  ",
                "   }  ",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(20) };  ",
                "   let len: usize = 25;  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                "   let shared: *const () = atom.load(Ordering::Acquire);  ",
                "   let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };  ",
                "  let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(shared as _, shared as _, Ordering::AcqRel, Ordering::Acquire);  ",
                "   let actual_ptr: *mut () = compare_exchange_result.unwrap();  ",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   assert!(atom.compare_exchange(std::ptr::null_mut(), buf as _, Ordering::AcqRel, Ordering::Acquire).is_err());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   ",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "   ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "    assert!(result.ptr == offset);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   assert!(result.len == len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf.cast::<u8>(), offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf.cast::<u8>(), offset, len) };",
                "    assert!(result.data.load(Ordering::Relaxed) != std::ptr::null_mut());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let atom = AtomicPtr::new(std::ptr::null_mut());",
                "    let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "",
                "   // Simulate other thread having already promoted",
                "   atom.store(buf as *mut _, Ordering::Release);",
                "   ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let offset = buf as *const u8;",
                "   let len = 5;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "  let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                "  let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer  ",
                "  let offset = buf as *const u8;  ",
                "  let len = 10; // Set to valid length  ",
                "  ",
                "  let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };  ",
                "   let buf = Box::into_raw(Box::new([0u8; 10]));",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let offset = buf as *const u8;",
                "  let len = 10; // Set to valid length  ",
                "  let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };  ",
                "  assert!(!result.ptr.is_null());  // Update assertion as result should not be null",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // cast to *mut u8",
                "   let offset = buf as *const u8;",
                "   let len = 0; // Not valid",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf, offset, len) };",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // cast to *mut u8",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let offset = buf as *const u8;",
                "   let len = 0;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf, offset, len) };",
                "   assert_eq!(result.len, 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // valid non-null pointer",
                "    let offset = buf as *const u8;",
                "    let len = 0; // Not valid",
                "",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "   let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());",
                "   let offset = buf as *const u8;",
                "   let len = 0;",
                "   let result = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };",
                "    assert!(result.data.load(Ordering::Relaxed).is_null());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "  let atom: std::sync::atomic::AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "  let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // changed to *mut u8",
                "  let offset = buf as *const u8;",
                "  let len = usize::MAX; // Edge case",
                "",
                "  let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf, offset, len) };",
                "  let atom: std::sync::atomic::AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "  let buf = Box::into_raw(Box::new([0u8; 10])) as *mut u8; // changed to *mut u8",
                "  let offset = buf as *const u8;",
                "  let len = usize::MAX; // Edge case",
                "  let shared = Box::new(Shared {",
                "  buf,",
                "  cap: offset_from(offset, buf) + len,",
                "  ref_cnt: AtomicUsize::new(2),",
                "  });",
                "  let shared_ptr = Box::into_raw(shared);",
                "  assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer  ",
                "   let offset = buf as *const u8;  ",
                "   let len = usize::MAX; // Edge case  ",
                " ",
                "   let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf as *mut u8, offset, len) };  ",
                "   let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                "   let buf = Box::into_raw(Box::new([0u8; 10])); // valid non-null pointer  ",
                "   let offset = buf as *const u8;  ",
                "   let len = usize::MAX; // Edge case  ",
                "   let shared = Box::new(Shared {  ",
                "   buf: buf as *mut u8,  ",
                "   cap: offset_from(offset, buf as *const u8) + len,  ",
                "   ref_cnt: AtomicUsize::new(2),  ",
                "   });  ",
                "   let shared_ptr = Box::into_raw(shared);  ",
                "   assert!(atom.compare_exchange(std::ptr::null_mut(), shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_err());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                " let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                " let buf = Box::into_raw(Box::new(vec![0u8; 1_000_000])); // valid non-null pointer  ",
                " let offset = buf as *const u8;  ",
                " let len = 100_000;  ",
                "",
                " let _ = unsafe { shallow_clone_vec(&atom, atom.load(Ordering::Relaxed), buf.cast::<u8>(), offset, len) };  ",
                " let atom = AtomicPtr::new(std::ptr::null_mut());  ",
                " let buf = Box::into_raw(Box::new(vec![0u8; 1_000_000])); // valid non-null pointer  ",
                " let offset = buf as *const u8;  ",
                " let len = 100_000;  ",
                " let shared_ptr = Box::into_raw(Box::new(Shared { buf: buf.cast::<u8>(), cap: offset_from(offset, buf as *const u8) + len, ref_cnt: AtomicUsize::new(2) }));  ",
                " debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");  ",
                " assert!(atom.compare_exchange(std::ptr::null_mut(), shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_err());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 10];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = NonNull::from(&mut buffer).cast::<()>().as_ptr();",
                "  let atom = AtomicPtr::new(atom_ptr);",
                "   let offset: *const u8 = buf_ptr;",
                "   let len: usize = 5;",
                "   ",
                "   unsafe {",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);",
                "   }",
                "   let mut buffer: Vec<u8> = vec![0u8; 10];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = NonNull::from(&mut buffer).cast::<()>().as_ptr();",
                "  let atom = AtomicPtr::new(atom_ptr.cast::<u8>());",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = 5;  ",
                "   let shared = Box::new(Shared { buf: buf_ptr, cap: offset_from(offset, buf_ptr) + len, ref_cnt: AtomicUsize::new(2) });  ",
                "   let shared_ptr = Box::into_raw(shared);  ",
                "   assert!(0 == (shared_ptr as usize & KIND_MASK));  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 1];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = NonNull::from(&buffer).as_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = 1;  ",
                " ",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);  ",
                "   }  ",
                "   let mut buffer: Vec<u8> = vec![0u8; 1];  ",
                "   let buf_ptr = buffer.as_mut_ptr();  ",
                "   let atom_ptr: *mut () = NonNull::from(&buffer).as_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 1;",
                "    let shared = Box::new(Shared {",
                "    buf: buf_ptr,",
                "    cap: offset_from(offset, buf_ptr) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert_eq!(0, shared_ptr as usize & KIND_MASK);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 1];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = NonNull::from(buffer.as_mut_slice()).cast::<()>().as_ptr();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 1;",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);",
                "    }",
                "    let mut buffer: Vec<u8> = vec![0u8; 1];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = NonNull::from(buffer.as_mut_slice()).cast::<()>().as_ptr();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 1;",
                "    let shared = Box::new(Shared {",
                "    buf: buf_ptr,",
                "    cap: offset_from(offset, buf_ptr) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared_ptr = Box::into_raw(shared);",
                "   let result = unsafe { shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len) };",
                "   assert_eq!(result.data.load(Ordering::Relaxed), shared_ptr as _);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr();",
                "   let atom = AtomicPtr::new(atom_ptr.cast::<()>()); // Cast to AtomicPtr<()> for compatibility",
                "   let offset: *const u8 = buf_ptr;",
                "   let len: usize = max_len;",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, atom_ptr.cast::<()>(), buf_ptr, offset, len); // Cast to *const () for compatibility",
                "   }",
                "   let max_len: usize = usize::MAX - 1;",
                "   let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr();",
                "    let atom = AtomicPtr::new(atom_ptr);",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert!(max_len > 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = max_len;  ",
                " ",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);  ",
                "   }  ",
                "   let max_len: usize = usize::MAX - 1;  ",
                "   let mut buffer: Vec<u8> = vec![0u8; max_len];  ",
                "   let buf_ptr = buffer.as_mut_ptr();  ",
                "  let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();  ",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert!(!buffer.is_empty());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr() as *mut Vec<u8>;  ",
                " let atom: AtomicPtr<()> = AtomicPtr::new(atom_ptr.cast());  ",
                " let offset: *const u8 = buf_ptr;  ",
                " let len: usize = max_len;  ",
                "",
                "  unsafe {",
                "      shallow_clone_vec(&atom, atom_ptr as *const (), buf_ptr, offset, len);",
                "   }",
                "   let max_len: usize = usize::MAX - 1;",
                "  let mut buffer: Vec<u8> = vec![0u8; max_len];  ",
                "  let buf_ptr = buffer.as_mut_ptr();  ",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr() as *mut Vec<u8>;  ",
                "  let atom = AtomicPtr::new(atom_ptr);  ",
                "  let offset: *const u8 = buf_ptr;  ",
                "  let len: usize = max_len;  ",
                "  assert_eq!(atom_ptr as *const (), buffer.as_ptr() as *const ());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr(); // changed to mutable  ",
                "   let atom = AtomicPtr::new(atom_ptr as *mut ());  ",
                "   let offset: *const u8 = buf_ptr;  ",
                "   let len: usize = max_len;  ",
                "",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, atom_ptr as *mut (), buf_ptr, offset, len);  ",
                "  }  ",
                "  let max_len: usize = usize::MAX - 1;  ",
                "  let mut buffer: Vec<u8> = vec![0u8; max_len];  ",
                "  let buf_ptr = buffer.as_mut_ptr();  ",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr(); // changed to mutable  ",
                "   let atom = AtomicPtr::new(atom_ptr);",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert_eq!(buffer.len(), max_len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();",
                "  let atom = AtomicPtr::new(atom_ptr);",
                "   let offset: *const u8 = buf_ptr;",
                "   let len: usize = max_len;",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, atom_ptr, buf_ptr, offset, len);",
                "   }",
                "   let max_len: usize = usize::MAX - 1;",
                "   let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = buffer.as_mut_ptr() as *mut ();",
                "   let atom = AtomicPtr::new(atom_ptr);  ",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert_eq!(offset, buf_ptr);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "",
                "    let max_len: usize = usize::MAX - 1; // to stay within valid range",
                "    let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr();  // Changed to *mut Vec<u8>",
                " let atom = AtomicPtr::new(atom_ptr.cast());  // Cast to *mut ()  ",
                " let offset: *const u8 = buf_ptr;  ",
                " let len: usize = max_len;  ",
                " ",
                " unsafe {  ",
                "     shallow_clone_vec(&atom, atom_ptr.cast(), buf_ptr, offset, len);  // No additional cast needed for atom  ",
                "  }",
                "  let max_len: usize = usize::MAX - 1;",
                "  let mut buffer: Vec<u8> = vec![0u8; max_len];",
                "  let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut Vec<u8> = NonNull::from(&mut buffer).as_ptr();  // Changed to *mut Vec<u8>",
                "   let atom = AtomicPtr::new(atom_ptr);  // No cast needed",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = max_len;",
                "    assert!(len <= max_len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    ",
                "    let mut buffer: Vec<u8> = vec![0u8; 10];",
                "    let buf_ptr = buffer.as_mut_ptr();",
                "  let atom_ptr: *mut () = NonNull::from(&buffer).as_ptr() as *mut ();",
                "  let atom = AtomicPtr::new(atom_ptr);",
                "  let offset: *const u8 = buf_ptr;",
                "  let len: usize = 5;",
                "  ",
                "  unsafe {",
                "      // Simulating concurrent modifications by modifying the atom's pointer",
                "      atom.store(NonNull::dangling().as_ptr() as *mut (), Ordering::Relaxed);",
                "      shallow_clone_vec(&atom, atom_ptr.cast(), buf_ptr, offset, len);",
                "   }",
                "   let mut buffer: Vec<u8> = vec![0u8; 10];",
                "   let buf_ptr = buffer.as_mut_ptr();",
                "   let atom_ptr: *mut Vec<u8> = NonNull::from(&buffer).as_ptr();",
                "   let atom = AtomicPtr::new(atom_ptr);",
                "    let offset: *const u8 = buf_ptr;",
                "    let len: usize = 5;",
                "    let shared = Box::new(Shared {",
                "    buf: buf_ptr,",
                "    cap: offset_from(offset, buf_ptr) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "   debug_assert!(0 == (shared as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "   let result = atom.compare_exchange(atom.as_ptr() as _, shared as _, Ordering::AcqRel, Ordering::Acquire);",
                "   let actual = result.unwrap_err();",
                "   assert!(actual as usize == atom_ptr as usize);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "    let shared = Box::new(Shared {",
                "    buf,",
                "    cap: offset_from(offset, buf) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert!(shared as usize & KIND_MASK == 0);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "    let shared = Box::new(Shared {",
                "    buf,",
                "    cap: offset_from(offset, buf) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
                "    let len: usize = 5; // length of 5",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
                "    let shared = Box::new(Shared {",
                "    buf,",
                "    cap: offset_from(offset, buf) + len,",
                "    ref_cnt: AtomicUsize::new(2),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert_eq!(atom.load(Ordering::Acquire), buf as _);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast(), buf, offset, len);",
                "   }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert_eq!(0, (shared_ptr as usize & KIND_MASK));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "    let len: usize = 8; // length of 8",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf as *const (), buf, offset, len);",
                "   }",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) };",
                "   let len: usize = 8;",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "   let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "   let shared_ptr = Box::into_raw(shared);",
                "   assert!(atom.compare_exchange(buf as *const () as _, shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast(), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(atom.load(Ordering::Acquire) as usize == buf as usize);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "    let len: usize = 8; // length of 8",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(offset as usize == buf as usize + 3);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "   ",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast::<()>(), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(len == 8);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
                "   let len: usize = 8; // length of 8",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "",
                "   unsafe {",
                "       shallow_clone_vec(&atom, buf.cast::<()>(), buf, offset, len);",
                "   }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(3) };",
                "    let len: usize = 8;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    assert!(!atom.load(Ordering::Acquire).is_null());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "    let len: usize = 15; // length of 15",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) };",
                "    let len: usize = 15;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) }));",
                "   let shared_ptr: usize = shared as usize;",
                "   assert!(0 == (shared_ptr & KIND_MASK));",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "    let len: usize = 15; // length of 15",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) };",
                "    let len: usize = 15;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) }));  ",
                "   let shared_ptr: usize = shared as usize;  ",
                "   assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "   let len: usize = 15; // length of 15  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());  ",
                " ",
                "   unsafe {  ",
                "       shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);  ",
                "   }  ",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(10) };  ",
                "   let len: usize = 15;  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());  ",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) })) as *mut Shared;  ",
                "   let shared_ptr: usize = shared as usize;  ",
                "   assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
                "    let len: usize = 15; // length of 15",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(10) };",
                "    let len: usize = 15;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
                "   let shared: *mut Shared = Box::into_raw(Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) }));  ",
                "   let shared_ptr: usize = shared as usize;  ",
                "   let actual: *mut () = atom.load(Ordering::Acquire);  ",
                "   assert!(actual as usize != buf as usize);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
                "    let len: usize = 12; // length of 12",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) };",
                "    let len: usize = 12;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
                "    assert!(result.ptr == offset);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
                "    let len: usize = 12; // length of 12",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) };",
                "    let len: usize = 12;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
                "    assert!(result.len == len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
                "    let len: usize = 12; // length of 12",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "",
                "    unsafe {",
                "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
                "    }",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(5) };",
                "    let len: usize = 12;",
                "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
                "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
                "    let shared_ptr = Box::into_raw(shared);",
                "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
                "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
                "    assert_eq!(atom.load(Ordering::Relaxed) as usize, shared_ptr as usize);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
                "   let len: usize = 25; // length of 25",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
                "",
                "   unsafe {",
                "       let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);",
                "   }",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
                "   let offset: *const u8 = unsafe { buf.add(20) };",
                "   let len: usize = 25;",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
                "   let shared: *const u8 = unsafe { buf.add(15) }; // Define shared pointer correctly",
                "   let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
                "    let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
                "   let len: usize = 25; // length of 25  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                " ",
                "   unsafe {  ",
                "       let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);  ",
                "   }  ",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(20) };  ",
                "   let len: usize = 25;  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                "   let shared: *mut u8 = Box::into_raw(Box::new([0u8; 25])) as *mut u8;  ",
                "   let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };  ",
                "  let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(offset as _, shared as _, Ordering::AcqRel, Ordering::Acquire);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20  ",
                "   let len: usize = 25; // length of 25  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                " ",
                "   unsafe {  ",
                "       let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);  ",
                "   }  ",
                "   let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;  ",
                "   let offset: *const u8 = unsafe { buf.add(20) };  ",
                "   let len: usize = 25;  ",
                "   let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());  ",
                "   let shared: *const () = atom.load(Ordering::Acquire);  ",
                "   let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };  ",
                "  let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(shared as _, shared as _, Ordering::AcqRel, Ordering::Acquire);  ",
                "   let actual_ptr: *mut () = compare_exchange_result.unwrap();  ",
                "}"
            ],
            []
        ]
    ]
}