{
    "function_name": "bytes::bytes::promotable_odd_clone",
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/bytes",
    "tests": 55,
    "tests_lines": [
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        19,
        18,
        19,
        19,
        19,
        19,
        19,
        21,
        21,
        20,
        21,
        28,
        28,
        28,
        28,
        28,
        28,
        28,
        27,
        33,
        32,
        32,
        32,
        30,
        30,
        30,
        30,
        22,
        22,
        28,
        29,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        13,
        10,
        12,
        15,
        15,
        15,
        15,
        15,
        15,
        15
    ],
    "oracles": 14,
    "oracles_compiled": 13,
    "oracles_compiled_rate": 92.85714285714286,
    "tests_compiled": 42,
    "tests_compiled_rate": 76.36363636363637,
    "oracles_run": 13,
    "oracles_passed": 7,
    "oracles_passed_rate": 53.84615384615385,
    "tests_run": 42,
    "tests_passed": 16,
    "tests_passed_rate": 38.095238095238095,
    "lines": 9,
    "lines_covered": 7,
    "lines_coveraged_rate": 77.77777777777779,
    "branches": 2,
    "branches_covered": 1,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        1303,
        1304,
        1305,
        1306,
        1307,
        1308,
        1310,
        1311,
        1313
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "    assert_eq!(result.len, len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.data.load(Ordering::SeqCst) as usize & KIND_MASK, KIND_ARC);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr;",
                "    use std::sync::Arc;",
                "    ",
                "    let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "    let buffer = Arc::new(vec![0u8; 10]);",
                "    let len = 5;",
                "    let ptr = buffer.as_ptr();",
                "",
                "   {  ",
                "       let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   }  ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 10]);  ",
                "   let len = 5;  ",
                "   let ptr = buffer.as_ptr();  ",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "    assert!(result.data.load(Ordering::SeqCst) != ptr::null_mut());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "   let len = usize::MAX / 2;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "   let len = usize::MAX / 2;",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.len, len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "   let len = usize::MAX / 2;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "       let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "       let len = usize::MAX / 2;",
                "       let ptr = buffer.as_ptr();",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.ptr, ptr);",
                "   }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr;",
                "    use std::sync::Arc;",
                "",
                "    let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "    let buffer = Arc::new(vec![0u8; 20]);",
                "    let len = 10;",
                "    let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 20]);",
                "   let len = 10;",
                "   let ptr = buffer.as_ptr();",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;  ",
                "   use std::sync::Arc;  ",
                " ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 20]);  ",
                "   let len = 10;  ",
                "   let ptr = buffer.as_ptr();  ",
                " ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 20]);  ",
                "   let len = 10;  ",
                "   let ptr = buffer.as_ptr();  ",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   assert!(!result.data.load(Ordering::Relaxed).is_null());  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use core::ptr;",
                "    use std::sync::Arc;",
                "",
                "    let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "    let buffer = Arc::new(vec![0u8; 20]);",
                "    let len = 10;",
                "    let ptr = buffer.as_ptr();",
                "",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 20]);  ",
                "   let len = 10;  ",
                "   let ptr = buffer.as_ptr();  ",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   assert_eq!(Arc::strong_count(&data), 1);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.len, len);",
                "   }",
                "}"
            ],
            []
        ],
        [
            [
                "{  ",
                "   use core::ptr;  ",
                "   use std::sync::Arc;  ",
                " ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 1]);  ",
                "   let len = 1; // Minimum valid length  ",
                "   let ptr = buffer.as_ptr();  ",
                " ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 1]);  ",
                "   let len = 1; // Minimum valid length  ",
                "   let ptr = buffer.as_ptr();  ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "       assert_eq!(result.ptr, ptr);  ",
                "   }  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert!(result.data.load(Ordering::Relaxed) != ptr::null_mut());",
                "}",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf = vec![1u8, 2, 3, 4];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![1u8, 2, 3, 4];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1), });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    unsafe {",
                "   let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.len, len);",
                "   }",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1) });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.len, len);",
                "   }",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1) });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.ptr, ptr);",
                "   }",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![5u8, 6, 7, 8];  ",
                "   let len = buf.len();  ",
                "   let ptr = buf.as_ptr();  ",
                "   ",
                "   let shared = Box::new(Shared {  ",
                "       buf: buf.as_ptr() as *mut u8,  ",
                "       cap: len,  ",
                "       ref_cnt: AtomicUsize::new(1),  ",
                "   });  ",
                "   let shared = Box::into_raw(shared);  ",
                "   ",
                "   let data = AtomicPtr::new(shared as _);  ",
                "   ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let buf = vec![5u8, 6, 7, 8];  ",
                "   let len = buf.len();  ",
                "   let ptr = buf.as_ptr();  ",
                "   let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1) });  ",
                "   let shared = Box::into_raw(shared);  ",
                "   let data = AtomicPtr::new(shared as _);  ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "       assert!(!result.data.load(Ordering::Acquire).is_null());  ",
                "   }  ",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   assert_eq!(result.ptr, ptr);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    unsafe {",
                "   let result = promotable_odd_clone(&data, ptr, len);  ",
                "   assert_eq!(result.len, len);  ",
                "   }  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    unsafe {",
                "   let result = promotable_odd_clone(&data, ptr, len);",
                "   assert!(result.data.load(Ordering::Relaxed).is_null() == false);",
                "   }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let _result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared {",
                "   buf: buf.as_ptr() as *mut u8,",
                "   cap: len,",
                "   ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.len, len);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   let result; // Declare the variable ",
                "   unsafe { result = promotable_odd_clone(&data, ptr, len); } // Wrap in unsafe block",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![10u8];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![10u8];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.data.load(Ordering::Relaxed) as usize & KIND_MASK, KIND_VEC);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    assert_eq!(len, 0);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    assert_eq!(ptr, buf.as_ptr());",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert!(!shared.is_null());",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    assert_eq!(data.load(Ordering::Acquire), shared as _);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
                "    assert_eq!(kind, KIND_VEC);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
                "    assert!(data.load(Ordering::Acquire) != ptr as *mut ());",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
                "    assert!(len == 1);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert_eq!(kind, KIND_VEC);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert!(!ptr.is_null());",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert!(len != 0);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK != KIND_ARC);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert_eq!(ptr as usize, 10u8 as usize);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "    let len = 42;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "    let len = 42;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "    let len = 42;",
                "   assert!(!ptr.is_null());",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());  ",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;  ",
                "   let len = 42;  ",
                "   unsafe {  ",
                "       let _result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());  ",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;  ",
                "   let len = 42;  ",
                "   unsafe {  ",
                "   let _result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   assert!(!data.load(Ordering::Acquire).is_null());  ",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "   let len = 42;",
                "   unsafe {",
                "       let _result = promotable_odd_clone(&data, ptr, len);",
                "       assert!(_result.ptr != ptr); // Moved the assertion here",
                "   }",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "   let len = 42;",
                "   unsafe {",
                "       let _result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert_eq!(kind, KIND_VEC);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert!(!ptr::eq(ptr1, ptr2));",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert_eq!(len1, 1);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert_eq!(len2, 2);",
                "}"
            ],
            [
                1303,
                1304,
                1305,
                1306,
                1307,
                1308,
                1313
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1307,
            "start_column": 8,
            "end_line": 1307,
            "end_column": 24,
            "positive": true,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "    assert_eq!(result.len, len);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.data.load(Ordering::SeqCst) as usize & KIND_MASK, KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use core::ptr;",
                "    use std::sync::Arc;",
                "    ",
                "    let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "    let buffer = Arc::new(vec![0u8; 10]);",
                "    let len = 5;",
                "    let ptr = buffer.as_ptr();",
                "",
                "   {  ",
                "       let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   }  ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 10]);  ",
                "   let len = 5;  ",
                "   let ptr = buffer.as_ptr();  ",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   assert!(result.vtable as *const _ == &SHARED_VTABLE as *const _);  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 10]);",
                "   let len = 5;",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "    assert!(result.data.load(Ordering::SeqCst) != ptr::null_mut());",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "   let len = usize::MAX / 2;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "   let len = usize::MAX / 2;",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.len, len);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "   ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "   let len = usize::MAX / 2;",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "       let buffer = Arc::new(vec![0u8; usize::MAX / 2]);",
                "       let len = usize::MAX / 2;",
                "       let ptr = buffer.as_ptr();",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.ptr, ptr);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use core::ptr;",
                "    use std::sync::Arc;",
                "",
                "    let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "    let buffer = Arc::new(vec![0u8; 20]);",
                "    let len = 10;",
                "    let ptr = buffer.as_ptr();",
                "",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 20]);",
                "   let len = 10;",
                "   let ptr = buffer.as_ptr();",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;  ",
                "   use std::sync::Arc;  ",
                " ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 20]);  ",
                "   let len = 10;  ",
                "   let ptr = buffer.as_ptr();  ",
                " ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 20]);  ",
                "   let len = 10;  ",
                "   let ptr = buffer.as_ptr();  ",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   assert!(!result.data.load(Ordering::Relaxed).is_null());  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use core::ptr;",
                "    use std::sync::Arc;",
                "",
                "    let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "    let buffer = Arc::new(vec![0u8; 20]);",
                "    let len = 10;",
                "    let ptr = buffer.as_ptr();",
                "",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 20]);  ",
                "   let len = 10;  ",
                "   let ptr = buffer.as_ptr();  ",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };  ",
                "   assert_eq!(Arc::strong_count(&data), 1);  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.len, len);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{  ",
                "   use core::ptr;  ",
                "   use std::sync::Arc;  ",
                " ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 1]);  ",
                "   let len = 1; // Minimum valid length  ",
                "   let ptr = buffer.as_ptr();  ",
                " ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));  ",
                "   let buffer = Arc::new(vec![0u8; 1]);  ",
                "   let len = 1; // Minimum valid length  ",
                "   let ptr = buffer.as_ptr();  ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "       assert_eq!(result.ptr, ptr);  ",
                "   }  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   use core::ptr;",
                "   use std::sync::Arc;",
                "",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let data = Arc::new(AtomicPtr::new(ptr::null_mut()));",
                "   let buffer = Arc::new(vec![0u8; 1]);",
                "   let len = 1; // Minimum valid length",
                "   let ptr = buffer.as_ptr();",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert!(result.data.load(Ordering::Relaxed) != ptr::null_mut());",
                "}",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![1u8, 2, 3, 4];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![1u8, 2, 3, 4];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1), });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    unsafe {",
                "   let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.len, len);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1) });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.len, len);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![5u8, 6, 7, 8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1) });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "       assert_eq!(result.ptr, ptr);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![5u8, 6, 7, 8];  ",
                "   let len = buf.len();  ",
                "   let ptr = buf.as_ptr();  ",
                "   ",
                "   let shared = Box::new(Shared {  ",
                "       buf: buf.as_ptr() as *mut u8,  ",
                "       cap: len,  ",
                "       ref_cnt: AtomicUsize::new(1),  ",
                "   });  ",
                "   let shared = Box::into_raw(shared);  ",
                "   ",
                "   let data = AtomicPtr::new(shared as _);  ",
                "   ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let buf = vec![5u8, 6, 7, 8];  ",
                "   let len = buf.len();  ",
                "   let ptr = buf.as_ptr();  ",
                "   let shared = Box::new(Shared { buf: buf.as_ptr() as *mut u8, cap: len, ref_cnt: AtomicUsize::new(1) });  ",
                "   let shared = Box::into_raw(shared);  ",
                "   let data = AtomicPtr::new(shared as _);  ",
                "   unsafe {  ",
                "       let result = promotable_odd_clone(&data, ptr, len);  ",
                "       assert!(!result.data.load(Ordering::Acquire).is_null());  ",
                "   }  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "   let result;",
                "   unsafe {",
                "       result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   assert_eq!(result.ptr, ptr);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    unsafe {",
                "   let result = promotable_odd_clone(&data, ptr, len);  ",
                "   assert_eq!(result.len, len);  ",
                "   }  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![9u8; usize::MAX / 2];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    unsafe {",
                "   let result = promotable_odd_clone(&data, ptr, len);",
                "   assert!(result.data.load(Ordering::Relaxed).is_null() == false);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let _result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared {",
                "   buf: buf.as_ptr() as *mut u8,",
                "   cap: len,",
                "   ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.len, len);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   ",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   ",
                "   let data = AtomicPtr::new(shared as _);",
                "   ",
                "   unsafe {",
                "       let result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "   let buf = vec![10u8];",
                "   let len = buf.len();",
                "   let ptr = buf.as_ptr();",
                "   let shared = Box::new(Shared {",
                "       buf: buf.as_ptr() as *mut u8,",
                "       cap: len,",
                "       ref_cnt: AtomicUsize::new(1),",
                "   });",
                "   let shared = Box::into_raw(shared);",
                "   let data = AtomicPtr::new(shared as _);",
                "   let result; // Declare the variable ",
                "   unsafe { result = promotable_odd_clone(&data, ptr, len); } // Wrap in unsafe block",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf = vec![10u8];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf = vec![10u8];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "   let result = unsafe { promotable_odd_clone(&data, ptr, len) };",
                "   assert_eq!(result.data.load(Ordering::Relaxed) as usize & KIND_MASK, KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    assert_eq!(len, 0);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    assert_eq!(ptr, buf.as_ptr());",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    assert!(!shared.is_null());",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len(); // len is zero",
                "    let ptr = buf.as_ptr();",
                "    ",
                "    let shared = Box::new(Shared {",
                "        buf: buf.as_ptr() as *mut u8,",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    ",
                "    let data = AtomicPtr::new(shared as _);",
                "    ",
                "    unsafe {",
                "        let result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let buf: Vec<u8> = vec![];",
                "    let len = buf.len();",
                "    let ptr = buf.as_ptr();",
                "    let shared = Box::new(Shared {",
                "    buf: buf.as_ptr() as *mut u8,",
                "    cap: len,",
                "    ref_cnt: AtomicUsize::new(1),",
                "    });",
                "    let shared = Box::into_raw(shared);",
                "    let data = AtomicPtr::new(shared as _);",
                "    assert_eq!(data.load(Ordering::Acquire), shared as _);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
                "    assert_eq!(kind, KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
                "    assert!(data.load(Ordering::Acquire) != ptr as *mut ());",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(5u8)) as *const u8;",
                "    let len = 1;",
                "    let kind = data.load(Ordering::Acquire) as usize & KIND_MASK;",
                "    assert!(len == 1);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert_eq!(kind, KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert!(!ptr.is_null());",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert!(len != 0);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK != KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let ptr = Box::into_raw(Box::new(10u8)) as *const u8;",
                "    let len = usize::MAX - 1;",
                "    let shared = data.load(Ordering::Acquire);",
                "    let kind = shared as usize & KIND_MASK;",
                "    assert_eq!(ptr as usize, 10u8 as usize);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "    let len = 42;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    assert_eq!(data.load(Ordering::Acquire) as usize & KIND_MASK, KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "    let len = 42;",
                "    unsafe {",
                "        let _result = promotable_odd_clone(&data, ptr, len);",
                "    }",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "    let len = 42;",
                "   assert!(!ptr.is_null());",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());  ",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;  ",
                "   let len = 42;  ",
                "   unsafe {  ",
                "       let _result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());  ",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;  ",
                "   let len = 42;  ",
                "   unsafe {  ",
                "   let _result = promotable_odd_clone(&data, ptr, len);  ",
                "   }  ",
                "   assert!(!data.load(Ordering::Acquire).is_null());  ",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "   let len = 42;",
                "   unsafe {",
                "       let _result = promotable_odd_clone(&data, ptr, len);",
                "       assert!(_result.ptr != ptr); // Moved the assertion here",
                "   }",
                "   let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "   let ptr = Box::into_raw(Box::new(15u8)) as *const u8;",
                "   let len = 42;",
                "   unsafe {",
                "       let _result = promotable_odd_clone(&data, ptr, len);",
                "   }",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert_eq!(kind, KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert!(!ptr::eq(ptr1, ptr2));",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert_eq!(len1, 1);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let data = AtomicPtr::new(Box::into_raw(Box::new(0 as *const () as *mut ())) as *mut ());",
                "    let ptr1 = Box::into_raw(Box::new(20u8)) as *const u8;",
                "    let len1 = 1;",
                "    let ptr2 = Box::into_raw(Box::new(30u8)) as *const u8;",
                "    let len2 = 2;",
                "",
                "    unsafe {",
                "        let _result1 = promotable_odd_clone(&data, ptr1, len1);",
                "        let _result2 = promotable_odd_clone(&data, ptr2, len2);",
                "    }",
                "    let shared_value = data.load(Ordering::Acquire);",
                "    let kind = shared_value as usize & KIND_MASK;",
                "    assert_eq!(len2, 2);",
                "}"
            ],
            [
                {
                    "start_line": 1307,
                    "start_column": 8,
                    "end_line": 1307,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ]
}