{
    "function_name": "bytes::bytes_mut::shared_v_to_mut",
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs",
    "work_dir": "/home/abezbm/rust-utgen-test-crates-new/bytes",
    "tests": 41,
    "tests_lines": [
        23,
        24,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        23,
        24,
        24,
        24,
        24,
        23,
        24,
        23,
        23,
        21,
        21,
        21,
        21,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        25,
        26,
        25,
        25,
        25,
        25,
        25
    ],
    "oracles": 9,
    "oracles_compiled": 7,
    "oracles_compiled_rate": 77.77777777777779,
    "tests_compiled": 20,
    "tests_compiled_rate": 48.78048780487805,
    "oracles_run": 7,
    "oracles_passed": 5,
    "oracles_passed_rate": 71.42857142857143,
    "tests_run": 20,
    "tests_passed": 11,
    "tests_passed_rate": 55.00000000000001,
    "lines": 26,
    "lines_covered": 26,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1815,
        1816,
        1817,
        1818,
        1819,
        1820,
        1821,
        1822,
        1823,
        1824,
        1825,
        1826,
        1827,
        1828,
        1829,
        1830,
        1831,
        1832,
        1833,
        1834,
        1835,
        1836,
        1838,
        1839,
        1840,
        1842
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared {  ",
                "     vec: vec.clone(),  ",
                "     original_capacity_repr: 0,  ",
                "     ref_count: AtomicUsize::new(1),  ",
                " });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                " let len = 0;  ",
                "",
                " unsafe {  ",
                "     let result = shared_v_to_mut(&data, ptr, len);  ",
                " }  ",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                " let len = 0;  ",
                " let result = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                " assert_eq!(result.len(), len);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1819,
                1820,
                1821,
                1822,
                1823,
                1824,
                1825,
                1826,
                1827,
                1828,
                1829,
                1830,
                1831,
                1832,
                1833,
                1834,
                1835,
                1836,
                1842
            ]
        ],
        [
            [
                "{",
                "  let mut vec = vec![1, 2, 3, 4].clone();  ",
                "  let mut shared = Box::new(Shared {  ",
                "      vec: vec.clone(),  ",
                "      original_capacity_repr: 0,  ",
                "      ref_count: AtomicUsize::new(1),  ",
                "  });  ",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                "  let len = 0;  ",
                " ",
                "  let result;  ",
                "  unsafe {  ",
                "      result = shared_v_to_mut(&data, ptr, len);  ",
                "  }  ",
                "  let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });  ",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                "  let len = 0;  ",
                "  let result;  ",
                "  unsafe { result = shared_v_to_mut(&data, ptr, len); }  ",
                "   assert_eq!(result.cap, vec.len());",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1819,
                1820,
                1821,
                1822,
                1823,
                1824,
                1825,
                1826,
                1827,
                1828,
                1829,
                1830,
                1831,
                1832,
                1833,
                1834,
                1835,
                1836,
                1842
            ]
        ],
        [
            [
                "{",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared {  ",
                "     vec: vec.clone(),  ",
                "     original_capacity_repr: 0,  ",
                "     ref_count: AtomicUsize::new(1),  ",
                " });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                " let len = 0;  ",
                " ",
                " let result;  ",
                " unsafe {  ",
                "     result = shared_v_to_mut(&data, ptr, len);  ",
                " }  ",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "  let len = 0;",
                "    assert!(result.ptr.as_ptr() == ptr);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1819,
                1820,
                1821,
                1822,
                1823,
                1824,
                1825,
                1826,
                1827,
                1828,
                1829,
                1830,
                1831,
                1832,
                1833,
                1834,
                1835,
                1836,
                1842
            ]
        ],
        [
            [
                "{",
                "  let mut vec = vec![14; MAX_VEC_POS]; // using a valid length close to the max",
                "  let mut shared = Box::new(Shared {",
                "      vec: vec.clone(),",
                "      original_capacity_repr: 0,",
                "      ref_count: AtomicUsize::new(1),",
                "  });",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "  let len = MAX_VEC_POS;",
                "",
                " let result;",
                " unsafe {",
                "     result = shared_v_to_mut(&data, ptr, len);",
                " }",
                " let mut vec = vec![14; MAX_VEC_POS];",
                " let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1), });",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                " let len = MAX_VEC_POS;",
                "   assert_eq!(result.len(), len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "let mut vec = vec![14; MAX_VEC_POS]; // using a valid length close to the max  ",
                "let mut shared = Box::new(Shared {  ",
                "    vec: vec.clone(),  ",
                "    original_capacity_repr: 0,  ",
                "    ref_count: AtomicUsize::new(1),  ",
                "});  ",
                "let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "",
                "let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                "let len = MAX_VEC_POS;",
                "",
                "unsafe {",
                "    let result = shared_v_to_mut(&data, ptr, len);",
                "}",
                "let mut vec = vec![14; MAX_VEC_POS];",
                "let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1), });",
                "let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "let len = MAX_VEC_POS;",
                "let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "assert_eq!(result.cap, MAX_VEC_POS);",
                "    assert_eq!(result.cap, MAX_VEC_POS);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "  let mut vec = vec![14; MAX_VEC_POS]; // using a valid length close to the max  ",
                "  let mut shared = Box::new(Shared {  ",
                "       vec: vec.clone(), // Clone vec to keep ownership in the original variable",
                "       original_capacity_repr: 0,",
                "       ref_count: AtomicUsize::new(1),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "   let len = MAX_VEC_POS;",
                "",
                "   unsafe {",
                "       let result = shared_v_to_mut(&data, ptr, len);",
                "  }  ",
                " let mut vec2 = vec![14; MAX_VEC_POS];  // renamed to vec2 to avoid conflict  ",
                " let mut shared = Box::new(Shared { vec: vec2.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1), });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " let ptr = NonNull::new(vec2.as_mut_ptr()).unwrap().as_ptr(); // use vec2 here  ",
                " let len = MAX_VEC_POS;  ",
                " let result = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                " assert_eq!(unsafe { result.as_slice() }[0], 14);  ",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(2), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.len(), len);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(2), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.cap, vec.len() - len);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(2), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.as_slice(), &[1, 2, 3]);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![10, 20, 30, 40, 50, 60];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(3), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr: *const u8;  ",
                "  let len: usize = 4; // Length does not exceed the vector's length  ",
                "",
                "  unsafe { ptr = vec.as_ptr().add(2); } // Pointer to the third element  ",
                "   let bytes_mut = unsafe { std::slice::from_raw_parts_mut(ptr as *mut u8, len) }; // Define bytes_mut",
                "   let vec = vec![10, 20, 30, 40, 50, 60];",
                "   let shared = Box::new(Shared {",
                "   vec: vec.clone(),",
                "   original_capacity_repr: vec.capacity(),",
                "   ref_count: AtomicUsize::new(3),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "  let ptr: *const u8;  ",
                "  let len: usize = 4;  ",
                "   assert_eq!(bytes_mut.len(), len);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let vec = vec![10, 20, 30, 40, 50, 60];  ",
                "   let shared = Box::new(Shared {  ",
                "       vec: vec.clone(),  ",
                "       original_capacity_repr: vec.capacity(),  ",
                "       ref_count: AtomicUsize::new(3), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "  let ptr: *const u8;  ",
                "  let len: usize = 4; // Length does not exceed the vector's length  ",
                "  unsafe { ptr = vec.as_ptr().add(2); } // Pointer to the third element  ",
                " ",
                "   let vec = vec![10, 20, 30, 40, 50, 60];  ",
                "   let shared = Box::new(Shared {  ",
                "   vec: vec.clone(),  ",
                "   original_capacity_repr: vec.capacity(),  ",
                "   ref_count: AtomicUsize::new(3),  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "   let ptr: *const u8;  ",
                "   let len: usize = 4;  ",
                "   unsafe { ptr = vec.as_ptr().add(2); }  ",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![100, 200, 255];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(4), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   ",
                "   let ptr: *const u8 = vec.as_ptr();",
                "   let len: usize = 2; // Length is less than the vector's length",
                "   ",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   let vec = vec![100, 200, 255];",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(4),",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.len(), 2);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "   {",
                "       let vec = vec![100, 200, 255];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(4), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2; // Length is less than the vector's length",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   let vec = vec![100, 200, 255];  ",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(4),",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(unsafe { result.as_slice() }, &[100, 200]);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![100, 200, 255];  ",
                "   let shared = Box::new(Shared {  ",
                "       vec: vec.clone(),  ",
                "       original_capacity_repr: vec.capacity(),  ",
                "       ref_count: AtomicUsize::new(4), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "   let ptr: *const u8 = vec.as_ptr();  ",
                "   let len: usize = 2; // Length is less than the vector's length  ",
                " ",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "   let vec = vec![100, 200, 255];  ",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(4),",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.cap, 1);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![7, 14, 21, 28, 35];  ",
                "   let shared = Box::new(Shared {  ",
                "       vec: vec.clone(),  ",
                "       original_capacity_repr: vec.capacity(),  ",
                "       ref_count: AtomicUsize::new(5), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "  let ptr: *const u8;  ",
                "  let len: usize = 3; // Length does not exceed the vector's length  ",
                "  unsafe { ptr = vec.as_ptr().add(1); } // Pointer to the second element  ",
                "  let _ = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "   let vec = vec![7, 14, 21, 28, 35];  ",
                "   let shared = Box::new(Shared {  ",
                "   vec: vec.clone(),  ",
                "   original_capacity_repr: vec.capacity(),  ",
                "   ref_count: AtomicUsize::new(5), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "   let ptr: *const u8;  ",
                "   let len: usize = 3;  ",
                "  unsafe { ptr = vec.as_ptr().add(1); }  ",
                "   let result = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) }; // Pointer to the second element",
                "    let len: usize = 3; // Length does not exceed the vector's length",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) };",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(unsafe { *(result.ptr.as_ptr()) }, 14);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) }; // Pointer to the second element",
                "   let len: usize = 3; // Length does not exceed the vector's length",
                "   ",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) };",
                "   let len: usize = 3;",
                "   let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(unsafe { *(result.ptr.as_ptr().add(2)) }, 28);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(6), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr: *const u8;",
                "  let len: usize = 2; // Length does not exceed the vector's remaining size  ",
                "",
                "  unsafe { ptr = vec.as_ptr().add(4) }; // Pointer to the fifth element  ",
                "  let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];  ",
                "  let shared = Box::new(Shared {  ",
                "      vec: vec.clone(),  ",
                "      original_capacity_repr: vec.capacity(),  ",
                "      ref_count: AtomicUsize::new(6),  ",
                "  });  ",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "  let ptr: *const u8;  ",
                "  let len: usize = 2;  ",
                "  unsafe { ptr = vec.as_ptr().add(4) };  ",
                "   let bytes_mut = unsafe { std::slice::from_raw_parts_mut(ptr as *mut u8, len) };",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(6), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(4) }; // Pointer to the fifth element",
                "    let len: usize = 2; // Length does not exceed the vector's remaining size",
                "",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, unsafe { ptr }, len) };",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "   vec: vec.clone(),",
                "   original_capacity_repr: vec.capacity(),",
                "   ref_count: AtomicUsize::new(6),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(4) };",
                "   let len: usize = 2;",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(bytes_mut.cap, 4);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(6), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr: *const u8;",
                "  let len: usize = 2; // Length does not exceed the vector's remaining size",
                "  ptr = unsafe { vec.as_ptr().add(4) }; // Pointer to the fifth element",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "   vec: vec.clone(),",
                "   original_capacity_repr: vec.capacity(),",
                "   ref_count: AtomicUsize::new(6),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(4) };",
                "   let len: usize = 2;",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   assert_eq!(unsafe { bytes_mut.as_slice() }, &[4, 5]);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1818,
            "start_column": 8,
            "end_line": 1818,
            "end_column": 29,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared {  ",
                "     vec: vec.clone(),  ",
                "     original_capacity_repr: 0,  ",
                "     ref_count: AtomicUsize::new(1),  ",
                " });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                " let len = 0;  ",
                "",
                " unsafe {  ",
                "     let result = shared_v_to_mut(&data, ptr, len);  ",
                " }  ",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                " let len = 0;  ",
                " let result = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                " assert_eq!(result.len(), len);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "  let mut vec = vec![1, 2, 3, 4].clone();  ",
                "  let mut shared = Box::new(Shared {  ",
                "      vec: vec.clone(),  ",
                "      original_capacity_repr: 0,  ",
                "      ref_count: AtomicUsize::new(1),  ",
                "  });  ",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                "  let len = 0;  ",
                " ",
                "  let result;  ",
                "  unsafe {  ",
                "      result = shared_v_to_mut(&data, ptr, len);  ",
                "  }  ",
                "  let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });  ",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                "  let len = 0;  ",
                "  let result;  ",
                "  unsafe { result = shared_v_to_mut(&data, ptr, len); }  ",
                "   assert_eq!(result.cap, vec.len());",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared {  ",
                "     vec: vec.clone(),  ",
                "     original_capacity_repr: 0,  ",
                "     ref_count: AtomicUsize::new(1),  ",
                " });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                " let len = 0;  ",
                " ",
                " let result;  ",
                " unsafe {  ",
                "     result = shared_v_to_mut(&data, ptr, len);  ",
                " }  ",
                " let mut vec = vec![1, 2, 3, 4];  ",
                " let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1) });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "  let len = 0;",
                "    assert!(result.ptr.as_ptr() == ptr);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "  let mut vec = vec![14; MAX_VEC_POS]; // using a valid length close to the max",
                "  let mut shared = Box::new(Shared {",
                "      vec: vec.clone(),",
                "      original_capacity_repr: 0,",
                "      ref_count: AtomicUsize::new(1),",
                "  });",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "  let len = MAX_VEC_POS;",
                "",
                " let result;",
                " unsafe {",
                "     result = shared_v_to_mut(&data, ptr, len);",
                " }",
                " let mut vec = vec![14; MAX_VEC_POS];",
                " let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1), });",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                " let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                " let len = MAX_VEC_POS;",
                "   assert_eq!(result.len(), len);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "let mut vec = vec![14; MAX_VEC_POS]; // using a valid length close to the max  ",
                "let mut shared = Box::new(Shared {  ",
                "    vec: vec.clone(),  ",
                "    original_capacity_repr: 0,  ",
                "    ref_count: AtomicUsize::new(1),  ",
                "});  ",
                "let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "",
                "let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();  ",
                "let len = MAX_VEC_POS;",
                "",
                "unsafe {",
                "    let result = shared_v_to_mut(&data, ptr, len);",
                "}",
                "let mut vec = vec![14; MAX_VEC_POS];",
                "let mut shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1), });",
                "let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "let len = MAX_VEC_POS;",
                "let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "assert_eq!(result.cap, MAX_VEC_POS);",
                "    assert_eq!(result.cap, MAX_VEC_POS);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "  let mut vec = vec![14; MAX_VEC_POS]; // using a valid length close to the max  ",
                "  let mut shared = Box::new(Shared {  ",
                "       vec: vec.clone(), // Clone vec to keep ownership in the original variable",
                "       original_capacity_repr: 0,",
                "       ref_count: AtomicUsize::new(1),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr = NonNull::new(vec.as_mut_ptr()).unwrap().as_ptr();",
                "   let len = MAX_VEC_POS;",
                "",
                "   unsafe {",
                "       let result = shared_v_to_mut(&data, ptr, len);",
                "  }  ",
                " let mut vec2 = vec![14; MAX_VEC_POS];  // renamed to vec2 to avoid conflict  ",
                " let mut shared = Box::new(Shared { vec: vec2.clone(), original_capacity_repr: 0, ref_count: AtomicUsize::new(1), });  ",
                " let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " let ptr = NonNull::new(vec2.as_mut_ptr()).unwrap().as_ptr(); // use vec2 here  ",
                " let len = MAX_VEC_POS;  ",
                " let result = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                " assert_eq!(unsafe { result.as_slice() }[0], 14);  ",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(2), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.len(), len);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(2), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.cap, vec.len() - len);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(2), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![1, 2, 3, 4, 5];",
                "    let shared = Box::new(Shared { vec: vec.clone(), original_capacity_repr: vec.capacity(), ref_count: AtomicUsize::new(2) });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.as_slice(), &[1, 2, 3]);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![10, 20, 30, 40, 50, 60];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(3), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr: *const u8;  ",
                "  let len: usize = 4; // Length does not exceed the vector's length  ",
                "",
                "  unsafe { ptr = vec.as_ptr().add(2); } // Pointer to the third element  ",
                "   let bytes_mut = unsafe { std::slice::from_raw_parts_mut(ptr as *mut u8, len) }; // Define bytes_mut",
                "   let vec = vec![10, 20, 30, 40, 50, 60];",
                "   let shared = Box::new(Shared {",
                "   vec: vec.clone(),",
                "   original_capacity_repr: vec.capacity(),",
                "   ref_count: AtomicUsize::new(3),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "  let ptr: *const u8;  ",
                "  let len: usize = 4;  ",
                "   assert_eq!(bytes_mut.len(), len);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![10, 20, 30, 40, 50, 60];  ",
                "   let shared = Box::new(Shared {  ",
                "       vec: vec.clone(),  ",
                "       original_capacity_repr: vec.capacity(),  ",
                "       ref_count: AtomicUsize::new(3), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "  let ptr: *const u8;  ",
                "  let len: usize = 4; // Length does not exceed the vector's length  ",
                "  unsafe { ptr = vec.as_ptr().add(2); } // Pointer to the third element  ",
                " ",
                "   let vec = vec![10, 20, 30, 40, 50, 60];  ",
                "   let shared = Box::new(Shared {  ",
                "   vec: vec.clone(),  ",
                "   original_capacity_repr: vec.capacity(),  ",
                "   ref_count: AtomicUsize::new(3),  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "   let ptr: *const u8;  ",
                "   let len: usize = 4;  ",
                "   unsafe { ptr = vec.as_ptr().add(2); }  ",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![100, 200, 255];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(4), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   ",
                "   let ptr: *const u8 = vec.as_ptr();",
                "   let len: usize = 2; // Length is less than the vector's length",
                "   ",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   let vec = vec![100, 200, 255];",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(4),",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.len(), 2);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "   {",
                "       let vec = vec![100, 200, 255];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(4), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2; // Length is less than the vector's length",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   let vec = vec![100, 200, 255];  ",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(4),",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(unsafe { result.as_slice() }, &[100, 200]);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![100, 200, 255];  ",
                "   let shared = Box::new(Shared {  ",
                "       vec: vec.clone(),  ",
                "       original_capacity_repr: vec.capacity(),  ",
                "       ref_count: AtomicUsize::new(4), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "   let ptr: *const u8 = vec.as_ptr();  ",
                "   let len: usize = 2; // Length is less than the vector's length  ",
                " ",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "   let vec = vec![100, 200, 255];  ",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(4),",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "    let ptr: *const u8 = vec.as_ptr();",
                "    let len: usize = 2;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(result.cap, 1);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![7, 14, 21, 28, 35];  ",
                "   let shared = Box::new(Shared {  ",
                "       vec: vec.clone(),  ",
                "       original_capacity_repr: vec.capacity(),  ",
                "       ref_count: AtomicUsize::new(5), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                " ",
                "  let ptr: *const u8;  ",
                "  let len: usize = 3; // Length does not exceed the vector's length  ",
                "  unsafe { ptr = vec.as_ptr().add(1); } // Pointer to the second element  ",
                "  let _ = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "   let vec = vec![7, 14, 21, 28, 35];  ",
                "   let shared = Box::new(Shared {  ",
                "   vec: vec.clone(),  ",
                "   original_capacity_repr: vec.capacity(),  ",
                "   ref_count: AtomicUsize::new(5), // Non-unique  ",
                "   });  ",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "   let ptr: *const u8;  ",
                "   let len: usize = 3;  ",
                "  unsafe { ptr = vec.as_ptr().add(1); }  ",
                "   let result = unsafe { shared_v_to_mut(&data, ptr, len) };  ",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) }; // Pointer to the second element",
                "    let len: usize = 3; // Length does not exceed the vector's length",
                "",
                "    let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) };",
                "    let len: usize = 3;",
                "    let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(unsafe { *(result.ptr.as_ptr()) }, 14);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) }; // Pointer to the second element",
                "   let len: usize = 3; // Length does not exceed the vector's length",
                "   ",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    let vec = vec![7, 14, 21, 28, 35];",
                "    let shared = Box::new(Shared {",
                "    vec: vec.clone(),",
                "    original_capacity_repr: vec.capacity(),",
                "    ref_count: AtomicUsize::new(5), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(1) };",
                "   let len: usize = 3;",
                "   let result = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(unsafe { *(result.ptr.as_ptr().add(2)) }, 28);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(6), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr: *const u8;",
                "  let len: usize = 2; // Length does not exceed the vector's remaining size  ",
                "",
                "  unsafe { ptr = vec.as_ptr().add(4) }; // Pointer to the fifth element  ",
                "  let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];  ",
                "  let shared = Box::new(Shared {  ",
                "      vec: vec.clone(),  ",
                "      original_capacity_repr: vec.capacity(),  ",
                "      ref_count: AtomicUsize::new(6),  ",
                "  });  ",
                "  let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());  ",
                "  let ptr: *const u8;  ",
                "  let len: usize = 2;  ",
                "  unsafe { ptr = vec.as_ptr().add(4) };  ",
                "   let bytes_mut = unsafe { std::slice::from_raw_parts_mut(ptr as *mut u8, len) };",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "    let shared = Box::new(Shared {",
                "        vec: vec.clone(),",
                "        original_capacity_repr: vec.capacity(),",
                "        ref_count: AtomicUsize::new(6), // Non-unique",
                "    });",
                "    let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(4) }; // Pointer to the fifth element",
                "    let len: usize = 2; // Length does not exceed the vector's remaining size",
                "",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, unsafe { ptr }, len) };",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "   vec: vec.clone(),",
                "   original_capacity_repr: vec.capacity(),",
                "   ref_count: AtomicUsize::new(6),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(4) };",
                "   let len: usize = 2;",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "    assert_eq!(bytes_mut.cap, 4);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "       vec: vec.clone(),",
                "       original_capacity_repr: vec.capacity(),",
                "       ref_count: AtomicUsize::new(6), // Non-unique",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "",
                "  let ptr: *const u8;",
                "  let len: usize = 2; // Length does not exceed the vector's remaining size",
                "  ptr = unsafe { vec.as_ptr().add(4) }; // Pointer to the fifth element",
                "   let _ = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   let vec = vec![0, 1, 2, 3, 4, 5, 6, 7];",
                "   let shared = Box::new(Shared {",
                "   vec: vec.clone(),",
                "   original_capacity_repr: vec.capacity(),",
                "   ref_count: AtomicUsize::new(6),",
                "   });",
                "   let data = AtomicPtr::new(Box::into_raw(shared) as *mut ());",
                "   let ptr: *const u8 = unsafe { vec.as_ptr().add(4) };",
                "   let len: usize = 2;",
                "   let bytes_mut = unsafe { shared_v_to_mut(&data, ptr, len) };",
                "   assert_eq!(unsafe { bytes_mut.as_slice() }, &[4, 5]);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ]
}