{
  "system_pt": "As a software testing expert, please generate accurate test oracles code based on the provided information. Follow these guidelines:\n1. Generate executable test oracle codes in plain text format, one per line. Do not output complete test functions, do not repeat provided test prefixes, avoid additional explanations, and do not use Markdown.\n2. Generate necessary test oracles solely for the provided test prefixes.\n3. Each test oracle's assertions are independent and have no dependencies between them.\n4. Group all non-assertion statements first, followed by all assertion statements.\n5. Generate test oracles by interpreting the behavior of the test function through the provided test prefixes, context, and documentation.\n",
  "static_pt": "The context for the focal function is as follows:\n// src/bytes.rs\n// crate name is bytes\nuse core::iter::FromIterator;\nuse core::mem::{self, ManuallyDrop};\nuse core::ops::{Deref, RangeBounds};\nuse core::ptr::NonNull;\nuse core::{cmp, fmt, hash, ptr, slice, usize};\nuse alloc::{\n    alloc::{dealloc, Layout},\n    borrow::Borrow, boxed::Box, string::String, vec::Vec,\n};\nuse crate::buf::IntoIter;\n#[allow(unused)]\nuse crate::loom::sync::atomic::AtomicMut;\nuse crate::loom::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};\nuse crate::{offset_from, Buf, BytesMut};\nstatic OWNED_VTABLE: Vtable = Vtable {\n    clone: owned_clone,\n    into_vec: owned_to_vec,\n    into_mut: owned_to_mut,\n    is_unique: owned_is_unique,\n    drop: owned_drop,\n};\nstatic PROMOTABLE_EVEN_VTABLE: Vtable = Vtable {\n    clone: promotable_even_clone,\n    into_vec: promotable_even_to_vec,\n    into_mut: promotable_even_to_mut,\n    is_unique: promotable_is_unique,\n    drop: promotable_even_drop,\n};\nstatic PROMOTABLE_ODD_VTABLE: Vtable = Vtable {\n    clone: promotable_odd_clone,\n    into_vec: promotable_odd_to_vec,\n    into_mut: promotable_odd_to_mut,\n    is_unique: promotable_is_unique,\n    drop: promotable_odd_drop,\n};\nstatic SHARED_VTABLE: Vtable = Vtable {\n    clone: shared_clone,\n    into_vec: shared_to_vec,\n    into_mut: shared_to_mut,\n    is_unique: shared_is_unique,\n    drop: shared_drop,\n};\nconst STATIC_VTABLE: Vtable = Vtable {\n    clone: static_clone,\n    into_vec: static_to_vec,\n    into_mut: static_to_mut,\n    is_unique: static_is_unique,\n    drop: static_drop,\n};\nconst _: [(); 0 - mem::align_of::<Shared>() % 2] = [];\nconst KIND_ARC: usize = 0b0;\nconst KIND_VEC: usize = 0b1;\nconst KIND_MASK: usize = 0b1;\npub(crate) struct Vtable {\n    /// fn(data, ptr, len)\n    pub clone: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> Bytes,\n    /// fn(data, ptr, len)\n    ///\n    /// `into_*` consumes the `Bytes`, returning the respective value.\n    pub into_vec: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> Vec<u8>,\n    pub into_mut: unsafe fn(&AtomicPtr<()>, *const u8, usize) -> BytesMut,\n    /// fn(data)\n    pub is_unique: unsafe fn(&AtomicPtr<()>) -> bool,\n    /// fn(data, ptr, len)\n    pub drop: unsafe fn(&mut AtomicPtr<()>, *const u8, usize),\n}\npub struct Bytes {\n    ptr: *const u8,\n    len: usize,\n    data: AtomicPtr<()>,\n    vtable: &'static Vtable,\n}\n#[repr(C)]\nstruct OwnedLifetime {\n    ref_cnt: AtomicUsize,\n    drop: unsafe fn(*mut ()),\n}\nunsafe fn owned_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {\n    let owned = data.load(Ordering::Relaxed);\n    let ref_cnt = &(*owned.cast::<OwnedLifetime>()).ref_cnt;\n    let old_cnt = ref_cnt.fetch_add(1, Ordering::Relaxed);\n    if old_cnt > usize::MAX >> 1 {\n        crate::abort()\n    }\n    Bytes {\n        ptr,\n        len,\n        data: AtomicPtr::new(owned as _),\n        vtable: &OWNED_VTABLE,\n    }\n}\n#[inline(never)]\n#[cold]\nfn abort() -> ! {\n    #[cfg(feature = \"std\")]\n    {\n        std::process::abort();\n    }\n    #[cfg(not(feature = \"std\"))]\n    {\n        struct Abort;\n        impl Drop for Abort {\n            fn drop(&mut self) {\n                panic!();\n            }\n        }\n        let _a = Abort;\n        panic!(\"abort\");\n    }\n}\n\nThe function to be tested is presented as follows:\nunsafe fn owned_clone(data: &AtomicPtr<()>, ptr: *const u8, len: usize) -> Bytes {\n    let owned = data.load(Ordering::Relaxed);\n    let ref_cnt = &(*owned.cast::<OwnedLifetime>()).ref_cnt;\n    let old_cnt = ref_cnt.fetch_add(1, Ordering::Relaxed);\n    if old_cnt > usize::MAX >> 1 {\n        crate::abort()\n    }\n\n    Bytes {\n        ptr,\n        len,\n        data: AtomicPtr::new(owned as _),\n        vtable: &OWNED_VTABLE,\n    }\n}\n",
  "depend_pt": ""
}