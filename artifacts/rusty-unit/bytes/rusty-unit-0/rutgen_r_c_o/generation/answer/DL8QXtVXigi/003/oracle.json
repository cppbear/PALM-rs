[
  {
    "uses": [
      "use core::alloc::alloc;",
      "use core::alloc::Layout;",
      "use core::alloc::dealloc;",
      "use core::ptr::null_mut;",
      "use core::ptr::NonNull;"
    ],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::alloc::{alloc, dealloc, Layout};",
          "    use core::ptr::null_mut;",
          "    ",
          "    let layout = Layout::from_size_align(1024, 1).unwrap();",
          "    let shared_ptr = unsafe { alloc(layout) };",
          "    let data = AtomicPtr::new(shared_ptr);",
          "    let ptr = shared_ptr;",
          "    let len = 512;",
          "",
          "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
          "",
          "    unsafe {",
          "        let _result = promotable_to_vec(&data, ptr, len, f);",
          "    }",
          "",
          "    unsafe { dealloc(shared_ptr, layout); }",
          "}"
        ],
        "oracles": [
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_VEC);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(len <= 1024);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(shared_ptr != null_mut());"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(f(shared_ptr) == shared_ptr as *mut u8);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::null_mut;",
            "    ",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::null_mut;",
            "    ",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(len <= 1024);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::null_mut;",
            "    ",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(shared_ptr != null_mut());",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::null_mut;",
            "    ",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = 512;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    unsafe { let _result = promotable_to_vec(&data, ptr, len, f); }",
            "    assert!(f(shared_ptr) == shared_ptr as *mut u8);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::alloc::{alloc, dealloc, Layout};",
          "    use core::ptr::{null_mut, NonNull};",
          "",
          "    let layout = Layout::from_size_align(1024, 1).unwrap();",
          "    let shared_ptr = unsafe { alloc(layout) };",
          "    let data = AtomicPtr::new(shared_ptr);",
          "    ",
          "    // Using a pointer from another kind (not `KIND_ARC`)",
          "    // Simulating the pointer adjustment and treating as a kind",
          "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
          "    let len = 256;",
          "",
          "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
          "",
          "    unsafe {",
          "        let _result = promotable_to_vec(&data, ptr, len, f);",
          "    }",
          "",
          "    unsafe { dealloc(shared_ptr, layout); }",
          "}"
        ],
        "oracles": [
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(ptr::null_mut() != data.load(Ordering::Acquire));"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert_eq!(offset_from(ptr, shared_ptr), 1);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(len <= 1024);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(len > 0);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(shared_ptr as usize % 1 == 0);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK != KIND_ARC);"
          ],
          [
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_VEC);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(ptr::null_mut() != data.load(Ordering::Acquire));",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert_eq!(offset_from(ptr, shared_ptr), 1);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(len <= 1024);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(len > 0);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(shared_ptr as usize % 1 == 0);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK != KIND_ARC);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "    use core::ptr::{null_mut, NonNull};",
            "",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    ",
            "    // Using a pointer from another kind (not `KIND_ARC`)",
            "    // Simulating the pointer adjustment and treating as a kind",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1024, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = NonNull::new(shared_ptr).unwrap().as_ptr().add(1);",
            "    let len = 256;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let _result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(data.load(Ordering::Acquire) as usize & KIND_MASK == KIND_VEC);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let data = AtomicPtr::new(null_mut());",
          "    let ptr = null_mut();",
          "    let len = 0;  // Invalid length to induce a panic",
          "",
          "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
          "",
          "    unsafe {",
          "        let _result = promotable_to_vec(&data, ptr, len, f);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let data = AtomicPtr::new(null_mut());",
            "    let ptr = null_mut();",
            "    let len = 0;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    assert!(std::panic::catch_unwind(|| {"
          ]
        ],
        "codes": [
          [
            "{",
            "    let data = AtomicPtr::new(null_mut());",
            "    let ptr = null_mut();",
            "    let len = 0;  // Invalid length to induce a panic",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "    let data = AtomicPtr::new(null_mut());",
            "    let ptr = null_mut();",
            "    let len = 0;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    assert!(std::panic::catch_unwind(|| {",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    use core::alloc::{alloc, dealloc, Layout};",
          "",
          "    let layout = Layout::from_size_align(1, 1).unwrap();",
          "    let shared_ptr = unsafe { alloc(layout) };",
          "    let data = AtomicPtr::new(shared_ptr);",
          "    let ptr = shared_ptr;",
          "    let len = usize::MAX;",
          "",
          "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
          "",
          "    unsafe {",
          "        let _result = promotable_to_vec(&data, ptr, len, f);",
          "    }",
          "",
          "    unsafe { dealloc(shared_ptr, layout); }",
          "}"
        ],
        "oracles": [
          [
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.len() <= usize::MAX);"
          ],
          [
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.as_ptr() == f(shared_ptr));"
          ],
          [
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.capacity() >= len);"
          ],
          [
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.is_empty() == (len == 0));"
          ],
          [
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(data.load(Ordering::Acquire) == shared_ptr);"
          ]
        ],
        "codes": [
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.len() <= usize::MAX);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.as_ptr() == f(shared_ptr));",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.capacity() >= len);",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(result.is_empty() == (len == 0));",
            "}"
          ],
          [
            "{",
            "    use core::alloc::{alloc, dealloc, Layout};",
            "",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "",
            "    unsafe {",
            "        let _result = promotable_to_vec(&data, ptr, len, f);",
            "    }",
            "",
            "    unsafe { dealloc(shared_ptr, layout); }",
            "    let layout = Layout::from_size_align(1, 1).unwrap();",
            "    let shared_ptr = unsafe { alloc(layout) };",
            "    let data = AtomicPtr::new(shared_ptr);",
            "    let ptr = shared_ptr;",
            "    let len = usize::MAX;",
            "    let f: fn(*mut ()) -> *mut u8 = |ptr| ptr as *mut u8;",
            "    let result = promotable_to_vec(&data, ptr, len, f);",
            "    assert!(data.load(Ordering::Acquire) == shared_ptr);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]