[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct OwnerEmpty;",
          "",
          "    impl AsRef<[u8]> for OwnerEmpty {",
          "        fn as_ref(&self) -> &[u8] {",
          "            &[]",
          "        }",
          "    }",
          "",
          "    let owner = OwnerEmpty;",
          "    let bytes = Bytes::from_owner(owner);",
          "}"
        ],
        "oracles": [
          [
            "    let owner = OwnerEmpty;",
            "    assert!(bytes.ptr != ptr::null());"
          ],
          [
            "    let owner = OwnerEmpty;",
            "    assert_eq!(bytes.len, 0);"
          ],
          [
            "    let owner = OwnerEmpty;",
            "    assert_eq!(bytes.vtable, &OWNED_VTABLE);"
          ],
          [
            "    let owner = OwnerEmpty;",
            "    assert!(bytes.is_unique());"
          ],
          [
            "    let owner = OwnerEmpty;",
            "    assert!(bytes.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct OwnerEmpty;",
            "",
            "    impl AsRef<[u8]> for OwnerEmpty {",
            "        fn as_ref(&self) -> &[u8] {",
            "            &[]",
            "        }",
            "    }",
            "",
            "    let owner = OwnerEmpty;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerEmpty;",
            "    assert!(bytes.ptr != ptr::null());",
            "}"
          ],
          [
            "{",
            "    struct OwnerEmpty;",
            "",
            "    impl AsRef<[u8]> for OwnerEmpty {",
            "        fn as_ref(&self) -> &[u8] {",
            "            &[]",
            "        }",
            "    }",
            "",
            "    let owner = OwnerEmpty;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerEmpty;",
            "    assert_eq!(bytes.len, 0);",
            "}"
          ],
          [
            "{",
            "    struct OwnerEmpty;",
            "",
            "    impl AsRef<[u8]> for OwnerEmpty {",
            "        fn as_ref(&self) -> &[u8] {",
            "            &[]",
            "        }",
            "    }",
            "",
            "    let owner = OwnerEmpty;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerEmpty;",
            "    assert_eq!(bytes.vtable, &OWNED_VTABLE);",
            "}"
          ],
          [
            "{",
            "    struct OwnerEmpty;",
            "",
            "    impl AsRef<[u8]> for OwnerEmpty {",
            "        fn as_ref(&self) -> &[u8] {",
            "            &[]",
            "        }",
            "    }",
            "",
            "    let owner = OwnerEmpty;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerEmpty;",
            "    assert!(bytes.is_unique());",
            "}"
          ],
          [
            "{",
            "    struct OwnerEmpty;",
            "",
            "    impl AsRef<[u8]> for OwnerEmpty {",
            "        fn as_ref(&self) -> &[u8] {",
            "            &[]",
            "        }",
            "    }",
            "",
            "    let owner = OwnerEmpty;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerEmpty;",
            "    assert!(bytes.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct OwnerSmall;",
          "",
          "    impl AsRef<[u8]> for OwnerSmall {",
          "        fn as_ref(&self) -> &[u8] {",
          "            b\"small\"",
          "        }",
          "    }",
          "",
          "    let owner = OwnerSmall;",
          "    let bytes = Bytes::from_owner(owner);",
          "}"
        ],
        "oracles": [
          [
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), 5);"
          ],
          [
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.as_slice(), b\"small\");"
          ],
          [
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.is_empty());"
          ],
          [
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct OwnerSmall;",
            "",
            "    impl AsRef<[u8]> for OwnerSmall {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"small\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), 5);",
            "}"
          ],
          [
            "{",
            "    struct OwnerSmall;",
            "",
            "    impl AsRef<[u8]> for OwnerSmall {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"small\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.as_slice(), b\"small\");",
            "}"
          ],
          [
            "{",
            "    struct OwnerSmall;",
            "",
            "    impl AsRef<[u8]> for OwnerSmall {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"small\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.is_empty());",
            "}"
          ],
          [
            "{",
            "    struct OwnerSmall;",
            "",
            "    impl AsRef<[u8]> for OwnerSmall {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"small\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerSmall;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct OwnerLarge;",
          "",
          "    impl AsRef<[u8]> for OwnerLarge {",
          "        fn as_ref(&self) -> &[u8] {",
          "            b\"this is a considerably larger buffer to test the from_owner functionality\"",
          "        }",
          "    }",
          "",
          "    let owner = OwnerLarge;",
          "    let bytes = Bytes::from_owner(owner);",
          "}"
        ],
        "oracles": [
          [
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), 75);"
          ],
          [
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(unsafe { core::slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"this is a considerably larger buffer to test the from_owner functionality\");"
          ],
          [
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.data.load(Ordering::Relaxed).is_null());"
          ],
          [
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.vtable, &OWNED_VTABLE);"
          ],
          [
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct OwnerLarge;",
            "",
            "    impl AsRef<[u8]> for OwnerLarge {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"this is a considerably larger buffer to test the from_owner functionality\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), 75);",
            "}"
          ],
          [
            "{",
            "    struct OwnerLarge;",
            "",
            "    impl AsRef<[u8]> for OwnerLarge {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"this is a considerably larger buffer to test the from_owner functionality\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(unsafe { core::slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"this is a considerably larger buffer to test the from_owner functionality\");",
            "}"
          ],
          [
            "{",
            "    struct OwnerLarge;",
            "",
            "    impl AsRef<[u8]> for OwnerLarge {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"this is a considerably larger buffer to test the from_owner functionality\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.data.load(Ordering::Relaxed).is_null());",
            "}"
          ],
          [
            "{",
            "    struct OwnerLarge;",
            "",
            "    impl AsRef<[u8]> for OwnerLarge {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"this is a considerably larger buffer to test the from_owner functionality\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.vtable, &OWNED_VTABLE);",
            "}"
          ],
          [
            "{",
            "    struct OwnerLarge;",
            "",
            "    impl AsRef<[u8]> for OwnerLarge {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"this is a considerably larger buffer to test the from_owner functionality\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerLarge;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct OwnerMultiple;",
          "",
          "    impl AsRef<[u8]> for OwnerMultiple {",
          "        fn as_ref(&self) -> &[u8] {",
          "            b\"multiple bytes are definitely better than one\"",
          "        }",
          "    }",
          "",
          "    let owner = OwnerMultiple;",
          "    let bytes = Bytes::from_owner(owner);",
          "}"
        ],
        "oracles": [
          [
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), 40);"
          ],
          [
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.is_empty(), false);"
          ],
          [
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.ptr as usize, bytes.data.load(Ordering::SeqCst) as usize);"
          ],
          [
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());"
          ],
          [
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(unsafe { slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"multiple bytes are definitely better than one\");"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct OwnerMultiple;",
            "",
            "    impl AsRef<[u8]> for OwnerMultiple {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"multiple bytes are definitely better than one\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), 40);",
            "}"
          ],
          [
            "{",
            "    struct OwnerMultiple;",
            "",
            "    impl AsRef<[u8]> for OwnerMultiple {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"multiple bytes are definitely better than one\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.is_empty(), false);",
            "}"
          ],
          [
            "{",
            "    struct OwnerMultiple;",
            "",
            "    impl AsRef<[u8]> for OwnerMultiple {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"multiple bytes are definitely better than one\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.ptr as usize, bytes.data.load(Ordering::SeqCst) as usize);",
            "}"
          ],
          [
            "{",
            "    struct OwnerMultiple;",
            "",
            "    impl AsRef<[u8]> for OwnerMultiple {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"multiple bytes are definitely better than one\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());",
            "}"
          ],
          [
            "{",
            "    struct OwnerMultiple;",
            "",
            "    impl AsRef<[u8]> for OwnerMultiple {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"multiple bytes are definitely better than one\"",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMultiple;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(unsafe { slice::from_raw_parts(bytes.ptr, bytes.len) }, b\"multiple bytes are definitely better than one\");",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct OwnerNonAscii;",
          "",
          "    impl AsRef<[u8]> for OwnerNonAscii {",
          "        fn as_ref(&self) -> &[u8] {",
          "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
          "        }",
          "    }",
          "",
          "    let owner = OwnerNonAscii;",
          "    let bytes = Bytes::from_owner(owner);",
          "}"
        ],
        "oracles": [
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes.len(), 4);"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[0], 0xF0);"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[1], 0x9F);"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[2], 0x98);"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[3], 0x81);"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert!(!bytes.is_empty());"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert!(bytes.is_unique());"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(bytes.len(), 4);"
          ],
          [
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(bytes.ptr, owner_bytes.as_ptr());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes.len(), 4);",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[0], 0xF0);",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[1], 0x9F);",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[2], 0x98);",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(owner_bytes[3], 0x81);",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert!(!bytes.is_empty());",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert!(bytes.is_unique());",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(bytes.len(), 4);",
            "}"
          ],
          [
            "{",
            "    struct OwnerNonAscii;",
            "",
            "    impl AsRef<[u8]> for OwnerNonAscii {",
            "        fn as_ref(&self) -> &[u8] {",
            "            b\"\\xF0\\x9F\\x98\\x81\" // U+1F601 Grinning Face with Smiling Eyes",
            "        }",
            "    }",
            "",
            "    let owner = OwnerNonAscii;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner_bytes = bytes.as_ref();",
            "    assert_eq!(bytes.ptr, owner_bytes.as_ptr());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct OwnerMaxSize;",
          "",
          "    impl AsRef<[u8]> for OwnerMaxSize {",
          "        fn as_ref(&self) -> &[u8] {",
          "            vec![0; usize::MAX].as_slice()",
          "        }",
          "    }",
          "",
          "    let owner = OwnerMaxSize;",
          "    let bytes = Bytes::from_owner(owner);",
          "}"
        ],
        "oracles": [
          [
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), usize::MAX);"
          ],
          [
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.ptr.is_null());"
          ],
          [
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.vtable, &OWNED_VTABLE);"
          ],
          [
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.data.load(Ordering::SeqCst).is_null());"
          ],
          [
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());"
          ],
          [
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.is_empty());"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct OwnerMaxSize;",
            "",
            "    impl AsRef<[u8]> for OwnerMaxSize {",
            "        fn as_ref(&self) -> &[u8] {",
            "            vec![0; usize::MAX].as_slice()",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.len(), usize::MAX);",
            "}"
          ],
          [
            "{",
            "    struct OwnerMaxSize;",
            "",
            "    impl AsRef<[u8]> for OwnerMaxSize {",
            "        fn as_ref(&self) -> &[u8] {",
            "            vec![0; usize::MAX].as_slice()",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.ptr.is_null());",
            "}"
          ],
          [
            "{",
            "    struct OwnerMaxSize;",
            "",
            "    impl AsRef<[u8]> for OwnerMaxSize {",
            "        fn as_ref(&self) -> &[u8] {",
            "            vec![0; usize::MAX].as_slice()",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert_eq!(bytes.vtable, &OWNED_VTABLE);",
            "}"
          ],
          [
            "{",
            "    struct OwnerMaxSize;",
            "",
            "    impl AsRef<[u8]> for OwnerMaxSize {",
            "        fn as_ref(&self) -> &[u8] {",
            "            vec![0; usize::MAX].as_slice()",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.data.load(Ordering::SeqCst).is_null());",
            "}"
          ],
          [
            "{",
            "    struct OwnerMaxSize;",
            "",
            "    impl AsRef<[u8]> for OwnerMaxSize {",
            "        fn as_ref(&self) -> &[u8] {",
            "            vec![0; usize::MAX].as_slice()",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(bytes.is_unique());",
            "}"
          ],
          [
            "{",
            "    struct OwnerMaxSize;",
            "",
            "    impl AsRef<[u8]> for OwnerMaxSize {",
            "        fn as_ref(&self) -> &[u8] {",
            "            vec![0; usize::MAX].as_slice()",
            "        }",
            "    }",
            "",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    let owner = OwnerMaxSize;",
            "    let bytes = Bytes::from_owner(owner);",
            "    assert!(!bytes.is_empty());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]