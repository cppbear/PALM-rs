[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
          "    bytes_mut.len = 10;",
          "    bytes_mut.cap = 10;",
          "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
          "    unsafe {",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.kind(), KIND_ARC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.len, 10);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.cap, 10);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.kind(), KIND_ARC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.len, 10);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.cap, 10);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(unsafe { (*bytes_mut.data).ref_count.load(Ordering::SeqCst) }, 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(15);",
          "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 15][..])) as *mut u8).unwrap();",
          "    bytes_mut.len = 15;",
          "    bytes_mut.cap = 15;",
          "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
          "    unsafe {",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_eq!(unsafe { (*shared_ptr).ref_count.load(Ordering::SeqCst) }, 1);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_ne!(unsafe { (*shared_ptr).ref_count.load(Ordering::SeqCst) }, 2);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_eq!(unsafe { (*shared_ptr).vec.as_slice() }, &[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 15][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 15][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_eq!(unsafe { (*shared_ptr).ref_count.load(Ordering::SeqCst) }, 1);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 15][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_ne!(unsafe { (*shared_ptr).ref_count.load(Ordering::SeqCst) }, 2);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 15][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(15);",
            "    let ptr: *mut u8 = Box::into_raw(Box::new([1u8; 15][..])) as *mut u8;",
            "    bytes_mut.ptr = NonNull::new(ptr).unwrap();",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 15;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (1 << VEC_POS_OFFSET);",
            "    let shared_ptr: *mut Shared = bytes_mut.data as *mut Shared;",
            "    assert_eq!(unsafe { (*shared_ptr).vec.as_slice() }, &[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
          "    bytes_mut.len = 10;",
          "    bytes_mut.cap = 10;",
          "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
          "    unsafe {",
          "        bytes_mut.promote_to_shared(2);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_VEC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.len == 10);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.cap == 10);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(2);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(2);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(2);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.len == 10);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(2);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (2 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.cap == 10);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
          "    bytes_mut.len = 10;",
          "    bytes_mut.cap = 10;",
          "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
          "    unsafe {",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.len, 10);"
          ],
          [
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.cap, 10);"
          ],
          [
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);"
          ],
          [
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.data & ORIGINAL_CAPACITY_MASK, 2 << ORIGINAL_CAPACITY_OFFSET);"
          ],
          [
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.data & NOT_VEC_POS_MASK, 0);"
          ],
          [
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert!(!bytes_mut.data.is_null());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.len, 10);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.cap, 10);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.data & ORIGINAL_CAPACITY_MASK, 2 << ORIGINAL_CAPACITY_OFFSET);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert_eq!(bytes_mut.data & NOT_VEC_POS_MASK, 0);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([0u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(10);",
            "    assert!(!bytes_mut.data.is_null());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(17);",
          "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
          "    bytes_mut.len = 17;",
          "    bytes_mut.cap = 17;",
          "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
          "    unsafe {",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.len, 17);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.cap, 17);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.ptr.as_ptr() == Box::into_raw(Box::new([1u8; 17][..])) as *mut u8);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert!(unsafe { bytes_mut.kind() } == KIND_VEC);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.len, 17);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.cap, 17);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert!(bytes_mut.ptr.as_ptr() == Box::into_raw(Box::new([1u8; 17][..])) as *mut u8);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(17);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([1u8; 17][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 17;",
            "    bytes_mut.cap = 17;",
            "    bytes_mut.data = (3 << ORIGINAL_CAPACITY_OFFSET) | (0 << VEC_POS_OFFSET);",
            "    assert!(unsafe { bytes_mut.kind() } == KIND_VEC);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(10);",
          "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
          "    bytes_mut.len = 10;",
          "    bytes_mut.cap = 10;",
          "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
          "    unsafe {",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "    bytes_mut.promote_to_shared(1);",
            "    }",
            "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "    bytes_mut.promote_to_shared(1);",
            "    }",
            "    assert_eq!(bytes_mut.len, 10);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "    bytes_mut.promote_to_shared(1);",
            "    }",
            "    assert_eq!(bytes_mut.cap, 10);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "    bytes_mut.promote_to_shared(1);",
            "    }",
            "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_ARC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "    bytes_mut.promote_to_shared(1);",
            "    }",
            "    assert_eq!(bytes_mut.len, 10);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(10);",
            "    bytes_mut.ptr = NonNull::new(Box::into_raw(Box::new([7u8; 10][..])) as *mut u8).unwrap();",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 10;",
            "    bytes_mut.data = (2 << ORIGINAL_CAPACITY_OFFSET) | (3 << VEC_POS_OFFSET);",
            "    unsafe {",
            "    bytes_mut.promote_to_shared(1);",
            "    }",
            "    assert_eq!(bytes_mut.cap, 10);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      }
    ]
  }
]