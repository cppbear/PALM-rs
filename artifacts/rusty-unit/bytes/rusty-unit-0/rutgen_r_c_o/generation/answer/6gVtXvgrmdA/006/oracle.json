[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(16);",
          "    unsafe {",
          "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
          "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
          "        bytes_mut.len = 5; // Set length",
          "        bytes_mut.cap = 16; // Set capacity",
          "        bytes_mut.promote_to_shared(1);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_eq!(bytes_mut.kind(), KIND_ARC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_eq!(bytes_mut.len, 5);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_eq!(bytes_mut.cap, 16);"
          ],
          [
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_ne!(bytes_mut.data as usize & KIND_MASK, KIND_VEC);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 16; // Set capacity",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_eq!(bytes_mut.kind(), KIND_ARC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 16; // Set capacity",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_eq!(bytes_mut.len, 5);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 16; // Set capacity",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_eq!(bytes_mut.cap, 16);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 16; // Set capacity",
            "        bytes_mut.promote_to_shared(1);",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(16);",
            "    assert_ne!(bytes_mut.data as usize & KIND_MASK, KIND_VEC);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(32);",
          "    unsafe {",
          "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
          "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
          "        bytes_mut.len = 10; // Set length",
          "        bytes_mut.cap = 32; // Set capacity",
          "        bytes_mut.promote_to_shared(2);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let bytes_mut = BytesMut::with_capacity(32);",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 32;",
            "    let original_capacity_repr = (bytes_mut.data as usize & ORIGINAL_CAPACITY_MASK) >> ORIGINAL_CAPACITY_OFFSET;",
            "    let off = (bytes_mut.data as usize) >> VEC_POS_OFFSET;",
            "    let shared = Box::new(Shared { vec: rebuild_vec(bytes_mut.ptr.as_ptr(), bytes_mut.len, bytes_mut.cap, off), original_capacity_repr, ref_count: AtomicUsize::new(2) });",
            "    let shared_pointer = Box::into_raw(shared);",
            "    debug_assert_eq!(shared_pointer as usize & KIND_MASK, KIND_ARC);",
            "    assert!(bytes_mut.data != shared_pointer);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(32);",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 10; // Set length",
            "        bytes_mut.cap = 32; // Set capacity",
            "        bytes_mut.promote_to_shared(2);",
            "    }",
            "    let bytes_mut = BytesMut::with_capacity(32);",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 10;",
            "    bytes_mut.cap = 32;",
            "    let original_capacity_repr = (bytes_mut.data as usize & ORIGINAL_CAPACITY_MASK) >> ORIGINAL_CAPACITY_OFFSET;",
            "    let off = (bytes_mut.data as usize) >> VEC_POS_OFFSET;",
            "    let shared = Box::new(Shared { vec: rebuild_vec(bytes_mut.ptr.as_ptr(), bytes_mut.len, bytes_mut.cap, off), original_capacity_repr, ref_count: AtomicUsize::new(2) });",
            "    let shared_pointer = Box::into_raw(shared);",
            "    debug_assert_eq!(shared_pointer as usize & KIND_MASK, KIND_ARC);",
            "    assert!(bytes_mut.data != shared_pointer);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::new();",
          "    unsafe {",
          "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
          "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
          "        bytes_mut.len = 5; // Set length",
          "        bytes_mut.cap = 8; // Set capacity",
          "        bytes_mut.promote_to_shared(3); // Should panic",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert!(result.is_err());"
          ],
          [
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_VEC);"
          ],
          [
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert_eq!(bytes_mut.len, 5);"
          ],
          [
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert_eq!(bytes_mut.cap, 8);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::new();",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 8; // Set capacity",
            "        bytes_mut.promote_to_shared(3); // Should panic",
            "    }",
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert!(result.is_err());",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::new();",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 8; // Set capacity",
            "        bytes_mut.promote_to_shared(3); // Should panic",
            "    }",
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert_eq!(bytes_mut.data as usize & KIND_MASK, KIND_VEC);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::new();",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 8; // Set capacity",
            "        bytes_mut.promote_to_shared(3); // Should panic",
            "    }",
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert_eq!(bytes_mut.len, 5);",
            "}"
          ],
          [
            "{",
            "    let mut bytes_mut = BytesMut::new();",
            "    unsafe {",
            "        bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_VEC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 5; // Set length",
            "        bytes_mut.cap = 8; // Set capacity",
            "        bytes_mut.promote_to_shared(3); // Should panic",
            "    }",
            "    let mut bytes_mut = BytesMut::new();",
            "    bytes_mut.data = (KIND_VEC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 5;",
            "    bytes_mut.cap = 8;",
            "    let result = std::panic::catch_unwind(|| {",
            "    unsafe { bytes_mut.promote_to_shared(3); }",
            "    });",
            "    assert_eq!(bytes_mut.cap, 8);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [
          "#[should_panic]"
        ],
        "prefix": [
          "{",
          "    let mut bytes_mut = BytesMut::with_capacity(64);",
          "    unsafe {",
          "        bytes_mut.data = (KIND_ARC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_ARC",
          "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
          "        bytes_mut.len = 15; // Set length",
          "        bytes_mut.cap = 64; // Set capacity",
          "        bytes_mut.promote_to_shared(1); // Should panic",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let mut bytes_mut = BytesMut::with_capacity(64);",
            "    bytes_mut.data = (KIND_ARC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 64;",
            "    assert!(std::panic::catch_unwind(|| { bytes_mut.promote_to_shared(1); }).is_err());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut bytes_mut = BytesMut::with_capacity(64);",
            "    unsafe {",
            "        bytes_mut.data = (KIND_ARC as *mut usize) << VEC_POS_OFFSET; // Set kind to KIND_ARC",
            "        bytes_mut.ptr = NonNull::new(&mut bytes_mut); // Assure it points to a valid memory",
            "        bytes_mut.len = 15; // Set length",
            "        bytes_mut.cap = 64; // Set capacity",
            "        bytes_mut.promote_to_shared(1); // Should panic",
            "    }",
            "    let mut bytes_mut = BytesMut::with_capacity(64);",
            "    bytes_mut.data = (KIND_ARC as *mut usize) << VEC_POS_OFFSET;",
            "    bytes_mut.ptr = NonNull::new(&mut bytes_mut);",
            "    bytes_mut.len = 15;",
            "    bytes_mut.cap = 64;",
            "    assert!(std::panic::catch_unwind(|| { bytes_mut.promote_to_shared(1); }).is_err());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      }
    ]
  }
]