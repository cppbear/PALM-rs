[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
          "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
          "    let len: usize = 5; // length of 5",
          "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
          "",
          "    unsafe {",
          "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "    let shared = Box::new(Shared {",
            "    buf,",
            "    cap: offset_from(offset, buf) + len,",
            "    ref_cnt: AtomicUsize::new(2),",
            "    });",
            "    let shared = Box::into_raw(shared);",
            "    assert!(shared as usize & KIND_MASK == 0);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "    let shared = Box::new(Shared {",
            "    buf,",
            "    cap: offset_from(offset, buf) + len,",
            "    ref_cnt: AtomicUsize::new(2),",
            "    });",
            "    let shared = Box::into_raw(shared);",
            "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "    let shared = Box::new(Shared {",
            "    buf,",
            "    cap: offset_from(offset, buf) + len,",
            "    ref_cnt: AtomicUsize::new(2),",
            "    });",
            "    let shared = Box::into_raw(shared);",
            "    assert_eq!(atom.load(Ordering::Acquire), buf as _);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "    let shared = Box::new(Shared {",
            "    buf,",
            "    cap: offset_from(offset, buf) + len,",
            "    ref_cnt: AtomicUsize::new(2),",
            "    });",
            "    let shared = Box::into_raw(shared);",
            "    assert!(shared as usize & KIND_MASK == 0);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "    let shared = Box::new(Shared {",
            "    buf,",
            "    cap: offset_from(offset, buf) + len,",
            "    ref_cnt: AtomicUsize::new(2),",
            "    });",
            "    let shared = Box::into_raw(shared);",
            "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(1) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 10])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(1) }; // offset of 1",
            "    let len: usize = 5; // length of 5",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(42)) as *mut ());",
            "    let shared = Box::new(Shared {",
            "    buf,",
            "    cap: offset_from(offset, buf) + len,",
            "    ref_cnt: AtomicUsize::new(2),",
            "    });",
            "    let shared = Box::into_raw(shared);",
            "    assert_eq!(atom.load(Ordering::Acquire), buf as _);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
          "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
          "    let len: usize = 8; // length of 8",
          "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
          "",
          "    unsafe {",
          "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert_eq!(0, (shared_ptr as usize & KIND_MASK));"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(atom.compare_exchange(buf as _, shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_ok());"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(atom.load(Ordering::Acquire) as usize == buf as usize);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(offset as usize == buf as usize + 3);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(len == 8);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(!atom.load(Ordering::Acquire).is_null());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
            "    let len: usize = 8; // length of 8",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert_eq!(0, (shared_ptr as usize & KIND_MASK));",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
            "    let len: usize = 8; // length of 8",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(atom.compare_exchange(buf as _, shared_ptr as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
            "    let len: usize = 8; // length of 8",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(atom.load(Ordering::Acquire) as usize == buf as usize);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
            "    let len: usize = 8; // length of 8",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(offset as usize == buf as usize + 3);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
            "    let len: usize = 8; // length of 8",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(len == 8);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) }; // offset of 3",
            "    let len: usize = 8; // length of 8",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, buf as *const u8, buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 20])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(3) };",
            "    let len: usize = 8;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(100)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    assert!(!atom.load(Ordering::Acquire).is_null());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
          "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
          "    let len: usize = 15; // length of 15",
          "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
          "",
          "    unsafe {",
          "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    assert!(0 == (shared_ptr & KIND_MASK));"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    let actual: *mut () = atom.load(Ordering::Acquire);",
            "    assert!(actual as usize != buf as usize);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
            "    let len: usize = 15; // length of 15",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    assert!(0 == (shared_ptr & KIND_MASK));",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
            "    let len: usize = 15; // length of 15",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
            "    let len: usize = 15; // length of 15",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    assert!(atom.compare_exchange(buf as _, shared as _, Ordering::AcqRel, Ordering::Acquire).is_ok());",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) }; // offset of 10",
            "    let len: usize = 15; // length of 15",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(5) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 50])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(10) };",
            "    let len: usize = 15;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(999)) as *mut ());",
            "    let shared: *mut Shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr: usize = shared as usize;",
            "    let actual: *mut () = atom.load(Ordering::Acquire);",
            "    assert!(actual as usize != buf as usize);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
          "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
          "    let len: usize = 12; // length of 12",
          "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
          "",
          "    unsafe {",
          "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) };",
            "    let len: usize = 12;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
            "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
            "    assert!(result.ptr == offset);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) };",
            "    let len: usize = 12;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
            "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
            "    assert!(result.len == len);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) };",
            "    let len: usize = 12;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
            "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
            "    assert_eq!(atom.load(Ordering::Relaxed) as usize, shared_ptr as usize);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
            "    let len: usize = 12; // length of 12",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) };",
            "    let len: usize = 12;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
            "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
            "    assert!(result.ptr == offset);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
            "    let len: usize = 12; // length of 12",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) };",
            "    let len: usize = 12;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
            "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
            "    assert!(result.len == len);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) }; // offset of 5",
            "    let len: usize = 12; // length of 12",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "",
            "    unsafe {",
            "        shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 30])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(5) };",
            "    let len: usize = 12;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(200)) as *mut ());",
            "    let shared = Box::new(Shared { buf, cap: offset_from(offset, buf) + len, ref_cnt: AtomicUsize::new(2) });",
            "    let shared_ptr = Box::into_raw(shared);",
            "    debug_assert!(0 == (shared_ptr as usize & KIND_MASK), \"internal: Box<Shared> should have an aligned pointer\");",
            "    let result = unsafe { shallow_clone_vec(&atom, (buf as *const u8).add(2) as *const (), buf, offset, len) };",
            "    assert_eq!(atom.load(Ordering::Relaxed) as usize, shared_ptr as usize);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
          "    let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
          "    let len: usize = 25; // length of 25",
          "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
          "",
          "    unsafe {",
          "        let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);",
          "    }",
          "}"
        ],
        "oracles": [
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) };",
            "    let len: usize = 25;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "    let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
            "    assert!(shared_ptr_is_aligned == false);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) };",
            "    let len: usize = 25;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "    let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
            "    let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(ptr as _, shared as _, Ordering::AcqRel, Ordering::Acquire);",
            "    assert!(compare_exchange_result.is_ok() == true);"
          ],
          [
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) };",
            "    let len: usize = 25;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "    let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
            "    let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(ptr as _, shared as _, Ordering::AcqRel, Ordering::Acquire);",
            "    let actual_ptr: *mut () = compare_exchange_result.unwrap();",
            "    assert!(actual_ptr as usize == ptr as usize == false);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
            "    let len: usize = 25; // length of 25",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "",
            "    unsafe {",
            "        let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) };",
            "    let len: usize = 25;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "    let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
            "    assert!(shared_ptr_is_aligned == false);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
            "    let len: usize = 25; // length of 25",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "",
            "    unsafe {",
            "        let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) };",
            "    let len: usize = 25;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "    let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
            "    let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(ptr as _, shared as _, Ordering::AcqRel, Ordering::Acquire);",
            "    assert!(compare_exchange_result.is_ok() == true);",
            "}"
          ],
          [
            "{",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) }; // offset of 20",
            "    let len: usize = 25; // length of 25",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "",
            "    unsafe {",
            "        let _ = shallow_clone_vec(&atom, (buf as *const u8).add(15) as *const (), buf, offset, len);",
            "    }",
            "    let buf: *mut u8 = Box::into_raw(Box::new([0u8; 100])) as *mut u8;",
            "    let offset: *const u8 = unsafe { buf.add(20) };",
            "    let len: usize = 25;",
            "    let atom: AtomicPtr<()> = AtomicPtr::new(Box::into_raw(Box::new(500)) as *mut ());",
            "    let shared_ptr_is_aligned: bool = unsafe { (shared as usize & KIND_MASK) == 0 };",
            "    let compare_exchange_result: Result<*mut (), *mut ()> = atom.compare_exchange(ptr as _, shared as _, Ordering::AcqRel, Ordering::Acquire);",
            "    let actual_ptr: *mut () = compare_exchange_result.unwrap();",
            "    assert!(actual_ptr as usize == ptr as usize == false);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]