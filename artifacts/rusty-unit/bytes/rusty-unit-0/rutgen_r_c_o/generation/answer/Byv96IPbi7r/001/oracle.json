[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestLifetime {",
          "        ref_cnt: AtomicUsize,",
          "        drop: unsafe fn(*mut ()),",
          "    }",
          "",
          "    unsafe fn test_drop(_: *mut ()) {}",
          "",
          "    let mut test_instance = TestLifetime {",
          "        ref_cnt: AtomicUsize::new(2),",
          "        drop: test_drop,",
          "    };",
          "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
          "",
          "    owned_drop_impl(owned);",
          "}"
        ],
        "oracles": [
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert_eq!(test_instance.ref_cnt.load(Ordering::SeqCst), 1);"
          ],
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert_eq!(test_instance.ref_cnt.fetch_sub(1, Ordering::Release), 2);"
          ],
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert!(!test_instance.ref_cnt.fetch_sub(1, Ordering::Release) == 0);"
          ],
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert!(test_instance.ref_cnt.load(Ordering::SeqCst) <= usize::MAX >> 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(2),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert_eq!(test_instance.ref_cnt.load(Ordering::SeqCst), 1);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(2),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert_eq!(test_instance.ref_cnt.fetch_sub(1, Ordering::Release), 2);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(2),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert!(!test_instance.ref_cnt.fetch_sub(1, Ordering::Release) == 0);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(2),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(2), drop: test_drop };",
            "    assert!(test_instance.ref_cnt.load(Ordering::SeqCst) <= usize::MAX >> 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestLifetime {",
          "        ref_cnt: AtomicUsize,",
          "        drop: unsafe fn(*mut ()),",
          "    }",
          "",
          "    unsafe fn test_drop(_: *mut ()) {}",
          "",
          "    let mut test_instance = TestLifetime {",
          "        ref_cnt: AtomicUsize::new(4611686018427387903),",
          "        drop: test_drop,",
          "    };",
          "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
          "",
          "    owned_drop_impl(owned);",
          "}"
        ],
        "oracles": [
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert_eq!(test_instance.ref_cnt.load(Ordering::Relaxed), 4611686018427387902);"
          ],
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert!(test_instance.ref_cnt.load(Ordering::Relaxed) > 0);"
          ],
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert!(test_instance.ref_cnt.load(Ordering::Relaxed) <= usize::MAX >> 1);"
          ],
          [
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert!(test_instance.ref_cnt.load(Ordering::Relaxed) != 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387903),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert_eq!(test_instance.ref_cnt.load(Ordering::Relaxed), 4611686018427387902);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387903),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert!(test_instance.ref_cnt.load(Ordering::Relaxed) > 0);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387903),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert!(test_instance.ref_cnt.load(Ordering::Relaxed) <= usize::MAX >> 1);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387903),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let mut test_instance = TestLifetime { ref_cnt: AtomicUsize::new(4611686018427387903), drop: test_drop };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "    assert!(test_instance.ref_cnt.load(Ordering::Relaxed) != 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestLifetime {",
          "        ref_cnt: AtomicUsize,",
          "        drop: unsafe fn(*mut ()),",
          "    }",
          "",
          "    unsafe fn test_drop(_: *mut ()) {}",
          "",
          "    let mut test_instance = TestLifetime {",
          "        ref_cnt: AtomicUsize::new(4611686018427387901),",
          "        drop: test_drop,",
          "    };",
          "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
          "",
          "    owned_drop_impl(owned);",
          "}"
        ],
        "oracles": [
          [
            "    let lifetime = owned.cast::<OwnedLifetime>();",
            "    let ref_cnt = &(*lifetime).ref_cnt;",
            "    let old_cnt = ref_cnt.fetch_sub(1, Ordering::Release);",
            "    debug_assert!(old_cnt > 0 && old_cnt <= usize::MAX >> 1, \"expected non-zero refcount and no underflow\");",
            "    assert!(old_cnt == 4611686018427387901);"
          ],
          [
            "    let lifetime = owned.cast::<OwnedLifetime>();",
            "    let ref_cnt = &(*lifetime).ref_cnt;",
            "    let old_cnt = ref_cnt.fetch_sub(1, Ordering::Release);",
            "    debug_assert!(old_cnt > 0 && old_cnt <= usize::MAX >> 1, \"expected non-zero refcount and no underflow\");",
            "    assert!(old_cnt <= usize::MAX >> 1);"
          ],
          [
            "    let lifetime = owned.cast::<OwnedLifetime>();",
            "    let ref_cnt = &(*lifetime).ref_cnt;",
            "    let old_cnt = ref_cnt.fetch_sub(1, Ordering::Release);",
            "    debug_assert!(old_cnt > 0 && old_cnt <= usize::MAX >> 1, \"expected non-zero refcount and no underflow\");",
            "    assert!(old_cnt != 1);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387901),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let lifetime = owned.cast::<OwnedLifetime>();",
            "    let ref_cnt = &(*lifetime).ref_cnt;",
            "    let old_cnt = ref_cnt.fetch_sub(1, Ordering::Release);",
            "    debug_assert!(old_cnt > 0 && old_cnt <= usize::MAX >> 1, \"expected non-zero refcount and no underflow\");",
            "    assert!(old_cnt == 4611686018427387901);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387901),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let lifetime = owned.cast::<OwnedLifetime>();",
            "    let ref_cnt = &(*lifetime).ref_cnt;",
            "    let old_cnt = ref_cnt.fetch_sub(1, Ordering::Release);",
            "    debug_assert!(old_cnt > 0 && old_cnt <= usize::MAX >> 1, \"expected non-zero refcount and no underflow\");",
            "    assert!(old_cnt <= usize::MAX >> 1);",
            "}"
          ],
          [
            "{",
            "    struct TestLifetime {",
            "        ref_cnt: AtomicUsize,",
            "        drop: unsafe fn(*mut ()),",
            "    }",
            "",
            "    unsafe fn test_drop(_: *mut ()) {}",
            "",
            "    let mut test_instance = TestLifetime {",
            "        ref_cnt: AtomicUsize::new(4611686018427387901),",
            "        drop: test_drop,",
            "    };",
            "    let owned: *mut () = &mut test_instance as *mut _ as *mut ();",
            "",
            "    owned_drop_impl(owned);",
            "    let lifetime = owned.cast::<OwnedLifetime>();",
            "    let ref_cnt = &(*lifetime).ref_cnt;",
            "    let old_cnt = ref_cnt.fetch_sub(1, Ordering::Release);",
            "    debug_assert!(old_cnt > 0 && old_cnt <= usize::MAX >> 1, \"expected non-zero refcount and no underflow\");",
            "    assert!(old_cnt != 1);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]