[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(100);",
          "    buf.extend_from_slice(b\"Hello, World!\");",
          "    let additional = 50; // rem = 100 - 13 = 87, additional <= rem is false",
          "    let result = buf.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Hello, World!\");",
            "    let additional = 50;",
            "    assert_eq!(false, result);"
          ],
          [
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Hello, World!\");",
            "    let additional = 50;",
            "    assert_eq!(87, buf.capacity() - buf.len());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Hello, World!\");",
            "    let additional = 50; // rem = 100 - 13 = 87, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Hello, World!\");",
            "    let additional = 50;",
            "    assert_eq!(false, result);",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Hello, World!\");",
            "    let additional = 50; // rem = 100 - 13 = 87, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Hello, World!\");",
            "    let additional = 50;",
            "    assert_eq!(87, buf.capacity() - buf.len());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(100);",
          "    buf.extend_from_slice(b\"Data\");",
          "    let additional = 150; // rem = 100 - 4 = 96, additional <= rem is false",
          "    let result = buf.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Data\");",
            "    let additional = 150;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(false, result);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Data\");",
            "    let additional = 150; // rem = 100 - 4 = 96, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Data\");",
            "    let additional = 150;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(false, result);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(100);",
          "    buf.extend_from_slice(b\"Example\");",
          "    let additional = 0; // zero additional should always succeed",
          "    let result = buf.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Example\");",
            "    let additional = 0;",
            "    assert_eq!(true, buf.try_reclaim(additional));"
          ],
          [
            "    let buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Example\");",
            "    let additional = 0;",
            "    assert_eq!(100, buf.capacity());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Example\");",
            "    let additional = 0; // zero additional should always succeed",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Example\");",
            "    let additional = 0;",
            "    assert_eq!(true, buf.try_reclaim(additional));",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Example\");",
            "    let additional = 0; // zero additional should always succeed",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(100);",
            "    buf.extend_from_slice(b\"Example\");",
            "    let additional = 0;",
            "    assert_eq!(100, buf.capacity());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(80);",
          "    buf.extend_from_slice(b\"Text Data\");",
          "    let split = buf.split(); // split creates a scenario with more than enough capacity",
          "    let additional = 15; // rem = 80 - 9 = 71, additional <= rem is false",
          "    let result = split.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = BytesMut::with_capacity(80);",
            "    buf.extend_from_slice(b\"Text Data\");",
            "    let split = buf.split();",
            "    let additional = 15;",
            "    let result = split.try_reclaim(additional);",
            "    assert_eq!(false, result);"
          ],
          [
            "    let buf = BytesMut::with_capacity(80);",
            "    buf.extend_from_slice(b\"Text Data\");",
            "    let split = buf.split();",
            "    let additional = 15;",
            "    let result = split.try_reclaim(additional);",
            "    assert_eq!(71, split.capacity());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(80);",
            "    buf.extend_from_slice(b\"Text Data\");",
            "    let split = buf.split(); // split creates a scenario with more than enough capacity",
            "    let additional = 15; // rem = 80 - 9 = 71, additional <= rem is false",
            "    let result = split.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(80);",
            "    buf.extend_from_slice(b\"Text Data\");",
            "    let split = buf.split();",
            "    let additional = 15;",
            "    let result = split.try_reclaim(additional);",
            "    assert_eq!(false, result);",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(80);",
            "    buf.extend_from_slice(b\"Text Data\");",
            "    let split = buf.split(); // split creates a scenario with more than enough capacity",
            "    let additional = 15; // rem = 80 - 9 = 71, additional <= rem is false",
            "    let result = split.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(80);",
            "    buf.extend_from_slice(b\"Text Data\");",
            "    let split = buf.split();",
            "    let additional = 15;",
            "    let result = split.try_reclaim(additional);",
            "    assert_eq!(71, split.capacity());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(64);",
          "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
          "    let additional = 80; // rem = 64 - 26 = 38, additional <= rem is false",
          "    let result = buf.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    assert_eq!(38, buf.capacity() - buf.len());"
          ],
          [
            "    let buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    assert_eq!(false, buf.try_reclaim(80));"
          ],
          [
            "    let buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    assert_eq!(false, buf.try_reclaim(38));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    let additional = 80; // rem = 64 - 26 = 38, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    assert_eq!(38, buf.capacity() - buf.len());",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    let additional = 80; // rem = 64 - 26 = 38, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    assert_eq!(false, buf.try_reclaim(80));",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    let additional = 80; // rem = 64 - 26 = 38, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(64);",
            "    buf.extend_from_slice(b\"Lorem ipsum dolor sit amet\");",
            "    assert_eq!(false, buf.try_reclaim(38));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::new(); // empty buffer",
          "    let additional = 10; // no available capacity, should return false",
          "    let result = buf.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = BytesMut::new();",
            "    let additional = 10;",
            "    assert_eq!(false, buf.try_reclaim(additional));"
          ],
          [
            "    let buf = BytesMut::new();",
            "    let additional = 10;",
            "    assert_eq!(0, buf.capacity());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::new(); // empty buffer",
            "    let additional = 10; // no available capacity, should return false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::new();",
            "    let additional = 10;",
            "    assert_eq!(false, buf.try_reclaim(additional));",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::new(); // empty buffer",
            "    let additional = 10; // no available capacity, should return false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::new();",
            "    let additional = 10;",
            "    assert_eq!(0, buf.capacity());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let mut buf = BytesMut::with_capacity(128);",
          "    buf.resize(128, 0); // fill buffer to max capacity",
          "    let additional = 1; // rem = 128 - 128 = 0, additional <= rem is false",
          "    let result = buf.try_reclaim(additional);",
          "}"
        ],
        "oracles": [
          [
            "    let buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0);",
            "    let additional = 1;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(result, false);"
          ],
          [
            "    let buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0);",
            "    let additional = 1;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(buf.capacity(), 128);"
          ],
          [
            "    let buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0);",
            "    let additional = 1;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(buf.len(), 128);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0); // fill buffer to max capacity",
            "    let additional = 1; // rem = 128 - 128 = 0, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0);",
            "    let additional = 1;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(result, false);",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0); // fill buffer to max capacity",
            "    let additional = 1; // rem = 128 - 128 = 0, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0);",
            "    let additional = 1;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(buf.capacity(), 128);",
            "}"
          ],
          [
            "{",
            "    let mut buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0); // fill buffer to max capacity",
            "    let additional = 1; // rem = 128 - 128 = 0, additional <= rem is false",
            "    let result = buf.try_reclaim(additional);",
            "    let buf = BytesMut::with_capacity(128);",
            "    buf.resize(128, 0);",
            "    let additional = 1;",
            "    let result = buf.try_reclaim(additional);",
            "    assert_eq!(buf.len(), 128);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      }
    ]
  }
]