{
    "function_name": "bytes::bytes::release_shared",
    "tests": 4,
    "tests_lines": [
        38,
        34,
        19,
        19
    ],
    "oracles": 4,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 2,
    "tests_compiled_rate": 50.0,
    "oracles_run": 2,
    "oracles_passed": 1,
    "oracles_passed_rate": 50.0,
    "tests_run": 2,
    "tests_passed": 1,
    "tests_passed_rate": 50.0,
    "lines": 31,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 2,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        1564,
        1565,
        1566,
        1567,
        1568,
        1569,
        1570,
        1571,
        1572,
        1573,
        1574,
        1575,
        1576,
        1577,
        1578,
        1579,
        1580,
        1581,
        1582,
        1583,
        1584,
        1585,
        1586,
        1587,
        1588,
        1589,
        1590,
        1591,
        1592,
        1593,
        1594
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    use std::sync::atomic::{AtomicUsize, Ordering};",
                "",
                "    struct Shared {",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "",
                "    unsafe fn release_shared(ptr: *mut Shared) {",
                "        if (*ptr).ref_cnt.fetch_sub(1, Ordering::Release) != 1 {",
                "            return;",
                "        }",
                "",
                "        (*ptr).ref_cnt.load(Ordering::Acquire);",
                "        drop(Box::from_raw(ptr));",
                "    }",
                "",
                "    // Create a Shared instance with a reference count of 2",
                "    let shared = Shared {",
                "        ref_cnt: AtomicUsize::new(2),",
                "    };",
                "",
                "    // Create a mutable pointer to the Shared instance",
                "    let shared_ptr = Box::into_raw(Box::new(shared));",
                "",
                "    // Call release_shared and expect no panic",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "",
                "    // Ensure ref count is now 1 as we decremented it",
                "    let ref_count = unsafe { (*shared_ptr).ref_cnt.load(Ordering::SeqCst) };",
                "    assert_eq!(ref_count, 1);",
                "",
                "    // Clean up to avoid memory leaks",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    use std::sync::atomic::{AtomicUsize, Ordering};",
                "",
                "    struct Shared {",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "",
                "    unsafe fn release_shared(ptr: *mut Shared) {",
                "        if (*ptr).ref_cnt.fetch_sub(1, Ordering::Release) != 1 {",
                "            return;",
                "        }",
                "",
                "        (*ptr).ref_cnt.load(Ordering::Acquire);",
                "        drop(Box::from_raw(ptr));",
                "    }",
                "",
                "    // Create a Shared instance with a reference count of 1",
                "    let shared = Shared {",
                "        ref_cnt: AtomicUsize::new(1),",
                "    };",
                "",
                "    // Create a mutable pointer to the Shared instance",
                "    let shared_ptr = Box::into_raw(Box::new(shared));",
                "",
                "    // Call release_shared to decrement ref count to 0",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "",
                "    // The next call should panic since the ref count is now 0",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1566,
            "start_column": 8,
            "end_line": 1566,
            "end_column": 59,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    use std::sync::atomic::{AtomicUsize, Ordering};",
                "",
                "    struct Shared {",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "",
                "    unsafe fn release_shared(ptr: *mut Shared) {",
                "        if (*ptr).ref_cnt.fetch_sub(1, Ordering::Release) != 1 {",
                "            return;",
                "        }",
                "",
                "        (*ptr).ref_cnt.load(Ordering::Acquire);",
                "        drop(Box::from_raw(ptr));",
                "    }",
                "",
                "    // Create a Shared instance with a reference count of 2",
                "    let shared = Shared {",
                "        ref_cnt: AtomicUsize::new(2),",
                "    };",
                "",
                "    // Create a mutable pointer to the Shared instance",
                "    let shared_ptr = Box::into_raw(Box::new(shared));",
                "",
                "    // Call release_shared and expect no panic",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "",
                "    // Ensure ref count is now 1 as we decremented it",
                "    let ref_count = unsafe { (*shared_ptr).ref_cnt.load(Ordering::SeqCst) };",
                "    assert_eq!(ref_count, 1);",
                "",
                "    // Clean up to avoid memory leaks",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1566,
                    "start_column": 8,
                    "end_line": 1566,
                    "end_column": 59,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    use std::sync::atomic::{AtomicUsize, Ordering};",
                "",
                "    struct Shared {",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "",
                "    unsafe fn release_shared(ptr: *mut Shared) {",
                "        if (*ptr).ref_cnt.fetch_sub(1, Ordering::Release) != 1 {",
                "            return;",
                "        }",
                "",
                "        (*ptr).ref_cnt.load(Ordering::Acquire);",
                "        drop(Box::from_raw(ptr));",
                "    }",
                "",
                "    // Create a Shared instance with a reference count of 1",
                "    let shared = Shared {",
                "        ref_cnt: AtomicUsize::new(1),",
                "    };",
                "",
                "    // Create a mutable pointer to the Shared instance",
                "    let shared_ptr = Box::into_raw(Box::new(shared));",
                "",
                "    // Call release_shared to decrement ref count to 0",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "",
                "    // The next call should panic since the ref count is now 0",
                "    unsafe {",
                "        release_shared(shared_ptr);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1566,
                    "start_column": 8,
                    "end_line": 1566,
                    "end_column": 59,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes.rs"
}