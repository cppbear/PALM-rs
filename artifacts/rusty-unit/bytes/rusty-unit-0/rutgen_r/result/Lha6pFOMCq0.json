{
    "function_name": "bytes::bytes_mut::bytes_mut::BytesMut::try_unsplit",
    "tests": 11,
    "tests_lines": [
        51,
        40,
        42,
        25,
        8,
        16,
        7,
        14,
        7,
        18,
        16
    ],
    "oracles": 11,
    "oracles_compiled": 2,
    "oracles_compiled_rate": 18.181818181818183,
    "tests_compiled": 2,
    "tests_compiled_rate": 18.181818181818183,
    "oracles_run": 2,
    "oracles_passed": 1,
    "oracles_passed_rate": 50.0,
    "tests_run": 2,
    "tests_passed": 1,
    "tests_passed_rate": 50.0,
    "lines": 15,
    "lines_covered": 4,
    "lines_coveraged_rate": 26.666666666666668,
    "branches": 10,
    "branches_covered": 1,
    "branches_coverage_rate": 10.0,
    "codes_lines": [
        993,
        994,
        995,
        996,
        997,
        998,
        999,
        1000,
        1001,
        1002,
        1005,
        1006,
        1007,
        1009,
        1011
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct BytesMut {",
                "        ptr: *mut u8,",
                "        len: usize,",
                "        cap: usize,",
                "        kind: usize,",
                "        data: usize,",
                "    }",
                "",
                "    const KIND_ARC: usize = 1;",
                "",
                "    impl BytesMut {",
                "        fn new(len: usize, cap: usize, kind: usize, data: usize) -> Self {",
                "            let ptr = Box::into_raw(vec![0u8; cap].into_boxed_slice()) as *mut u8;",
                "            BytesMut { ptr, len, cap, kind, data }",
                "        }",
                "",
                "        fn capacity(&self) -> usize {",
                "            self.cap",
                "        }",
                "",
                "        fn kind(&self) -> usize {",
                "            self.kind",
                "        }",
                "",
                "        fn try_unsplit(&mut self, other: BytesMut) -> Result<(), BytesMut> {",
                "            if other.capacity() == 0 {",
                "                return Ok(());",
                "            }",
                "",
                "            let ptr = unsafe { self.ptr.add(self.len) };",
                "            if ptr == other.ptr",
                "                && self.kind() == KIND_ARC",
                "                && other.kind() == KIND_ARC",
                "                && self.data == other.data",
                "            {",
                "                self.len += other.len;",
                "                self.cap += other.cap;",
                "                Ok(())",
                "            } else {",
                "                Err(other)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut bytes1 = BytesMut::new(5, 10, KIND_ARC, 42);",
                "    let bytes2 = BytesMut::new(5, 10, KIND_ARC, 42);",
                "",
                "    let result = bytes1.try_unsplit(bytes2);",
                "    assert!(result.is_ok());",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(10); // Initial capacity > 0",
                "    let other = BytesMut::with_capacity(0); // Other has capacity zero",
                "",
                "    let result = bytes_mut.try_unsplit(other);",
                "    assert!(result.is_ok()); // Should return Ok(())",
                "}"
            ],
            [
                993,
                994,
                995,
                1011
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 994,
            "start_column": 12,
            "end_line": 994,
            "end_column": 33,
            "positive": true,
            "negative": false
        },
        {
            "start_line": 999,
            "start_column": 12,
            "end_line": 999,
            "end_column": 37,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1000,
            "start_column": 16,
            "end_line": 1000,
            "end_column": 39,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1001,
            "start_column": 16,
            "end_line": 1001,
            "end_column": 40,
            "positive": false,
            "negative": false
        },
        {
            "start_line": 1002,
            "start_column": 16,
            "end_line": 1002,
            "end_column": 39,
            "positive": false,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct BytesMut {",
                "        ptr: *mut u8,",
                "        len: usize,",
                "        cap: usize,",
                "        kind: usize,",
                "        data: usize,",
                "    }",
                "",
                "    const KIND_ARC: usize = 1;",
                "",
                "    impl BytesMut {",
                "        fn new(len: usize, cap: usize, kind: usize, data: usize) -> Self {",
                "            let ptr = Box::into_raw(vec![0u8; cap].into_boxed_slice()) as *mut u8;",
                "            BytesMut { ptr, len, cap, kind, data }",
                "        }",
                "",
                "        fn capacity(&self) -> usize {",
                "            self.cap",
                "        }",
                "",
                "        fn kind(&self) -> usize {",
                "            self.kind",
                "        }",
                "",
                "        fn try_unsplit(&mut self, other: BytesMut) -> Result<(), BytesMut> {",
                "            if other.capacity() == 0 {",
                "                return Ok(());",
                "            }",
                "",
                "            let ptr = unsafe { self.ptr.add(self.len) };",
                "            if ptr == other.ptr",
                "                && self.kind() == KIND_ARC",
                "                && other.kind() == KIND_ARC",
                "                && self.data == other.data",
                "            {",
                "                self.len += other.len;",
                "                self.cap += other.cap;",
                "                Ok(())",
                "            } else {",
                "                Err(other)",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut bytes1 = BytesMut::new(5, 10, KIND_ARC, 42);",
                "    let bytes2 = BytesMut::new(5, 10, KIND_ARC, 42);",
                "",
                "    let result = bytes1.try_unsplit(bytes2);",
                "    assert!(result.is_ok());",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(10); // Initial capacity > 0",
                "    let other = BytesMut::with_capacity(0); // Other has capacity zero",
                "",
                "    let result = bytes_mut.try_unsplit(other);",
                "    assert!(result.is_ok()); // Should return Ok(())",
                "}"
            ],
            [
                {
                    "start_line": 994,
                    "start_column": 12,
                    "end_line": 994,
                    "end_column": 33,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 999,
                    "start_column": 12,
                    "end_line": 999,
                    "end_column": 37,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1000,
                    "start_column": 16,
                    "end_line": 1000,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1001,
                    "start_column": 16,
                    "end_line": 1001,
                    "end_column": 40,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1002,
                    "start_column": 16,
                    "end_line": 1002,
                    "end_column": 39,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs"
}