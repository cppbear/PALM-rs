{
    "function_name": "bytes::bytes_mut::bytes_mut::BytesMut::set_vec_pos",
    "tests": 7,
    "tests_lines": [
        36,
        37,
        37,
        10,
        8,
        10,
        8
    ],
    "oracles": 7,
    "oracles_compiled": 6,
    "oracles_compiled_rate": 85.71428571428571,
    "tests_compiled": 6,
    "tests_compiled_rate": 85.71428571428571,
    "oracles_run": 6,
    "oracles_passed": 4,
    "oracles_passed_rate": 66.66666666666666,
    "tests_run": 6,
    "tests_passed": 4,
    "tests_passed_rate": 66.66666666666666,
    "lines": 5,
    "lines_covered": 0,
    "lines_coveraged_rate": 0.0,
    "branches": 1,
    "branches_covered": 0,
    "branches_coverage_rate": 0.0,
    "codes_lines": [
        1076,
        1077,
        1078,
        1080,
        1081
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    const KIND_VEC: u32 = 1;",
                "    const MAX_VEC_POS: usize = 100;",
                "    const VEC_POS_OFFSET: usize = 10;",
                "    const NOT_VEC_POS_MASK: usize = !0b1111111111; // Assuming valid bits are lower 10 bits",
                "",
                "    struct BytesMut {",
                "        kind: u32,",
                "        data: *mut u8,",
                "    }",
                "",
                "    impl BytesMut {",
                "        fn kind(&self) -> u32 {",
                "            self.kind",
                "        }",
                "",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind(), KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    fn invalid_ptr(val: usize) -> *mut u8 {",
                "        val as *mut u8",
                "    }",
                "",
                "    let mut bytes = BytesMut {",
                "        kind: KIND_VEC,",
                "        data: invalid_ptr(0),",
                "    };",
                "",
                "    unsafe {",
                "        bytes.set_vec_pos(50); // Valid position, should not panic",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    const KIND_VEC: u32 = 1;",
                "    const MAX_VEC_POS: usize = 100;",
                "    const VEC_POS_OFFSET: usize = 10;",
                "    const NOT_VEC_POS_MASK: usize = !0b1111111111; // Assuming valid bits are lower 10 bits",
                "",
                "    struct BytesMut {",
                "        kind: u32,",
                "        data: *mut u8,",
                "    }",
                "",
                "    impl BytesMut {",
                "        fn kind(&self) -> u32 {",
                "            self.kind",
                "        }",
                "",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind(), KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    fn invalid_ptr(val: usize) -> *mut u8 {",
                "        val as *mut u8",
                "    }",
                "",
                "    let mut bytes = BytesMut {",
                "        kind: KIND_VEC,",
                "        data: invalid_ptr(0),",
                "    };",
                "",
                "    unsafe {",
                "        bytes.set_vec_pos(101); // Exceeding position, should panic",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, KIND_VEC);",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, 5);",
                "        let expected_data = (5 << VEC_POS_OFFSET) | (data & NOT_VEC_POS_MASK);",
                "        assert_eq!(bytes.data as usize, expected_data);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, KIND_VEC);",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, MAX_VEC_POS + 1);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, KIND_VEC);",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, 0);",
                "        let expected_data = (0 << VEC_POS_OFFSET) | (data & NOT_VEC_POS_MASK);",
                "        assert_eq!(bytes.data as usize, expected_data);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, 0); // Invalid kind",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, 5);",
                "    }",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [],
    "codes_branches_covered": [
        [
            [
                "{",
                "    const KIND_VEC: u32 = 1;",
                "    const MAX_VEC_POS: usize = 100;",
                "    const VEC_POS_OFFSET: usize = 10;",
                "    const NOT_VEC_POS_MASK: usize = !0b1111111111; // Assuming valid bits are lower 10 bits",
                "",
                "    struct BytesMut {",
                "        kind: u32,",
                "        data: *mut u8,",
                "    }",
                "",
                "    impl BytesMut {",
                "        fn kind(&self) -> u32 {",
                "            self.kind",
                "        }",
                "",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind(), KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    fn invalid_ptr(val: usize) -> *mut u8 {",
                "        val as *mut u8",
                "    }",
                "",
                "    let mut bytes = BytesMut {",
                "        kind: KIND_VEC,",
                "        data: invalid_ptr(0),",
                "    };",
                "",
                "    unsafe {",
                "        bytes.set_vec_pos(50); // Valid position, should not panic",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    const KIND_VEC: u32 = 1;",
                "    const MAX_VEC_POS: usize = 100;",
                "    const VEC_POS_OFFSET: usize = 10;",
                "    const NOT_VEC_POS_MASK: usize = !0b1111111111; // Assuming valid bits are lower 10 bits",
                "",
                "    struct BytesMut {",
                "        kind: u32,",
                "        data: *mut u8,",
                "    }",
                "",
                "    impl BytesMut {",
                "        fn kind(&self) -> u32 {",
                "            self.kind",
                "        }",
                "",
                "        unsafe fn set_vec_pos(&mut self, pos: usize) {",
                "            debug_assert_eq!(self.kind(), KIND_VEC);",
                "            debug_assert!(pos <= MAX_VEC_POS);",
                "",
                "            self.data = invalid_ptr((pos << VEC_POS_OFFSET) | (self.data as usize & NOT_VEC_POS_MASK));",
                "        }",
                "    }",
                "",
                "    fn invalid_ptr(val: usize) -> *mut u8 {",
                "        val as *mut u8",
                "    }",
                "",
                "    let mut bytes = BytesMut {",
                "        kind: KIND_VEC,",
                "        data: invalid_ptr(0),",
                "    };",
                "",
                "    unsafe {",
                "        bytes.set_vec_pos(101); // Exceeding position, should panic",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, KIND_VEC);",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, 5);",
                "        let expected_data = (5 << VEC_POS_OFFSET) | (data & NOT_VEC_POS_MASK);",
                "        assert_eq!(bytes.data as usize, expected_data);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, KIND_VEC);",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, MAX_VEC_POS + 1);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, KIND_VEC);",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, 0);",
                "        let expected_data = (0 << VEC_POS_OFFSET) | (data & NOT_VEC_POS_MASK);",
                "        assert_eq!(bytes.data as usize, expected_data);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut data: usize = 0x1000; // Some initial value",
                "    let mut bytes = BytesMut::new(&mut data as *mut usize as *mut u8, 0); // Invalid kind",
                "    ",
                "    unsafe {",
                "        set_vec_pos(&mut bytes, 5);",
                "    }",
                "}"
            ],
            []
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs"
}