{
    "function_name": "bytes::bytes_mut::bytes_mut::BytesMut::promote_to_shared",
    "tests": 12,
    "tests_lines": [
        8,
        7,
        10,
        8,
        10,
        18,
        34,
        34,
        14,
        12,
        12,
        14
    ],
    "oracles": 12,
    "oracles_compiled": 12,
    "oracles_compiled_rate": 100.0,
    "tests_compiled": 12,
    "tests_compiled_rate": 100.0,
    "oracles_run": 12,
    "oracles_passed": 7,
    "oracles_passed_rate": 58.333333333333336,
    "tests_run": 12,
    "tests_passed": 7,
    "tests_passed_rate": 58.333333333333336,
    "lines": 30,
    "lines_covered": 30,
    "lines_coveraged_rate": 100.0,
    "branches": 4,
    "branches_covered": 4,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1018,
        1019,
        1020,
        1022,
        1023,
        1024,
        1025,
        1026,
        1027,
        1028,
        1029,
        1030,
        1031,
        1032,
        1033,
        1034,
        1035,
        1036,
        1037,
        1038,
        1039,
        1040,
        1041,
        1042,
        1043,
        1044,
        1045,
        1046,
        1048,
        1049
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    // Setting initial state to directly meet constraints",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(2); // This should operate without panic",
                "    }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    // Setting ref_cnt to 1, which has to trigger a panic",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(1); // This should panic due to the `ref_cnt` constraint",
                "    }",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(10);",
                "    let ref_cnt = 2; // Choose a ref_cnt that satisfies the constraint",
                "    // Assuming we could manipulate state directly for this test",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "    }",
                "    // Verify that state has transitioned correctly",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    let ref_cnt = 2; // violating the constraint",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "    }",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    let ref_cnt = 1; // satisfying the constraint",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "        // Verify that the pointer and values are as expected",
                "        assert_eq!(bytes_mut.kind(), KIND_ARC); // After promotion, kind should be KIND_ARC",
                "    }",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    // Setup BytesMut with unique content",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    let ref_cnt = 1; // satisfying the constraint",
                "",
                "    // Fill the BytesMut in a valid manner, ensuring it meets the constraints",
                "    unsafe {",
                "        bytes_mut.resize(10, 1);",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "    }",
                "",
                "    unsafe {",
                "        // Check if the contents are still the same after promotion",
                "        assert_eq!(bytes_mut.len(), 10);",
                "        let slice = bytes_mut.as_slice();",
                "        assert!(slice.iter().all(|&x| x == 1)); // contents should be `1`",
                "    }",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    // Helper structure to create a BytesMut instance",
                "    struct BytesMutTest {",
                "        bytes_mut: BytesMut,",
                "    }",
                "",
                "    impl BytesMutTest {",
                "        fn new_with_capacity(capacity: usize) -> BytesMutTest {",
                "            let bytes_mut = unsafe { BytesMut::with_capacity(capacity) };",
                "            BytesMutTest { bytes_mut }",
                "        }",
                "",
                "        fn set_data(&mut self, data: &[u8]) {",
                "            unsafe {",
                "                self.bytes_mut.extend_from_slice(data);",
                "            }",
                "        }",
                "",
                "        fn promote(&mut self, ref_cnt: usize) {",
                "            unsafe {",
                "                self.bytes_mut.promote_to_shared(ref_cnt);",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut bytes = BytesMutTest::new_with_capacity(10);",
                "    bytes.set_data(&[1, 2, 3, 4, 5]);",
                "",
                "    // Promote with ref_count = 1",
                "    bytes.promote(1);",
                "",
                "    // Check that the internal state is consistent",
                "    assert_eq!(bytes.bytes_mut.kind(), KIND_ARC);",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    // Helper structure to create a BytesMut instance",
                "    struct BytesMutTest {",
                "        bytes_mut: BytesMut,",
                "    }",
                "",
                "    impl BytesMutTest {",
                "        fn new_with_capacity(capacity: usize) -> BytesMutTest {",
                "            let bytes_mut = unsafe { BytesMut::with_capacity(capacity) };",
                "            BytesMutTest { bytes_mut }",
                "        }",
                "",
                "        fn set_data(&mut self, data: &[u8]) {",
                "            unsafe {",
                "                self.bytes_mut.extend_from_slice(data);",
                "            }",
                "        }",
                "",
                "        fn promote(&mut self, ref_cnt: usize) {",
                "            unsafe {",
                "                self.bytes_mut.promote_to_shared(ref_cnt);",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut bytes = BytesMutTest::new_with_capacity(10);",
                "    bytes.set_data(&[6, 7, 8, 9, 10]);",
                "",
                "    // Promote with ref_count = 2",
                "    bytes.promote(2);",
                "",
                "    // Check that the internal state is consistent",
                "    assert_eq!(bytes.bytes_mut.kind(), KIND_ARC);",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_VEC as *mut Shared).cast();",
                "        bytes_mut.len = 5;",
                "        bytes_mut.cap = 10;",
                "    }",
                "    ",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(1);",
                "    }",
                "",
                "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_ARC);",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_ARC as *mut Shared).cast();",
                "        bytes_mut.len = 5;",
                "        bytes_mut.cap = 10;",
                "    }",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(1);",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_VEC as *mut Shared).cast();",
                "        bytes_mut.len = 5;",
                "        bytes_mut.cap = 10;",
                "    }",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(3);",
                "    }",
                "}"
            ],
            [
                1018,
                1019,
                1020
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_VEC as *mut Shared).cast();",
                "        bytes_mut.len = 10;",
                "        bytes_mut.cap = 20;",
                "    }",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(2);",
                "    }",
                "",
                "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_ARC);",
                "}"
            ],
            [
                1018,
                1019,
                1020,
                1022,
                1023,
                1024,
                1025,
                1026,
                1027,
                1028,
                1029,
                1030,
                1031,
                1032,
                1033,
                1034,
                1035,
                1036,
                1037,
                1038,
                1039,
                1040,
                1041,
                1042,
                1043,
                1044,
                1045,
                1046,
                1048,
                1049
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1020,
            "start_column": 23,
            "end_line": 1020,
            "end_column": 35,
            "positive": true,
            "negative": true
        },
        {
            "start_line": 1020,
            "start_column": 39,
            "end_line": 1020,
            "end_column": 51,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    // Setting initial state to directly meet constraints",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(2); // This should operate without panic",
                "    }",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::new();",
                "    // Setting ref_cnt to 1, which has to trigger a panic",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(1); // This should panic due to the `ref_cnt` constraint",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(10);",
                "    let ref_cnt = 2; // Choose a ref_cnt that satisfies the constraint",
                "    // Assuming we could manipulate state directly for this test",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "    }",
                "    // Verify that state has transitioned correctly",
                "    assert_eq!(bytes_mut.kind(), KIND_VEC);",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    let ref_cnt = 2; // violating the constraint",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    let ref_cnt = 1; // satisfying the constraint",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "        // Verify that the pointer and values are as expected",
                "        assert_eq!(bytes_mut.kind(), KIND_ARC); // After promotion, kind should be KIND_ARC",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Setup BytesMut with unique content",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    let ref_cnt = 1; // satisfying the constraint",
                "",
                "    // Fill the BytesMut in a valid manner, ensuring it meets the constraints",
                "    unsafe {",
                "        bytes_mut.resize(10, 1);",
                "        bytes_mut.promote_to_shared(ref_cnt);",
                "    }",
                "",
                "    unsafe {",
                "        // Check if the contents are still the same after promotion",
                "        assert_eq!(bytes_mut.len(), 10);",
                "        let slice = bytes_mut.as_slice();",
                "        assert!(slice.iter().all(|&x| x == 1)); // contents should be `1`",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Helper structure to create a BytesMut instance",
                "    struct BytesMutTest {",
                "        bytes_mut: BytesMut,",
                "    }",
                "",
                "    impl BytesMutTest {",
                "        fn new_with_capacity(capacity: usize) -> BytesMutTest {",
                "            let bytes_mut = unsafe { BytesMut::with_capacity(capacity) };",
                "            BytesMutTest { bytes_mut }",
                "        }",
                "",
                "        fn set_data(&mut self, data: &[u8]) {",
                "            unsafe {",
                "                self.bytes_mut.extend_from_slice(data);",
                "            }",
                "        }",
                "",
                "        fn promote(&mut self, ref_cnt: usize) {",
                "            unsafe {",
                "                self.bytes_mut.promote_to_shared(ref_cnt);",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut bytes = BytesMutTest::new_with_capacity(10);",
                "    bytes.set_data(&[1, 2, 3, 4, 5]);",
                "",
                "    // Promote with ref_count = 1",
                "    bytes.promote(1);",
                "",
                "    // Check that the internal state is consistent",
                "    assert_eq!(bytes.bytes_mut.kind(), KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    // Helper structure to create a BytesMut instance",
                "    struct BytesMutTest {",
                "        bytes_mut: BytesMut,",
                "    }",
                "",
                "    impl BytesMutTest {",
                "        fn new_with_capacity(capacity: usize) -> BytesMutTest {",
                "            let bytes_mut = unsafe { BytesMut::with_capacity(capacity) };",
                "            BytesMutTest { bytes_mut }",
                "        }",
                "",
                "        fn set_data(&mut self, data: &[u8]) {",
                "            unsafe {",
                "                self.bytes_mut.extend_from_slice(data);",
                "            }",
                "        }",
                "",
                "        fn promote(&mut self, ref_cnt: usize) {",
                "            unsafe {",
                "                self.bytes_mut.promote_to_shared(ref_cnt);",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut bytes = BytesMutTest::new_with_capacity(10);",
                "    bytes.set_data(&[6, 7, 8, 9, 10]);",
                "",
                "    // Promote with ref_count = 2",
                "    bytes.promote(2);",
                "",
                "    // Check that the internal state is consistent",
                "    assert_eq!(bytes.bytes_mut.kind(), KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_VEC as *mut Shared).cast();",
                "        bytes_mut.len = 5;",
                "        bytes_mut.cap = 10;",
                "    }",
                "    ",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(1);",
                "    }",
                "",
                "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": true,
                    "negative": false
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_ARC as *mut Shared).cast();",
                "        bytes_mut.len = 5;",
                "        bytes_mut.cap = 10;",
                "    }",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(1);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": false
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(10) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_VEC as *mut Shared).cast();",
                "        bytes_mut.len = 5;",
                "        bytes_mut.cap = 10;",
                "    }",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(3);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = unsafe { BytesMut::with_capacity(20) };",
                "    unsafe {",
                "        bytes_mut.data = (KIND_VEC as *mut Shared).cast();",
                "        bytes_mut.len = 10;",
                "        bytes_mut.cap = 20;",
                "    }",
                "",
                "    unsafe {",
                "        bytes_mut.promote_to_shared(2);",
                "    }",
                "",
                "    assert!(bytes_mut.data as usize & KIND_MASK == KIND_ARC);",
                "}"
            ],
            [
                {
                    "start_line": 1020,
                    "start_column": 23,
                    "end_line": 1020,
                    "end_column": 35,
                    "positive": false,
                    "negative": true
                },
                {
                    "start_line": 1020,
                    "start_column": 39,
                    "end_line": 1020,
                    "end_column": 51,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs"
}