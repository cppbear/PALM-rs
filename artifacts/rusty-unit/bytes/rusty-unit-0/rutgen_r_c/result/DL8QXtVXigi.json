{
    "function_name": "bytes::bytes::promotable_to_vec",
    "tests": 6,
    "tests_lines": [
        36,
        28,
        35,
        27,
        37,
        39
    ],
    "oracles": 6,
    "oracles_compiled": 3,
    "oracles_compiled_rate": 50.0,
    "tests_compiled": 3,
    "tests_compiled_rate": 50.0,
    "oracles_run": 3,
    "oracles_passed": 1,
    "oracles_passed_rate": 33.33333333333333,
    "tests_run": 3,
    "tests_passed": 1,
    "tests_passed_rate": 33.33333333333333,
    "lines": 21,
    "lines_covered": 12,
    "lines_coveraged_rate": 57.14285714285714,
    "branches": 2,
    "branches_covered": 1,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        1221,
        1222,
        1223,
        1224,
        1225,
        1226,
        1227,
        1228,
        1229,
        1230,
        1231,
        1234,
        1236,
        1237,
        1238,
        1239,
        1240,
        1241,
        1242,
        1243,
        1245
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    struct DataWrapper {",
                "        atomic_ptr: AtomicPtr<()>,",
                "    }",
                "",
                "    impl DataWrapper {",
                "        fn new_invalid() -> Self {",
                "            let atomic_ptr = AtomicPtr::new(ptr::null_mut());",
                "            DataWrapper { atomic_ptr }",
                "        }",
                "    }",
                "",
                "    let data_wrapper = DataWrapper::new_invalid();",
                "    let ptr = ptr::null();",
                "    let len = 10;",
                "",
                "    unsafe {",
                "        promotable_to_vec(",
                "            &data_wrapper.atomic_ptr,",
                "            ptr,",
                "            len,",
                "            |shared| {",
                "                let shared_ref = shared as *mut Shared;",
                "                (*shared_ref).buf",
                "            },",
                "        ); // This should panic",
                "    }",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct DummyShared {",
                "        buf: *mut u8,",
                "        cap: usize,",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "    ",
                "    let mut data: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "    let len = 10;",
                "    ",
                "    let mut vec_buf = vec![0u8; len];",
                "    let mut dummy_shared = DummyShared {",
                "        buf: vec_buf.as_mut_ptr(),",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    };",
                "",
                "    // Store a pointer to DummyShared as an AtomicPtr",
                "    let shared_ptr = &mut dummy_shared as *mut DummyShared as *mut ();",
                "    data.store(shared_ptr, Ordering::Release);",
                "    ",
                "    // Function pointer to allocate memory for the buffer",
                "    let alloc_fn = |shared: *mut ()| -> *mut u8 {",
                "        unsafe {",
                "            let shared_ref = &*(shared as *mut DummyShared);",
                "            shared_ref.buf",
                "        }",
                "    };",
                "    ",
                "    // Should execute without panicking as the kind is KIND_VEC",
                "    let result_vec = unsafe {",
                "        promotable_to_vec(&data, dummy_shared.buf, len, alloc_fn)",
                "    };",
                "",
                "    // Ensure the content of the vector is same as initial buffer",
                "    assert_eq!(result_vec, vec![0; len]);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct DummyShared {",
                "        buf: *mut u8,",
                "        cap: usize,",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "    ",
                "    let mut data: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "    let len = 10;",
                "",
                "    let initial_buf = vec![1u8; len];",
                "    let mut vec_buf = vec![0u8; len];",
                "    let mut dummy_shared = DummyShared {",
                "        buf: vec_buf.as_mut_ptr(),",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    };",
                "",
                "    // Store a pointer to DummyShared as an AtomicPtr",
                "    let shared_ptr = &mut dummy_shared as *mut DummyShared as *mut ();",
                "    data.store(shared_ptr, Ordering::Release);",
                "    ",
                "    // Function pointer to allocate memory for the buffer",
                "    let alloc_fn = |shared: *mut ()| -> *mut u8 {",
                "        unsafe {",
                "            let shared_ref = &*(shared as *mut DummyShared);",
                "            shared_ref.buf",
                "        }",
                "    };",
                "",
                "    // Change ref_count to trigger panic (not necessary for this function)",
                "    dummy_shared.ref_cnt.store(2, Ordering::Release);",
                "",
                "    // Check that calling the function with unexpected kind will trigger a panic",
                "    #[should_panic(expected = \"assertion failed: kind == KIND_VEC\")]",
                "    unsafe {",
                "        let _ = promotable_to_vec(&data, initial_buf.as_ptr(), len, alloc_fn);",
                "    }",
                "}"
            ],
            [
                1221,
                1222,
                1223,
                1224,
                1225,
                1226,
                1227,
                1228,
                1229,
                1230,
                1231,
                1245
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1230,
            "start_column": 8,
            "end_line": 1230,
            "end_column": 24,
            "positive": true,
            "negative": false
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    struct DataWrapper {",
                "        atomic_ptr: AtomicPtr<()>,",
                "    }",
                "",
                "    impl DataWrapper {",
                "        fn new_invalid() -> Self {",
                "            let atomic_ptr = AtomicPtr::new(ptr::null_mut());",
                "            DataWrapper { atomic_ptr }",
                "        }",
                "    }",
                "",
                "    let data_wrapper = DataWrapper::new_invalid();",
                "    let ptr = ptr::null();",
                "    let len = 10;",
                "",
                "    unsafe {",
                "        promotable_to_vec(",
                "            &data_wrapper.atomic_ptr,",
                "            ptr,",
                "            len,",
                "            |shared| {",
                "                let shared_ref = shared as *mut Shared;",
                "                (*shared_ref).buf",
                "            },",
                "        ); // This should panic",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1230,
                    "start_column": 8,
                    "end_line": 1230,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct DummyShared {",
                "        buf: *mut u8,",
                "        cap: usize,",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "    ",
                "    let mut data: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "    let len = 10;",
                "    ",
                "    let mut vec_buf = vec![0u8; len];",
                "    let mut dummy_shared = DummyShared {",
                "        buf: vec_buf.as_mut_ptr(),",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    };",
                "",
                "    // Store a pointer to DummyShared as an AtomicPtr",
                "    let shared_ptr = &mut dummy_shared as *mut DummyShared as *mut ();",
                "    data.store(shared_ptr, Ordering::Release);",
                "    ",
                "    // Function pointer to allocate memory for the buffer",
                "    let alloc_fn = |shared: *mut ()| -> *mut u8 {",
                "        unsafe {",
                "            let shared_ref = &*(shared as *mut DummyShared);",
                "            shared_ref.buf",
                "        }",
                "    };",
                "    ",
                "    // Should execute without panicking as the kind is KIND_VEC",
                "    let result_vec = unsafe {",
                "        promotable_to_vec(&data, dummy_shared.buf, len, alloc_fn)",
                "    };",
                "",
                "    // Ensure the content of the vector is same as initial buffer",
                "    assert_eq!(result_vec, vec![0; len]);",
                "}"
            ],
            [
                {
                    "start_line": 1230,
                    "start_column": 8,
                    "end_line": 1230,
                    "end_column": 24,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct DummyShared {",
                "        buf: *mut u8,",
                "        cap: usize,",
                "        ref_cnt: AtomicUsize,",
                "    }",
                "    ",
                "    let mut data: AtomicPtr<()> = AtomicPtr::new(std::ptr::null_mut());",
                "    let len = 10;",
                "",
                "    let initial_buf = vec![1u8; len];",
                "    let mut vec_buf = vec![0u8; len];",
                "    let mut dummy_shared = DummyShared {",
                "        buf: vec_buf.as_mut_ptr(),",
                "        cap: len,",
                "        ref_cnt: AtomicUsize::new(1),",
                "    };",
                "",
                "    // Store a pointer to DummyShared as an AtomicPtr",
                "    let shared_ptr = &mut dummy_shared as *mut DummyShared as *mut ();",
                "    data.store(shared_ptr, Ordering::Release);",
                "    ",
                "    // Function pointer to allocate memory for the buffer",
                "    let alloc_fn = |shared: *mut ()| -> *mut u8 {",
                "        unsafe {",
                "            let shared_ref = &*(shared as *mut DummyShared);",
                "            shared_ref.buf",
                "        }",
                "    };",
                "",
                "    // Change ref_count to trigger panic (not necessary for this function)",
                "    dummy_shared.ref_cnt.store(2, Ordering::Release);",
                "",
                "    // Check that calling the function with unexpected kind will trigger a panic",
                "    #[should_panic(expected = \"assertion failed: kind == KIND_VEC\")]",
                "    unsafe {",
                "        let _ = promotable_to_vec(&data, initial_buf.as_ptr(), len, alloc_fn);",
                "    }",
                "}"
            ],
            [
                {
                    "start_line": 1230,
                    "start_column": 8,
                    "end_line": 1230,
                    "end_column": 24,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes.rs"
}