{
    "function_name": "bytes::bytes_mut::bytes_mut::BytesMut::freeze",
    "tests": 10,
    "tests_lines": [
        10,
        6,
        8,
        96,
        12,
        5,
        52,
        12,
        5,
        7
    ],
    "oracles": 10,
    "oracles_compiled": 8,
    "oracles_compiled_rate": 80.0,
    "tests_compiled": 8,
    "tests_compiled_rate": 80.0,
    "oracles_run": 8,
    "oracles_passed": 6,
    "oracles_passed_rate": 75.0,
    "tests_run": 8,
    "tests_passed": 6,
    "tests_passed_rate": 75.0,
    "lines": 14,
    "lines_covered": 14,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        246,
        247,
        248,
        251,
        252,
        253,
        254,
        255,
        258,
        260,
        261,
        262,
        263,
        265
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    let bytes_mut = BytesMut::new();",
                "    let frozen_bytes = bytes_mut.freeze();",
                "    ",
                "    assert!(frozen_bytes.is_empty());",
                "}"
            ],
            [
                246,
                247,
                248,
                251,
                252,
                253,
                254,
                255,
                265
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let input_data = vec![0u8; usize::MAX];",
                "    bytes_mut.extend_from_slice(&input_data);",
                "    let frozen_bytes = bytes_mut.freeze();",
                "    ",
                "    assert_eq!(frozen_bytes.len(), usize::MAX);",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    struct TestBuf;",
                "    ",
                "    impl Buf for TestBuf {",
                "        fn remaining(&self) -> usize { 10 }",
                "        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] }",
                "        fn advance(&mut self, _cnt: usize) {}",
                "        fn has_remaining(&self) -> bool { self.remaining() > 0 }",
                "        fn copy_to_slice(&mut self, dst: &mut [u8]) { dst.copy_from_slice(self.chunk()) }",
                "        fn get_u8(&mut self) -> u8 { 0 }",
                "        fn get_i8(&mut self) -> i8 { 0 }",
                "        fn get_u16(&mut self) -> u16 { 0 }",
                "        fn get_u16_le(&mut self) -> u16 { 0 }",
                "        fn get_u16_ne(&mut self) -> u16 { 0 }",
                "        fn get_i16(&mut self) -> i16 { 0 }",
                "        fn get_i16_le(&mut self) -> i16 { 0 }",
                "        fn get_i16_ne(&mut self) -> i16 { 0 }",
                "        fn get_u32(&mut self) -> u32 { 0 }",
                "        fn get_u32_le(&mut self) -> u32 { 0 }",
                "        fn get_u32_ne(&mut self) -> u32 { 0 }",
                "        fn get_i32(&mut self) -> i32 { 0 }",
                "        fn get_i32_le(&mut self) -> i32 { 0 }",
                "        fn get_i32_ne(&mut self) -> i32 { 0 }",
                "        fn get_u64(&mut self) -> u64 { 0 }",
                "        fn get_u64_le(&mut self) -> u64 { 0 }",
                "        fn get_u64_ne(&mut self) -> u64 { 0 }",
                "        fn get_i64(&mut self) -> i64 { 0 }",
                "        fn get_i64_le(&mut self) -> i64 { 0 }",
                "        fn get_i64_ne(&mut self) -> i64 { 0 }",
                "        fn get_u128(&mut self) -> u128 { 0 }",
                "        fn get_u128_le(&mut self) -> u128 { 0 }",
                "        fn get_u128_ne(&mut self) -> u128 { 0 }",
                "        fn get_i128(&mut self) -> i128 { 0 }",
                "        fn get_i128_le(&mut self) -> i128 { 0 }",
                "        fn get_i128_ne(&mut self) -> i128 { 0 }",
                "        fn get_uint(&mut self, _nbytes: usize) -> u64 { 0 }",
                "        fn get_uint_le(&mut self, _nbytes: usize) -> u64 { 0 }",
                "        fn get_uint_ne(&mut self, _nbytes: usize) -> u64 { 0 }",
                "        fn get_int(&mut self, _nbytes: usize) -> i64 { 0 }",
                "        fn get_int_le(&mut self, _nbytes: usize) -> i64 { 0 }",
                "        fn get_int_ne(&mut self, _nbytes: usize) -> i64 { 0 }",
                "        fn get_f32(&mut self) -> f32 { 0.0 }",
                "        fn get_f32_le(&mut self) -> f32 { 0.0 }",
                "        fn get_f32_ne(&mut self) -> f32 { 0.0 }",
                "        fn get_f64(&mut self) -> f64 { 0.0 }",
                "        fn get_f64_le(&mut self) -> f64 { 0.0 }",
                "        fn get_f64_ne(&mut self) -> f64 { 0.0 }",
                "        fn try_copy_to_slice(&mut self, _dst: &mut [u8]) -> Result<(), TryGetError> { Ok(()) }",
                "        fn try_get_u8(&mut self) -> Result<u8, TryGetError> { Ok(0) }",
                "        fn try_get_i8(&mut self) -> Result<i8, TryGetError> { Ok(0) }",
                "        fn try_get_u16(&mut self) -> Result<u16, TryGetError> { Ok(0) }",
                "        fn try_get_u16_le(&mut self) -> Result<u16, TryGetError> { Ok(0) }",
                "        fn try_get_u16_ne(&mut self) -> Result<u16, TryGetError> { Ok(0) }",
                "        fn try_get_i16(&mut self) -> Result<i16, TryGetError> { Ok(0) }",
                "        fn try_get_i16_le(&mut self) -> Result<i16, TryGetError> { Ok(0) }",
                "        fn try_get_i16_ne(&mut self) -> Result<i16, TryGetError> { Ok(0) }",
                "        fn try_get_u32(&mut self) -> Result<u32, TryGetError> { Ok(0) }",
                "        fn try_get_u32_le(&mut self) -> Result<u32, TryGetError> { Ok(0) }",
                "        fn try_get_u32_ne(&mut self) -> Result<u32, TryGetError> { Ok(0) }",
                "        fn try_get_i32(&mut self) -> Result<i32, TryGetError> { Ok(0) }",
                "        fn try_get_i32_le(&mut self) -> Result<i32, TryGetError> { Ok(0) }",
                "        fn try_get_i32_ne(&mut self) -> Result<i32, TryGetError> { Ok(0) }",
                "        fn try_get_u64(&mut self) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_u64_le(&mut self) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_u64_ne(&mut self) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_i64(&mut self) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_i64_le(&mut self) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_i64_ne(&mut self) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_u128(&mut self) -> Result<u128, TryGetError> { Ok(0) }",
                "        fn try_get_u128_le(&mut self) -> Result<u128, TryGetError> { Ok(0) }",
                "        fn try_get_u128_ne(&mut self) -> Result<u128, TryGetError> { Ok(0) }",
                "        fn try_get_i128(&mut self) -> Result<i128, TryGetError> { Ok(0) }",
                "        fn try_get_i128_le(&mut self) -> Result<i128, TryGetError> { Ok(0) }",
                "        fn try_get_i128_ne(&mut self) -> Result<i128, TryGetError> { Ok(0) }",
                "        fn try_get_uint(&mut self, _nbytes: usize) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_uint_le(&mut self, _nbytes: usize) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_uint_ne(&mut self, _nbytes: usize) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_int(&mut self, _nbytes: usize) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_int_le(&mut self, _nbytes: usize) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_int_ne(&mut self, _nbytes: usize) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_f32(&mut self) -> Result<f32, TryGetError> { Ok(0.0) }",
                "        fn try_get_f32_le(&mut self) -> Result<f32, TryGetError> { Ok(0.0) }",
                "        fn try_get_f32_ne(&mut self) -> Result<f32, TryGetError> { Ok(0.0) }",
                "        fn try_get_f64(&mut self) -> Result<f64, TryGetError> { Ok(0.0) }",
                "        fn try_get_f64_le(&mut self) -> Result<f64, TryGetError> { Ok(0.0) }",
                "        fn try_get_f64_ne(&mut self) -> Result<f64, TryGetError> { Ok(0.0) }",
                "    }",
                "",
                "    let mut buffer = BytesMut::with_capacity(10);",
                "    buffer.extend_from_slice(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);",
                "    ",
                "    let frozen_bytes = buffer.freeze();",
                "    ",
                "    assert_eq!(frozen_bytes.len(), 10);",
                "    assert!(!frozen_bytes.is_empty());",
                "}"
            ],
            [
                246,
                247,
                248,
                251,
                252,
                253,
                254,
                255,
                265
            ]
        ],
        [
            [
                "{",
                "    let mut buffer = BytesMut::with_capacity(20);",
                "    buffer.extend_from_slice(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);",
                "    ",
                "    let split = buffer.split_off(10);",
                "    let frozen_bytes = buffer.freeze();",
                "    ",
                "    assert_eq!(frozen_bytes.len(), 10);",
                "    assert_eq!(split.len(), 10);",
                "    assert_eq!(frozen_bytes.chunk(), &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);",
                "    assert_eq!(split.chunk(), &[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);",
                "}"
            ],
            [
                246,
                247,
                248,
                258,
                260,
                261,
                262,
                263,
                265
            ]
        ],
        [
            [
                "{",
                "    let mut buffer = BytesMut::new();",
                "    ",
                "    let _ = buffer.split_off(1); // Attempting to split off more than exists should trigger panic",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "   let mut b = BytesMut::with_capacity(64);",
                "   b.extend_from_slice(b\"hello\");",
                "   let b1 = b.freeze();",
                "",
                "   let b2 = b1.clone();",
                "",
                "   // Additional verification",
                "   assert_eq!(b1.len(), b\"hello\".len());",
                "   assert_eq!(b2.len(), b\"hello\".len());",
                "   assert_ne!(b1.as_ptr(), b2.as_ptr()); // Ensure they are different pointers",
                "}"
            ],
            [
                246,
                247,
                248,
                251,
                252,
                253,
                254,
                255,
                265
            ]
        ],
        [
            [
                "{",
                "    let mut b = BytesMut::with_capacity(10);",
                "    b.advance(20); // Advancing beyond the capacity to trigger panic on freezing",
                "    let _ = b.freeze();",
                "}"
            ],
            []
        ],
        [
            [
                "{",
                "    let b = BytesMut::new();",
                "    let frozen_bytes = b.freeze();",
                "    ",
                "    assert!(frozen_bytes.is_empty());",
                "    assert_eq!(frozen_bytes.len(), 0);",
                "}"
            ],
            [
                246,
                247,
                248,
                251,
                252,
                253,
                254,
                255,
                265
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 248,
            "start_column": 12,
            "end_line": 248,
            "end_column": 36,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    let bytes_mut = BytesMut::new();",
                "    let frozen_bytes = bytes_mut.freeze();",
                "    ",
                "    assert!(frozen_bytes.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut bytes_mut = BytesMut::with_capacity(usize::MAX);",
                "    let input_data = vec![0u8; usize::MAX];",
                "    bytes_mut.extend_from_slice(&input_data);",
                "    let frozen_bytes = bytes_mut.freeze();",
                "    ",
                "    assert_eq!(frozen_bytes.len(), usize::MAX);",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    struct TestBuf;",
                "    ",
                "    impl Buf for TestBuf {",
                "        fn remaining(&self) -> usize { 10 }",
                "        fn chunk(&self) -> &[u8] { &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] }",
                "        fn advance(&mut self, _cnt: usize) {}",
                "        fn has_remaining(&self) -> bool { self.remaining() > 0 }",
                "        fn copy_to_slice(&mut self, dst: &mut [u8]) { dst.copy_from_slice(self.chunk()) }",
                "        fn get_u8(&mut self) -> u8 { 0 }",
                "        fn get_i8(&mut self) -> i8 { 0 }",
                "        fn get_u16(&mut self) -> u16 { 0 }",
                "        fn get_u16_le(&mut self) -> u16 { 0 }",
                "        fn get_u16_ne(&mut self) -> u16 { 0 }",
                "        fn get_i16(&mut self) -> i16 { 0 }",
                "        fn get_i16_le(&mut self) -> i16 { 0 }",
                "        fn get_i16_ne(&mut self) -> i16 { 0 }",
                "        fn get_u32(&mut self) -> u32 { 0 }",
                "        fn get_u32_le(&mut self) -> u32 { 0 }",
                "        fn get_u32_ne(&mut self) -> u32 { 0 }",
                "        fn get_i32(&mut self) -> i32 { 0 }",
                "        fn get_i32_le(&mut self) -> i32 { 0 }",
                "        fn get_i32_ne(&mut self) -> i32 { 0 }",
                "        fn get_u64(&mut self) -> u64 { 0 }",
                "        fn get_u64_le(&mut self) -> u64 { 0 }",
                "        fn get_u64_ne(&mut self) -> u64 { 0 }",
                "        fn get_i64(&mut self) -> i64 { 0 }",
                "        fn get_i64_le(&mut self) -> i64 { 0 }",
                "        fn get_i64_ne(&mut self) -> i64 { 0 }",
                "        fn get_u128(&mut self) -> u128 { 0 }",
                "        fn get_u128_le(&mut self) -> u128 { 0 }",
                "        fn get_u128_ne(&mut self) -> u128 { 0 }",
                "        fn get_i128(&mut self) -> i128 { 0 }",
                "        fn get_i128_le(&mut self) -> i128 { 0 }",
                "        fn get_i128_ne(&mut self) -> i128 { 0 }",
                "        fn get_uint(&mut self, _nbytes: usize) -> u64 { 0 }",
                "        fn get_uint_le(&mut self, _nbytes: usize) -> u64 { 0 }",
                "        fn get_uint_ne(&mut self, _nbytes: usize) -> u64 { 0 }",
                "        fn get_int(&mut self, _nbytes: usize) -> i64 { 0 }",
                "        fn get_int_le(&mut self, _nbytes: usize) -> i64 { 0 }",
                "        fn get_int_ne(&mut self, _nbytes: usize) -> i64 { 0 }",
                "        fn get_f32(&mut self) -> f32 { 0.0 }",
                "        fn get_f32_le(&mut self) -> f32 { 0.0 }",
                "        fn get_f32_ne(&mut self) -> f32 { 0.0 }",
                "        fn get_f64(&mut self) -> f64 { 0.0 }",
                "        fn get_f64_le(&mut self) -> f64 { 0.0 }",
                "        fn get_f64_ne(&mut self) -> f64 { 0.0 }",
                "        fn try_copy_to_slice(&mut self, _dst: &mut [u8]) -> Result<(), TryGetError> { Ok(()) }",
                "        fn try_get_u8(&mut self) -> Result<u8, TryGetError> { Ok(0) }",
                "        fn try_get_i8(&mut self) -> Result<i8, TryGetError> { Ok(0) }",
                "        fn try_get_u16(&mut self) -> Result<u16, TryGetError> { Ok(0) }",
                "        fn try_get_u16_le(&mut self) -> Result<u16, TryGetError> { Ok(0) }",
                "        fn try_get_u16_ne(&mut self) -> Result<u16, TryGetError> { Ok(0) }",
                "        fn try_get_i16(&mut self) -> Result<i16, TryGetError> { Ok(0) }",
                "        fn try_get_i16_le(&mut self) -> Result<i16, TryGetError> { Ok(0) }",
                "        fn try_get_i16_ne(&mut self) -> Result<i16, TryGetError> { Ok(0) }",
                "        fn try_get_u32(&mut self) -> Result<u32, TryGetError> { Ok(0) }",
                "        fn try_get_u32_le(&mut self) -> Result<u32, TryGetError> { Ok(0) }",
                "        fn try_get_u32_ne(&mut self) -> Result<u32, TryGetError> { Ok(0) }",
                "        fn try_get_i32(&mut self) -> Result<i32, TryGetError> { Ok(0) }",
                "        fn try_get_i32_le(&mut self) -> Result<i32, TryGetError> { Ok(0) }",
                "        fn try_get_i32_ne(&mut self) -> Result<i32, TryGetError> { Ok(0) }",
                "        fn try_get_u64(&mut self) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_u64_le(&mut self) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_u64_ne(&mut self) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_i64(&mut self) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_i64_le(&mut self) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_i64_ne(&mut self) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_u128(&mut self) -> Result<u128, TryGetError> { Ok(0) }",
                "        fn try_get_u128_le(&mut self) -> Result<u128, TryGetError> { Ok(0) }",
                "        fn try_get_u128_ne(&mut self) -> Result<u128, TryGetError> { Ok(0) }",
                "        fn try_get_i128(&mut self) -> Result<i128, TryGetError> { Ok(0) }",
                "        fn try_get_i128_le(&mut self) -> Result<i128, TryGetError> { Ok(0) }",
                "        fn try_get_i128_ne(&mut self) -> Result<i128, TryGetError> { Ok(0) }",
                "        fn try_get_uint(&mut self, _nbytes: usize) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_uint_le(&mut self, _nbytes: usize) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_uint_ne(&mut self, _nbytes: usize) -> Result<u64, TryGetError> { Ok(0) }",
                "        fn try_get_int(&mut self, _nbytes: usize) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_int_le(&mut self, _nbytes: usize) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_int_ne(&mut self, _nbytes: usize) -> Result<i64, TryGetError> { Ok(0) }",
                "        fn try_get_f32(&mut self) -> Result<f32, TryGetError> { Ok(0.0) }",
                "        fn try_get_f32_le(&mut self) -> Result<f32, TryGetError> { Ok(0.0) }",
                "        fn try_get_f32_ne(&mut self) -> Result<f32, TryGetError> { Ok(0.0) }",
                "        fn try_get_f64(&mut self) -> Result<f64, TryGetError> { Ok(0.0) }",
                "        fn try_get_f64_le(&mut self) -> Result<f64, TryGetError> { Ok(0.0) }",
                "        fn try_get_f64_ne(&mut self) -> Result<f64, TryGetError> { Ok(0.0) }",
                "    }",
                "",
                "    let mut buffer = BytesMut::with_capacity(10);",
                "    buffer.extend_from_slice(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);",
                "    ",
                "    let frozen_bytes = buffer.freeze();",
                "    ",
                "    assert_eq!(frozen_bytes.len(), 10);",
                "    assert!(!frozen_bytes.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut buffer = BytesMut::with_capacity(20);",
                "    buffer.extend_from_slice(&[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);",
                "    ",
                "    let split = buffer.split_off(10);",
                "    let frozen_bytes = buffer.freeze();",
                "    ",
                "    assert_eq!(frozen_bytes.len(), 10);",
                "    assert_eq!(split.len(), 10);",
                "    assert_eq!(frozen_bytes.chunk(), &[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);",
                "    assert_eq!(split.chunk(), &[11, 12, 13, 14, 15, 16, 17, 18, 19, 20]);",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "    let mut buffer = BytesMut::new();",
                "    ",
                "    let _ = buffer.split_off(1); // Attempting to split off more than exists should trigger panic",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "   let mut b = BytesMut::with_capacity(64);",
                "   b.extend_from_slice(b\"hello\");",
                "   let b1 = b.freeze();",
                "",
                "   let b2 = b1.clone();",
                "",
                "   // Additional verification",
                "   assert_eq!(b1.len(), b\"hello\".len());",
                "   assert_eq!(b2.len(), b\"hello\".len());",
                "   assert_ne!(b1.as_ptr(), b2.as_ptr()); // Ensure they are different pointers",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let mut b = BytesMut::with_capacity(10);",
                "    b.advance(20); // Advancing beyond the capacity to trigger panic on freezing",
                "    let _ = b.freeze();",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": false,
                    "negative": false
                }
            ]
        ],
        [
            [
                "{",
                "    let b = BytesMut::new();",
                "    let frozen_bytes = b.freeze();",
                "    ",
                "    assert!(frozen_bytes.is_empty());",
                "    assert_eq!(frozen_bytes.len(), 0);",
                "}"
            ],
            [
                {
                    "start_line": 248,
                    "start_column": 12,
                    "end_line": 248,
                    "end_column": 36,
                    "positive": true,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs"
}