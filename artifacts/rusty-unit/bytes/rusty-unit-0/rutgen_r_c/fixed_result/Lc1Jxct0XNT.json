{
    "function_name": "bytes::bytes_mut::shared_v_to_mut",
    "tests": 4,
    "tests_lines": [
        30,
        29,
        34,
        27
    ],
    "oracles": 4,
    "oracles_compiled": 1,
    "oracles_compiled_rate": 25.0,
    "tests_compiled": 1,
    "tests_compiled_rate": 25.0,
    "oracles_run": 1,
    "oracles_passed": 1,
    "oracles_passed_rate": 100.0,
    "tests_run": 1,
    "tests_passed": 1,
    "tests_passed_rate": 100.0,
    "lines": 26,
    "lines_covered": 8,
    "lines_coveraged_rate": 30.76923076923077,
    "branches": 2,
    "branches_covered": 1,
    "branches_coverage_rate": 50.0,
    "codes_lines": [
        1815,
        1816,
        1817,
        1818,
        1819,
        1820,
        1821,
        1822,
        1823,
        1824,
        1825,
        1826,
        1827,
        1828,
        1829,
        1830,
        1831,
        1832,
        1833,
        1834,
        1835,
        1836,
        1838,
        1839,
        1840,
        1842
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    use core::sync::atomic::{AtomicPtr, Ordering};",
                "    ",
                "    struct Shared {",
                "        vec: Vec<u8>,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    unsafe fn create_non_unique_shared() -> (AtomicPtr<()>, NonNull<u8>, usize) {",
                "        let vec = Vec::from_iter(vec![1, 2, 3, 4, 5]);",
                "        let shared = Box::into_raw(Box::new(Shared {",
                "            vec,",
                "            ref_count: AtomicUsize::new(2),",
                "        }));",
                "        let atom_ptr = AtomicPtr::new(shared as *mut ());",
                "        let ptr = NonNull::new_unchecked((*shared).vec.as_mut_ptr());",
                "        let len = (*shared).vec.len();",
                "        (atom_ptr, ptr, len)",
                "    }",
                "",
                "    let (data, ptr, len) = unsafe { create_non_unique_shared() };",
                "",
                "    let bytes_mut = unsafe { shared_v_to_mut(&data, ptr.as_ptr(), len) };",
                "",
                "    assert_eq!(bytes_mut.len(), len);",
                "    assert_eq!(bytes_mut.capacity(), len);",
                "}"
            ],
            [
                1815,
                1816,
                1817,
                1818,
                1838,
                1839,
                1840,
                1842
            ]
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1818,
            "start_column": 8,
            "end_line": 1818,
            "end_column": 29,
            "positive": false,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "    use core::ptr::NonNull;",
                "    use alloc::vec::Vec;",
                "    use core::sync::atomic::{AtomicPtr, Ordering};",
                "    ",
                "    struct Shared {",
                "        vec: Vec<u8>,",
                "        ref_count: AtomicUsize,",
                "    }",
                "",
                "    unsafe fn create_non_unique_shared() -> (AtomicPtr<()>, NonNull<u8>, usize) {",
                "        let vec = Vec::from_iter(vec![1, 2, 3, 4, 5]);",
                "        let shared = Box::into_raw(Box::new(Shared {",
                "            vec,",
                "            ref_count: AtomicUsize::new(2),",
                "        }));",
                "        let atom_ptr = AtomicPtr::new(shared as *mut ());",
                "        let ptr = NonNull::new_unchecked((*shared).vec.as_mut_ptr());",
                "        let len = (*shared).vec.len();",
                "        (atom_ptr, ptr, len)",
                "    }",
                "",
                "    let (data, ptr, len) = unsafe { create_non_unique_shared() };",
                "",
                "    let bytes_mut = unsafe { shared_v_to_mut(&data, ptr.as_ptr(), len) };",
                "",
                "    assert_eq!(bytes_mut.len(), len);",
                "    assert_eq!(bytes_mut.capacity(), len);",
                "}"
            ],
            [
                {
                    "start_line": 1818,
                    "start_column": 8,
                    "end_line": 1818,
                    "end_column": 29,
                    "positive": false,
                    "negative": true
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/bytes_mut.rs"
}