{
    "function_name": "bytes::buf::buf_mut::<alloc::vec::Vec<u8> as buf::buf_mut::BufMut>::put",
    "tests": 5,
    "tests_lines": [
        51,
        27,
        8,
        9,
        6
    ],
    "oracles": 5,
    "oracles_compiled": 3,
    "oracles_compiled_rate": 60.0,
    "tests_compiled": 3,
    "tests_compiled_rate": 60.0,
    "oracles_run": 3,
    "oracles_passed": 2,
    "oracles_passed_rate": 66.66666666666666,
    "tests_run": 3,
    "tests_passed": 2,
    "tests_passed_rate": 66.66666666666666,
    "lines": 13,
    "lines_covered": 13,
    "lines_coveraged_rate": 100.0,
    "branches": 2,
    "branches_covered": 2,
    "branches_coverage_rate": 100.0,
    "codes_lines": [
        1641,
        1642,
        1643,
        1644,
        1645,
        1646,
        1648,
        1649,
        1650,
        1651,
        1652,
        1653,
        1654
    ],
    "codes_lines_covered": [
        [
            [
                "{",
                "   let mut buf = Vec::new();  ",
                "   let empty_buf: &[u8] = &[];  ",
                " ",
                "   buf.put(empty_buf);  ",
                "",
                "    assert!(buf.is_empty());",
                "}"
            ],
            [
                1641,
                1642,
                1643,
                1644,
                1645,
                1646,
                1648,
                1654
            ]
        ],
        [
            [
                "{",
                "   let mut buf = Vec::new();",
                "   let large_buf: Vec<u8> = vec![1; 1024]; // src with 1024 bytes remaining",
                "",
                "   buf.put(&large_buf[..]);",
                "",
                "   assert_eq!(buf.len(), 1024);",
                "   assert_eq!(buf.as_slice(), &[1; 1024]);",
                "}"
            ],
            [
                1641,
                1642,
                1643,
                1644,
                1645,
                1646,
                1648,
                1649,
                1650,
                1651,
                1652,
                1653,
                1654
            ]
        ],
        [
            [
                "{",
                "   let mut buf = Vec::with_capacity(2);",
                "   let large_buf: &[u8] = &[1; 3]; // src requesting more than buffer can accommodate",
                "",
                "   buf.put_slice(large_buf);",
                "}"
            ],
            []
        ]
    ],
    "codes_branches": [
        {
            "start_line": 1648,
            "start_column": 15,
            "end_line": 1648,
            "end_column": 34,
            "positive": true,
            "negative": true
        }
    ],
    "codes_branches_covered": [
        [
            [
                "{",
                "   let mut buf = Vec::new();  ",
                "   let empty_buf: &[u8] = &[];  ",
                " ",
                "   buf.put(empty_buf);  ",
                "",
                "    assert!(buf.is_empty());",
                "}"
            ],
            [
                {
                    "start_line": 1648,
                    "start_column": 15,
                    "end_line": 1648,
                    "end_column": 34,
                    "positive": false,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let mut buf = Vec::new();",
                "   let large_buf: Vec<u8> = vec![1; 1024]; // src with 1024 bytes remaining",
                "",
                "   buf.put(&large_buf[..]);",
                "",
                "   assert_eq!(buf.len(), 1024);",
                "   assert_eq!(buf.as_slice(), &[1; 1024]);",
                "}"
            ],
            [
                {
                    "start_line": 1648,
                    "start_column": 15,
                    "end_line": 1648,
                    "end_column": 34,
                    "positive": true,
                    "negative": true
                }
            ]
        ],
        [
            [
                "{",
                "   let mut buf = Vec::with_capacity(2);",
                "   let large_buf: &[u8] = &[1; 3]; // src requesting more than buffer can accommodate",
                "",
                "   buf.put_slice(large_buf);",
                "}"
            ],
            [
                {
                    "start_line": 1648,
                    "start_column": 15,
                    "end_line": 1648,
                    "end_column": 34,
                    "positive": false,
                    "negative": false
                }
            ]
        ]
    ],
    "file_path": "/home/abezbm/rusty-unit/evaluation/bytes/rusty-unit-0/src/buf/buf_mut.rs"
}