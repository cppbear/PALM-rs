{
  "system_pt": "As a software testing expert, please generate Rust test functions based on the following guidelines:\n1. Provide the code in plain text format, without explanations or Markdown.\n2. If the method under test belongs to a trait, construct appropriate structs within the test function, but avoid method overrides. If the method under test uses generics, instantiate them with suitable types based on the context.\n3. Generate test code with minimal scope: avoid creating external structures or implementations. Instead, define any necessary helper structures or implementations directly within the test function when required.\n4. Whenever possible, initialize the corresponding data structures using the initialization methods provided in the context if exist.\n5. Ensure the generated function is fully implemented and can be compiled and executed directly without any missing parts.\n6. Create a minimal yet complete set of test functions, ensuring they adhere to all provided preconditions and cover boundary conditions.\n7. Do not create a test module, but include intrinsic attributes like #[test] or #[should_panic] where necessary.\n",
  "static_pt": "// src/bytes.rs\n// crate name is bytes\nThe function to be tested is presented as follows:\n/// Create [Bytes] with a buffer whose lifetime is controlled\n/// via an explicit owner.\n///\n/// A common use case is to zero-copy construct from mapped memory.\n///\n/// ```\n/// # struct File;\n/// #\n/// # impl File {\n/// #     pub fn open(_: &str) -> Result<Self, ()> {\n/// #         Ok(Self)\n/// #     }\n/// # }\n/// #\n/// # mod memmap2 {\n/// #     pub struct Mmap;\n/// #\n/// #     impl Mmap {\n/// #         pub unsafe fn map(_file: &super::File) -> Result<Self, ()> {\n/// #             Ok(Self)\n/// #         }\n/// #     }\n/// #\n/// #     impl AsRef<[u8]> for Mmap {\n/// #         fn as_ref(&self) -> &[u8] {\n/// #             b\"buf\"\n/// #         }\n/// #     }\n/// # }\n/// use bytes::Bytes;\n/// use memmap2::Mmap;\n///\n/// # fn main() -> Result<(), ()> {\n/// let file = File::open(\"upload_bundle.tar.gz\")?;\n/// let mmap = unsafe { Mmap::map(&file) }?;\n/// let b = Bytes::from_owner(mmap);\n/// # Ok(())\n/// # }\n/// ```\n///\n/// The `owner` will be transferred to the constructed [Bytes] object, which\n/// will ensure it is dropped once all remaining clones of the constructed\n/// object are dropped. The owner will then be responsible for dropping the\n/// specified region of memory as part of its [Drop] implementation.\n///\n/// Note that converting [Bytes] constructed from an owner into a [BytesMut]\n/// will always create a deep copy of the buffer into newly allocated memory.\npub fn from_owner<T>(owner: T) -> Self\nwhere\n    T: AsRef<[u8]> + Send + 'static,\n{\n    // Safety & Miri:\n    // The ownership of `owner` is first transferred to the `Owned` wrapper and `Bytes` object.\n    // This ensures that the owner is pinned in memory, allowing us to call `.as_ref()` safely\n    // since the lifetime of the owner is controlled by the lifetime of the new `Bytes` object,\n    // and the lifetime of the resulting borrowed `&[u8]` matches that of the owner.\n    // Note that this remains safe so long as we only call `.as_ref()` once.\n    //\n    // There are some additional special considerations here:\n    //   * We rely on Bytes's Drop impl to clean up memory should `.as_ref()` panic.\n    //   * Setting the `ptr` and `len` on the bytes object last (after moving the owner to\n    //     Bytes) allows Miri checks to pass since it avoids obtaining the `&[u8]` slice\n    //     from a stack-owned Box.\n    // More details on this: https://github.com/tokio-rs/bytes/pull/742/#discussion_r1813375863\n    //                  and: https://github.com/tokio-rs/bytes/pull/742/#discussion_r1813316032\n\n    let owned = Box::into_raw(Box::new(Owned {\n        lifetime: OwnedLifetime {\n            ref_cnt: AtomicUsize::new(1),\n            drop: owned_box_and_drop::<T>,\n        },\n        owner,\n    }));\n\n    let mut ret = Bytes {\n        ptr: NonNull::dangling().as_ptr(),\n        len: 0,\n        data: AtomicPtr::new(owned.cast()),\n        vtable: &OWNED_VTABLE,\n    };\n\n    let buf = unsafe { &*owned }.owner.as_ref();\n    ret.ptr = buf.as_ptr();\n    ret.len = buf.len();\n\n    ret\n}\n",
  "depend_pt": ""
}