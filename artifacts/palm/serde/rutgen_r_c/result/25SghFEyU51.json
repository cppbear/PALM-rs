{"function_name":"serde::de::size_hint::from_bounds","tests":5,"tests_lines":[27,28,27,18,27],"oracles":5,"oracles_compiled":5,"oracles_compiled_rate":100.0,"tests_compiled":5,"tests_compiled_rate":100.0,"oracles_run":5,"oracles_passed":5,"oracles_passed_rate":100.0,"tests_run":5,"tests_passed":5,"tests_passed_rate":100.0,"lines":6,"lines_covered":6,"lines_coveraged_rate":100.0,"branches":1,"branches_covered":1,"branches_coverage_rate":100.0,"codes_lines":[4,5,6,7,8,9],"codes_lines_covered":[[["{","    struct ExactSizeIter {","        current: usize,","        upper: usize,","    }","","    impl Iterator for ExactSizeIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.upper {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.upper - self.current, Some(self.upper - self.current))","        }","    }","","    let iter = ExactSizeIter { current: 0, upper: 5 };","    assert_eq!(from_bounds(&iter), Some(5));","}"],[4,5,6,7,8,9]],[["{","    struct RangeIter {","        start: usize,","        end: usize,","        current: usize,","    }","","    impl Iterator for RangeIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.end {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.end - self.current, Some(self.end - self.current))","        }","    }","","    let iter = RangeIter { start: 0, end: 3, current: 0 };","    assert_eq!(from_bounds(&iter), Some(3));","}"],[4,5,6,7,8,9]],[["{","    struct IncompleteSizeIter {","        current: usize,","        limit: usize,","    }","","    impl Iterator for IncompleteSizeIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.limit {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.limit - self.current, None) // No upper bound","        }","    }","","    let iter = IncompleteSizeIter { current: 0, limit: 5 };","    assert_eq!(from_bounds(&iter), None);","}"],[4,5,6,7,8,9]],[["{","    struct EmptyIter;","","    impl Iterator for EmptyIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            None","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (0, Some(0))","        }","    }","","    let iter = EmptyIter;","    assert_eq!(from_bounds(&iter), Some(0));","}"],[4,5,6,7,8,9]],[["{","    struct LowerUpperDifferentIter {","        current: usize,","        upper: usize,","    }","","    impl Iterator for LowerUpperDifferentIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.upper {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.upper, Some(self.upper + 1)) // Different lower and upper","        }","    }","","    let iter = LowerUpperDifferentIter { current: 0, upper: 5 };","    assert_eq!(from_bounds(&iter), None);","}"],[4,5,6,7,8,9]]],"codes_branches":[],"codes_branches_covered":[[["{","    struct ExactSizeIter {","        current: usize,","        upper: usize,","    }","","    impl Iterator for ExactSizeIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.upper {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.upper - self.current, Some(self.upper - self.current))","        }","    }","","    let iter = ExactSizeIter { current: 0, upper: 5 };","    assert_eq!(from_bounds(&iter), Some(5));","}"],[]],[["{","    struct RangeIter {","        start: usize,","        end: usize,","        current: usize,","    }","","    impl Iterator for RangeIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.end {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.end - self.current, Some(self.end - self.current))","        }","    }","","    let iter = RangeIter { start: 0, end: 3, current: 0 };","    assert_eq!(from_bounds(&iter), Some(3));","}"],[]],[["{","    struct IncompleteSizeIter {","        current: usize,","        limit: usize,","    }","","    impl Iterator for IncompleteSizeIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.limit {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.limit - self.current, None) // No upper bound","        }","    }","","    let iter = IncompleteSizeIter { current: 0, limit: 5 };","    assert_eq!(from_bounds(&iter), None);","}"],[]],[["{","    struct EmptyIter;","","    impl Iterator for EmptyIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            None","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (0, Some(0))","        }","    }","","    let iter = EmptyIter;","    assert_eq!(from_bounds(&iter), Some(0));","}"],[]],[["{","    struct LowerUpperDifferentIter {","        current: usize,","        upper: usize,","    }","","    impl Iterator for LowerUpperDifferentIter {","        type Item = usize;","","        fn next(&mut self) -> Option<Self::Item> {","            if self.current < self.upper {","                let result = Some(self.current);","                self.current += 1;","                result","            } else {","                None","            }","        }","","        fn size_hint(&self) -> (usize, Option<usize>) {","            (self.upper, Some(self.upper + 1)) // Different lower and upper","        }","    }","","    let iter = LowerUpperDifferentIter { current: 0, upper: 5 };","    assert_eq!(from_bounds(&iter), None);","}"],[]]]}