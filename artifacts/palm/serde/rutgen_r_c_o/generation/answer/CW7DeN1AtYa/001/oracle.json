[
  {
    "uses": [],
    "has_test_mod": false,
    "common": [],
    "chain_tests": [
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = 42;",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = 42;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);"
          ],
          [
            "    let value = 42;",
            "    let result = constrain(&value);",
            "    assert!(std::any::TypeId::of::<&i32>() == std::any::TypeId::of_val(result));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = 42;",
            "    constrain(&value);",
            "    let value = 42;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);",
            "}"
          ],
          [
            "{",
            "    let value = 42;",
            "    constrain(&value);",
            "    let value = 42;",
            "    let result = constrain(&value);",
            "    assert!(std::any::TypeId::of::<&i32>() == std::any::TypeId::of_val(result));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = 3.14;",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = 3.14;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = 3.14;",
            "    constrain(&value);",
            "    let value = 3.14;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = String::from(\"Hello\");",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = String::from(\"Hello\");",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);"
          ],
          [
            "    let value = String::from(\"Hello\");",
            "    let result = constrain(&value);",
            "    assert!(std::any::TypeId::of::<&String>() == std::any::TypeId::of_val(result));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = String::from(\"Hello\");",
            "    constrain(&value);",
            "    let value = String::from(\"Hello\");",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);",
            "}"
          ],
          [
            "{",
            "    let value = String::from(\"Hello\");",
            "    constrain(&value);",
            "    let value = String::from(\"Hello\");",
            "    let result = constrain(&value);",
            "    assert!(std::any::TypeId::of::<&String>() == std::any::TypeId::of_val(result));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    struct TestStruct {",
          "        number: i32,",
          "    }",
          "    let value = TestStruct { number: 10 };",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = TestStruct { number: 10 };",
            "    let result = constrain(&value);",
            "    assert_eq!(result.number, 10);"
          ]
        ],
        "codes": [
          [
            "{",
            "    struct TestStruct {",
            "        number: i32,",
            "    }",
            "    let value = TestStruct { number: 10 };",
            "    constrain(&value);",
            "    let value = TestStruct { number: 10 };",
            "    let result = constrain(&value);",
            "    assert_eq!(result.number, 10);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    enum TestEnum {",
          "        VariantA,",
          "        VariantB,",
          "    }",
          "    let value = TestEnum::VariantA;",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = TestEnum::VariantA;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);"
          ],
          [
            "    let value = TestEnum::VariantA;",
            "    let result = constrain(&value);",
            "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(&value));"
          ],
          [
            "    let value = TestEnum::VariantA;",
            "    let result = constrain(&value);",
            "    assert!(std::ptr::eq(result, &value));"
          ]
        ],
        "codes": [
          [
            "{",
            "    enum TestEnum {",
            "        VariantA,",
            "        VariantB,",
            "    }",
            "    let value = TestEnum::VariantA;",
            "    constrain(&value);",
            "    let value = TestEnum::VariantA;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);",
            "}"
          ],
          [
            "{",
            "    enum TestEnum {",
            "        VariantA,",
            "        VariantB,",
            "    }",
            "    let value = TestEnum::VariantA;",
            "    constrain(&value);",
            "    let value = TestEnum::VariantA;",
            "    let result = constrain(&value);",
            "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(&value));",
            "}"
          ],
          [
            "{",
            "    enum TestEnum {",
            "        VariantA,",
            "        VariantB,",
            "    }",
            "    let value = TestEnum::VariantA;",
            "    constrain(&value);",
            "    let value = TestEnum::VariantA;",
            "    let result = constrain(&value);",
            "    assert!(std::ptr::eq(result, &value));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: Option<i32> = None;",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value: Option<i32> = None;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);"
          ],
          [
            "    let value: Option<i32> = None;",
            "    let result = constrain(&value);",
            "    assert!(result.is_none());"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value: Option<i32> = None;",
            "    constrain(&value);",
            "    let value: Option<i32> = None;",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);",
            "}"
          ],
          [
            "{",
            "    let value: Option<i32> = None;",
            "    constrain(&value);",
            "    let value: Option<i32> = None;",
            "    let result = constrain(&value);",
            "    assert!(result.is_none());",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value: Option<&i32> = None;",
          "    constrain(value.as_ref().unwrap_or(&0)); // uses default value to avoid panic",
          "}"
        ],
        "oracles": [
          [
            "    let value: Option<&i32> = None;",
            "    let result = constrain(value.as_ref().unwrap_or(&0));",
            "    assert_eq!(result, &0);"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value: Option<&i32> = None;",
            "    constrain(value.as_ref().unwrap_or(&0)); // uses default value to avoid panic",
            "    let value: Option<&i32> = None;",
            "    let result = constrain(value.as_ref().unwrap_or(&0));",
            "    assert_eq!(result, &0);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          }
        ],
        "repaired": [
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = [1, 2, 3];",
          "    constrain(&value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = [1, 2, 3];",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);"
          ],
          [
            "    let value = [1, 2, 3];",
            "    let result = constrain(&value);",
            "    assert!(std::any::TypeId::of::<&[i32]>() == std::any::TypeId::of_val(result));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = [1, 2, 3];",
            "    constrain(&value);",
            "    let value = [1, 2, 3];",
            "    let result = constrain(&value);",
            "    assert_eq!(result, &value);",
            "}"
          ],
          [
            "{",
            "    let value = [1, 2, 3];",
            "    constrain(&value);",
            "    let value = [1, 2, 3];",
            "    let result = constrain(&value);",
            "    assert!(std::any::TypeId::of::<&[i32]>() == std::any::TypeId::of_val(result));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    let value = &[4, 5, 6];",
          "    constrain(value);",
          "}"
        ],
        "oracles": [
          [
            "    let value = &[4, 5, 6];",
            "    let result = constrain(value);",
            "    assert_eq!(result, value);"
          ],
          [
            "    let value = &[4, 5, 6];",
            "    let result = constrain(value);",
            "    assert!(std::ptr::eq(result, value));"
          ],
          [
            "    let value = &[4, 5, 6];",
            "    let result = constrain(value);",
            "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(value));"
          ]
        ],
        "codes": [
          [
            "{",
            "    let value = &[4, 5, 6];",
            "    constrain(value);",
            "    let value = &[4, 5, 6];",
            "    let result = constrain(value);",
            "    assert_eq!(result, value);",
            "}"
          ],
          [
            "{",
            "    let value = &[4, 5, 6];",
            "    constrain(value);",
            "    let value = &[4, 5, 6];",
            "    let result = constrain(value);",
            "    assert!(std::ptr::eq(result, value));",
            "}"
          ],
          [
            "{",
            "    let value = &[4, 5, 6];",
            "    constrain(value);",
            "    let value = &[4, 5, 6];",
            "    let result = constrain(value);",
            "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(value));",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false,
          false
        ]
      },
      {
        "attrs": [],
        "prefix": [
          "{",
          "    trait MyTrait {}",
          "    struct MyStruct;",
          "    impl MyTrait for MyStruct {}",
          "    let value: &dyn MyTrait = &MyStruct;",
          "    constrain(value);",
          "}"
        ],
        "oracles": [
          [
            "    let value: &dyn MyTrait = &MyStruct;",
            "    assert_eq!(std::any::type_name_of_val(value), \"MyStruct\");"
          ],
          [
            "    let value: &dyn MyTrait = &MyStruct;",
            "    assert_eq!(constrain(value), value);"
          ]
        ],
        "codes": [
          [
            "{",
            "    trait MyTrait {}",
            "    struct MyStruct;",
            "    impl MyTrait for MyStruct {}",
            "    let value: &dyn MyTrait = &MyStruct;",
            "    constrain(value);",
            "    let value: &dyn MyTrait = &MyStruct;",
            "    assert_eq!(std::any::type_name_of_val(value), \"MyStruct\");",
            "}"
          ],
          [
            "{",
            "    trait MyTrait {}",
            "    struct MyStruct;",
            "    impl MyTrait for MyStruct {}",
            "    let value: &dyn MyTrait = &MyStruct;",
            "    constrain(value);",
            "    let value: &dyn MyTrait = &MyStruct;",
            "    assert_eq!(constrain(value), value);",
            "}"
          ]
        ],
        "can_compile": [
          {
            "Ok": null
          },
          {
            "Ok": null
          }
        ],
        "repaired": [
          false,
          false
        ]
      }
    ]
  }
]