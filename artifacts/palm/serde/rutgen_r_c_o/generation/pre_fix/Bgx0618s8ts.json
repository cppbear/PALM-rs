{
  "name": "serde::de::value::private::<de::value::private::UnitOnly<E> as de::VariantAccess<'de>>::struct_variant",
  "name_with_impl": "serde::de::value::private::{impl#0}::struct_variant",
  "mod_info": {
    "name": "de::value::private",
    "loc": "serde/src/de/value.rs:1730:1:1894:2"
  },
  "visible": true,
  "loc": "serde/src/de/value.rs:1780:9:1792:10",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: Err(de::Error::invalid_type(\n                Unexpected::UnitVariant,\n                &\"struct variant\",\n            ))\n"
      ],
      "input_infer": "_fields: &'static [&'static str] = &[\"field1\", \"field2\"]; _visitor: V where V: de::Visitor<'de>, _fields length: 2 to 10\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [
            "struct MyVisitor;",
            "",
            "impl<'de> Visitor<'de> for MyVisitor {",
            "    type Value = ();",
            "",
            "    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {",
            "        formatter.write_str(\"any valid value\")",
            "    }",
            "",
            "    fn visit_unit<E>(self) -> Result<Self::Value, E> where E: de::Error {",
            "        Err(E::custom(\"unexpected value\"))",
            "    }",
            "}",
            "",
            "struct MyError; ",
            "impl de::Error for MyError {",
            "    fn custom<T>(_msg: T) -> Self {",
            "        MyError",
            "    }",
            "",
            "    fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {",
            "        MyError",
            "    }",
            "}"
          ],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0599]: no method named `invalid_type` found for struct `MyError` in the current scope\n    --> serde/src/de/value.rs:1935:36\n     |\n1913 | struct MyError; \n     | -------------- method `invalid_type` not found for this struct\n...\n1935 |     assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);\n     |                                    ^^^^^^^^^^^^ method not found in `MyError`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nhelp: trait `Error` which provides `invalid_type` is implemented but not in scope; perhaps you want to import it\n     |\n1897 +    use crate::de::Error;\n     |\n\nSome errors have detailed explanations: E0053, E0277, E0599.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 4 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0599]: no method named `invalid_type` found for struct `MyError` in the current scope\n    --> serde/src/de/value.rs:1935:36\n     |\n1913 | struct MyError; \n     | -------------- method `invalid_type` not found for this struct\n...\n1935 |     assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);\n     |                                    ^^^^^^^^^^^^ method not found in `MyError`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nhelp: trait `Error` which provides `invalid_type` is implemented but not in scope; perhaps you want to import it\n     |\n1897 +    use crate::de::Error;\n     |\n\nSome errors have detailed explanations: E0053, E0277, E0599.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 4 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(result.unwrap_err() == MyError);"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(matches!(result.unwrap_err(), MyError));"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(matches!(result, Err(MyError)));"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert_eq!(format!(\"{:?}\", result), \"Err(MyError)\");"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(result.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(result.unwrap_err() == MyError);",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(matches!(result.unwrap_err(), MyError));",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(matches!(result, Err(MyError)));",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert_eq!(format!(\"{:?}\", result), \"Err(MyError)\");",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(ref e) => { assert_eq!(e, &MyError); }",
                  "    _ => panic!(\"Expected an error\")",
                  "    }",
                  "    assert!(result.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `&MyError`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^\n     |                     |\n     |                     &MyError\n     |                     &MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `&MyError: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1939:33\n     |\n1939 |     assert!(result.unwrap_err() == MyError);\n     |             ------------------- ^^ ------- MyError\n     |             |\n     |             MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `&MyError`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^\n     |                     |\n     |                     &MyError\n     |                     &MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `&MyError: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `&MyError`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^\n     |                     |\n     |                     &MyError\n     |                     &MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `&MyError: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `&MyError`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^\n     |                     |\n     |                     &MyError\n     |                     &MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `&MyError: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1939:32\n     |\n1939 |     assert_eq!(format!(\"{:?}\", result), \"Err(MyError)\");\n     |                                ^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `Result<(), MyError>: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = help: the trait `std::fmt::Debug` is implemented for `Result<T, E>`\n     = note: this error originates in the macro `$crate::__export::format_args` which comes from the expansion of the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `&MyError`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^\n     |                     |\n     |                     &MyError\n     |                     &MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `&MyError: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nerror[E0599]: no method named `invalid_type` found for struct `MyError` in the current scope\n    --> serde/src/de/value.rs:1939:36\n     |\n1913 | struct MyError; \n     | -------------- method `invalid_type` not found for this struct\n...\n1939 |     assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, \"struct variant\"), MyError);\n     |                                    ^^^^^^^^^^^^ method not found in `MyError`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nhelp: trait `Error` which provides `invalid_type` is implemented but not in scope; perhaps you want to import it\n     |\n1897 +    use crate::de::Error;\n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369, E0599.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 7 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `&MyError`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^\n     |                     |\n     |                     &MyError\n     |                     &MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:21\n     |\n1936 |     Err(ref e) => { assert_eq!(e, &MyError); }\n     |                     ^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`, which is required by `&MyError: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, &\"struct variant\"), MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, &\"struct variant\"), MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0599]: no method named `invalid_type` found for struct `MyError` in the current scope\n    --> serde/src/de/value.rs:1935:36\n     |\n1913 | struct MyError; \n     | -------------- method `invalid_type` not found for this struct\n...\n1935 |     assert_eq!(result.unwrap_err().invalid_type(Unexpected::UnitVariant, &\"struct variant\"), MyError);\n     |                                    ^^^^^^^^^^^^ method not found in `MyError`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nhelp: trait `Error` which provides `invalid_type` is implemented but not in scope; perhaps you want to import it\n     |\n1897 +    use crate::de::Error;\n     |\n\nSome errors have detailed explanations: E0053, E0277, E0599.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 4 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error, MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    let error = result.unwrap_err();",
                  "    assert_eq!(error, MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1936:5\n     |\n1936 |     assert_eq!(error, MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1936:5\n     |\n1936 |     assert_eq!(error, MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert_eq!(result.unwrap_err(), MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nerror[E0369]: binary operation `==` cannot be applied to type `MyError`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     MyError\n     |     MyError\n     |\nnote: an implementation of `PartialEq` might be missing for `MyError`\n    --> serde/src/de/value.rs:1913:1\n     |\n1913 | struct MyError; \n     | ^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(PartialEq)]`\n     |\n1913 + #[derive(PartialEq)]\n1914 | struct MyError; \n     |\n\nerror[E0277]: `MyError` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1935:5\n     |\n1935 |     assert_eq!(result.unwrap_err(), MyError);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `MyError` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `MyError`\n     = note: add `#[derive(Debug)]` to `MyError` or manually `impl std::fmt::Debug for MyError`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `MyError` with `#[derive(Debug)]`\n     |\n1913 + #[derive(Debug)]\n1914 | struct MyError; \n     |\n\nSome errors have detailed explanations: E0053, E0277, E0369.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 6 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                "    let visitor = MyVisitor {};",
                "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                "    let _ = unit_only.struct_variant(fields, visitor);",
                "}"
              ],
              "oracles": [
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(e) => {",
                  "    assert_eq!(e, MyError);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let _ = unit_only.struct_variant(fields, visitor);",
                  "    let fields = &[\"field1\", \"field2\", \"field3\", \"field4\", \"field5\", \"field6\", \"field7\", \"field8\", \"field9\", \"field10\"];",
                  "    let visitor = MyVisitor {};",
                  "    let unit_only = UnitOnly::<MyError> { marker: PhantomData };",
                  "    let result = unit_only.struct_variant(fields, visitor);",
                  "    match result {",
                  "    Err(e) => {",
                  "    assert_eq!(e, MyError);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: unused import: `ntest::timeout`\n    --> serde/src/de/value.rs:1898:8\n     |\n1898 |    use ntest::timeout;\n     |        ^^^^^^^^^^^^^^\n     |\nnote: the lint level is defined here\n    --> serde/src/lib.rs:159:23\n     |\n159  | #![deny(missing_docs, unused_imports)]\n     |                       ^^^^^^^^^^^^^^\n\nerror[E0277]: the trait bound `MyError: std::error::Error` is not satisfied\n    --> serde/src/de/value.rs:1914:20\n     |\n1914 | impl de::Error for MyError {\n     |                    ^^^^^^^ the trait `std::error::Error` is not implemented for `MyError`\n     |\nnote: required by a bound in `de::Error`\n    --> serde/src/de/mod.rs:161:38\n     |\n161  |         pub trait Error: Sized $(+ $($supertrait)::+)* {\n     |                                      ^^^^^^^^^^^ required by this bound in `Error`\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0053]: method `invalid_type` has an incompatible type for trait\n    --> serde/src/de/value.rs:1919:57\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &'static str) -> Self {\n     |                                                         ^^^^^^^^^^^^ expected `dyn Expected`, found `str`\n     |\nnote: type in trait\n    --> serde/src/de/mod.rs:209:53\n     |\n209  |             fn invalid_type(unexp: Unexpected, exp: &dyn Expected) -> Self {\n     |                                                     ^^^^^^^^^^^^^\n...\n300  | declare_error_trait!(Error: Sized + StdError);\n     | --------------------------------------------- in this macro invocation\n     = note: expected signature `fn(de::Unexpected<'_>, &dyn Expected) -> MyError`\n                found signature `fn(de::Unexpected<'_>, &'static str) -> MyError`\n     = help: `str` implements `Expected` so you could box the found value and coerce it to the trait object `Box<dyn Expected>`, you will have to change the expected type as well\n     = note: this error originates in the macro `declare_error_trait` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: change the parameter type to match the trait\n     |\n1919 |     fn invalid_type(_unexpected: Unexpected, _expected: &dyn Expected) -> Self {\n     |                                                         ~~~~~~~~~~~~~\n\nSome errors have detailed explanations: E0053, E0277.\nFor more information about an error, try `rustc --explain E0053`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Err": "   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling serde_derive v1.0.219 (/home/utgen/workspace/serde/serde_derive)\n   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\n   Compiling quote v1.0.40\n   Compiling syn v2.0.100\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\nerror: this file contains an unclosed delimiter\n    --> serde/src/de/value.rs:1940:2\n     |\n1730 | mod private {\n     |             - unclosed delimiter\n...\n1896 | mod llmtests {\n     |              - unclosed delimiter\n...\n1940 | }\n     |  ^\n\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}