{
  "system_pt": "As a software testing expert, infer the test input ranges based on the provided information. Follow these guidelines:\n1. Provide test input ranges in one line in plain text only, without additional explanations or Markdown formatting.\n2. The inferred test input ranges should only satisfy all provided constraints simultaneously.\n3. Ensure the test input ranges cover boundary cases and edge scenarios.\n",
  "static_pt": "The context for the focal function is as follows:\n// serde/src/private/de.rs\n// crate name is serde\nuse crate::lib::*;\nuse crate::actually_private;\nuse crate::de::value::{MapDeserializer, SeqDeserializer};\nuse crate::de::{\n    self, size_hint, Deserialize, DeserializeSeed, Deserializer, EnumAccess, Expected,\n    IgnoredAny, MapAccess, SeqAccess, Unexpected, Visitor,\n};\npub trait Deserializer<'de>: Sized {\n    type Error: Error;\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_i128<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let _ = visitor;\n        Err(Error::custom(\"i128 is not supported\"))\n    }\n    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_u128<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let _ = visitor;\n        Err(Error::custom(\"u128 is not supported\"))\n    }\n    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_unit_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_newtype_struct<V>(\n        self,\n        name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_tuple<V>(\n        self,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_tuple_struct<V>(\n        self,\n        name: &'static str,\n        len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_struct<V>(\n        self,\n        name: &'static str,\n        fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_enum<V>(\n        self,\n        name: &'static str,\n        variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>;\n    #[inline]\n    fn is_human_readable(&self) -> bool {\n        true\n    }\n    #[cfg(all(not(no_serde_derive), any(feature = \"std\", feature = \"alloc\")))]\n    fn __deserialize_content<V>(\n        self,\n        _: crate::actually_private::T,\n        visitor: V,\n    ) -> Result<crate::__private::de::Content<'de>, Self::Error>\n    where\n        V: Visitor<'de, Value = crate::__private::de::Content<'de>>,\n    {\n        self.deserialize_any(visitor)\n    }\n}\npub trait IntoDeserializer<'de, E: Error = value::Error> {\n    type Deserializer: Deserializer<'de, Error = E>;\n    fn into_deserializer(self) -> Self::Deserializer;\n}\npub struct ContentDeserializer<'de, E> {\n    content: Content<'de>,\n    err: PhantomData<E>,\n}\npub enum Content {\n    Bool(bool),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n    Bytes(Vec<u8>),\n    None,\n    Some(Box<Content>),\n    Unit,\n    UnitStruct(&'static str),\n    UnitVariant(&'static str, u32, &'static str),\n    NewtypeStruct(&'static str, Box<Content>),\n    NewtypeVariant(&'static str, u32, &'static str, Box<Content>),\n    Seq(Vec<Content>),\n    Tuple(Vec<Content>),\n    TupleStruct(&'static str, Vec<Content>),\n    TupleVariant(&'static str, u32, &'static str, Vec<Content>),\n    Map(Vec<(Content, Content)>),\n    Struct(&'static str, Vec<(&'static str, Content)>),\n    StructVariant(&'static str, u32, &'static str, Vec<(&'static str, Content)>),\n}\n#[derive(Debug, Clone)]\npub enum Content<'de> {\n    Bool(bool),\n    U8(u8),\n    U16(u16),\n    U32(u32),\n    U64(u64),\n    I8(i8),\n    I16(i16),\n    I32(i32),\n    I64(i64),\n    F32(f32),\n    F64(f64),\n    Char(char),\n    String(String),\n    Str(&'de str),\n    ByteBuf(Vec<u8>),\n    Bytes(&'de [u8]),\n    None,\n    Some(Box<Content<'de>>),\n    Unit,\n    Newtype(Box<Content<'de>>),\n    Seq(Vec<Content<'de>>),\n    Map(Vec<(Content<'de>, Content<'de>)>),\n}\nimpl<'de, E> Deserializer<'de> for ContentDeserializer<'de, E>\nwhere\n    E: de::Error,\n{\n    type Error = E;\n    fn deserialize_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Bool(v) => visitor.visit_bool(v),\n            Content::U8(v) => visitor.visit_u8(v),\n            Content::U16(v) => visitor.visit_u16(v),\n            Content::U32(v) => visitor.visit_u32(v),\n            Content::U64(v) => visitor.visit_u64(v),\n            Content::I8(v) => visitor.visit_i8(v),\n            Content::I16(v) => visitor.visit_i16(v),\n            Content::I32(v) => visitor.visit_i32(v),\n            Content::I64(v) => visitor.visit_i64(v),\n            Content::F32(v) => visitor.visit_f32(v),\n            Content::F64(v) => visitor.visit_f64(v),\n            Content::Char(v) => visitor.visit_char(v),\n            Content::String(v) => visitor.visit_string(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            Content::Unit => visitor.visit_unit(),\n            Content::None => visitor.visit_none(),\n            Content::Some(v) => visitor.visit_some(ContentDeserializer::new(*v)),\n            Content::Newtype(v) => {\n                visitor.visit_newtype_struct(ContentDeserializer::new(*v))\n            }\n            Content::Seq(v) => visit_content_seq(v, visitor),\n            Content::Map(v) => visit_content_map(v, visitor),\n        }\n    }\n    fn deserialize_bool<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Bool(v) => visitor.visit_bool(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_i8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_i16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_i32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_i64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u8<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u16<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_u64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_integer(visitor)\n    }\n    fn deserialize_f32<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_float(visitor)\n    }\n    fn deserialize_f64<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_float(visitor)\n    }\n    fn deserialize_char<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Char(v) => visitor.visit_char(v),\n            Content::String(v) => visitor.visit_string(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_str<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_string(visitor)\n    }\n    fn deserialize_string<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::String(v) => visitor.visit_string(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_bytes<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_byte_buf(visitor)\n    }\n    fn deserialize_byte_buf<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::String(v) => visitor.visit_string(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            Content::Seq(v) => visit_content_seq(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_option<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::None => visitor.visit_none(),\n            Content::Some(v) => visitor.visit_some(ContentDeserializer::new(*v)),\n            Content::Unit => visitor.visit_unit(),\n            _ => visitor.visit_some(self),\n        }\n    }\n    fn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Unit => visitor.visit_unit(),\n            Content::Map(ref v) if v.is_empty() => visitor.visit_unit(),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_unit_struct<V>(\n        self,\n        _name: &'static str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Map(ref v) if v.is_empty() => visitor.visit_unit(),\n            Content::Seq(ref v) if v.is_empty() => visitor.visit_unit(),\n            _ => self.deserialize_any(visitor),\n        }\n    }\n    fn deserialize_newtype_struct<V>(\n        self,\n        _name: &str,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Newtype(v) => {\n                visitor.visit_newtype_struct(ContentDeserializer::new(*v))\n            }\n            _ => visitor.visit_newtype_struct(self),\n        }\n    }\n    fn deserialize_seq<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Seq(v) => visit_content_seq(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_tuple<V>(\n        self,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n    fn deserialize_tuple_struct<V>(\n        self,\n        _name: &'static str,\n        _len: usize,\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        self.deserialize_seq(visitor)\n    }\n    fn deserialize_map<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Map(v) => visit_content_map(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_struct<V>(\n        self,\n        _name: &'static str,\n        _fields: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::Seq(v) => visit_content_seq(v, visitor),\n            Content::Map(v) => visit_content_map(v, visitor),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_enum<V>(\n        self,\n        _name: &str,\n        _variants: &'static [&'static str],\n        visitor: V,\n    ) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        let (variant, value) = match self.content {\n            Content::Map(value) => {\n                let mut iter = value.into_iter();\n                let (variant, value) = match iter.next() {\n                    Some(v) => v,\n                    None => {\n                        return Err(\n                            de::Error::invalid_value(\n                                de::Unexpected::Map,\n                                &\"map with a single key\",\n                            ),\n                        );\n                    }\n                };\n                if iter.next().is_some() {\n                    return Err(\n                        de::Error::invalid_value(\n                            de::Unexpected::Map,\n                            &\"map with a single key\",\n                        ),\n                    );\n                }\n                (variant, Some(value))\n            }\n            s @ Content::String(_) | s @ Content::Str(_) => (s, None),\n            other => {\n                return Err(\n                    de::Error::invalid_type(other.unexpected(), &\"string or map\"),\n                );\n            }\n        };\n        visitor.visit_enum(EnumDeserializer::new(variant, value))\n    }\n    fn deserialize_identifier<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        match self.content {\n            Content::String(v) => visitor.visit_string(v),\n            Content::Str(v) => visitor.visit_borrowed_str(v),\n            Content::ByteBuf(v) => visitor.visit_byte_buf(v),\n            Content::Bytes(v) => visitor.visit_borrowed_bytes(v),\n            Content::U8(v) => visitor.visit_u8(v),\n            Content::U64(v) => visitor.visit_u64(v),\n            _ => Err(self.invalid_type(&visitor)),\n        }\n    }\n    fn deserialize_ignored_any<V>(self, visitor: V) -> Result<V::Value, Self::Error>\n    where\n        V: Visitor<'de>,\n    {\n        drop(self);\n        visitor.visit_unit()\n    }\n    fn __deserialize_content<V>(\n        self,\n        _: actually_private::T,\n        visitor: V,\n    ) -> Result<Content<'de>, Self::Error>\n    where\n        V: Visitor<'de, Value = Content<'de>>,\n    {\n        let _ = visitor;\n        Ok(self.content)\n    }\n}\nimpl<'de, E> ContentDeserializer<'de, E>\nwhere\n    E: de::Error,\n{\n    #[cold]\n    fn invalid_type(self, exp: &dyn Expected) -> E {\n        de::Error::invalid_type(self.content.unexpected(), exp)\n    }\n    fn deserialize_integer<V>(self, visitor: V) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n    {}\n    fn deserialize_float<V>(self, visitor: V) -> Result<V::Value, E>\n    where\n        V: Visitor<'de>,\n    {}\n}\n\nThe function to be tested is presented as follows:\nfn deserialize_unit<V>(self, visitor: V) -> Result<V::Value, Self::Error>\nwhere\n    V: Visitor<'de>,\n{\n    match self.content {\n        Content::Unit => visitor.visit_unit(),\n\n        // Allow deserializing newtype variant containing unit.\n        //\n        //     #[derive(Deserialize)]\n        //     #[serde(tag = \"result\")]\n        //     enum Response<T> {\n        //         Success(T),\n        //     }\n        //\n        // We want {\"result\":\"Success\"} to deserialize into Response<()>.\n        Content::Map(ref v) if v.is_empty() => visitor.visit_unit(),\n        _ => Err(self.invalid_type(&visitor)),\n    }\n}\nGiven the following constraints, potential panic-triggering statements, and expected return values/types (all extracted from the function under test).\nGenerate test inputs that maximize the function's runtime satisfaction of all constraints and expected outputs while considering panic conditions:\n",
  "depend_pt": ""
}