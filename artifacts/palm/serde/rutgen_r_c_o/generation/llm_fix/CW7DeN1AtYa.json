{
  "name": "serde::__private::ser::constrain",
  "name_with_impl": "serde::__private::ser::constrain",
  "mod_info": {
    "name": "__private::ser",
    "loc": "serde/src/private/mod.rs:4:1:4:13"
  },
  "visible": true,
  "loc": "serde/src/private/ser.rs:12:1:14:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: t\n"
      ],
      "input_infer": "test input ranges: any reference to type T, including valid references to structs, enums, and primitive types; must allow for null values and must not exceed the size limitations of the target system.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = 42;",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = 42;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);"
                ],
                [
                  "    let value = 42;",
                  "    let result = constrain(&value);",
                  "    assert!(std::any::TypeId::of::<&i32>() == std::any::TypeId::of_val(result));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value = 42;",
                  "    constrain(&value);",
                  "    let value = 42;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);",
                  "}"
                ],
                [
                  "{",
                  "    let value = 42;",
                  "    constrain(&value);",
                  "    let value = 42;",
                  "    let result = constrain(&value);",
                  "    assert!(std::any::TypeId::of::<&i32>() == std::any::TypeId::of_val(result));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no function or associated item named `of_val` found for struct `TypeId` in the current scope\n    --> serde/src/private/ser.rs:1377:65\n     |\n1377 |     assert!(std::any::TypeId::of::<&i32>() == std::any::TypeId::of_val(result));\n     |                                                                 ^^^^^^ function or associated item not found in `TypeId`\n     |\nnote: if you're trying to build a new `TypeId`, consider using `TypeId::of` which returns `TypeId`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/any.rs:640:5\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = 3.14;",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = 3.14;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value = 3.14;",
                  "    constrain(&value);",
                  "    let value = 3.14;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = String::from(\"Hello\");",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = String::from(\"Hello\");",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);"
                ],
                [
                  "    let value = String::from(\"Hello\");",
                  "    let result = constrain(&value);",
                  "    assert!(std::any::TypeId::of::<&String>() == std::any::TypeId::of_val(result));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value = String::from(\"Hello\");",
                  "    constrain(&value);",
                  "    let value = String::from(\"Hello\");",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);",
                  "}"
                ],
                [
                  "{",
                  "    let value = String::from(\"Hello\");",
                  "    constrain(&value);",
                  "    let value = String::from(\"Hello\");",
                  "    let result = constrain(&value);",
                  "    assert!(std::any::TypeId::of::<&String>() == std::any::TypeId::of_val(result));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no function or associated item named `of_val` found for struct `TypeId` in the current scope\n    --> serde/src/private/ser.rs:1377:68\n     |\n1377 |     assert!(std::any::TypeId::of::<&String>() == std::any::TypeId::of_val(result));\n     |                                                                    ^^^^^^ function or associated item not found in `TypeId`\n     |\nnote: if you're trying to build a new `TypeId`, consider using `TypeId::of` which returns `TypeId`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/any.rs:640:5\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct TestStruct {",
                "        number: i32,",
                "    }",
                "    let value = TestStruct { number: 10 };",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = TestStruct { number: 10 };",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result.number, 10);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct TestStruct {",
                  "        number: i32,",
                  "    }",
                  "    let value = TestStruct { number: 10 };",
                  "    constrain(&value);",
                  "    let value = TestStruct { number: 10 };",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result.number, 10);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    enum TestEnum {",
                "        VariantA,",
                "        VariantB,",
                "    }",
                "    let value = TestEnum::VariantA;",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = TestEnum::VariantA;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);"
                ],
                [
                  "    let value = TestEnum::VariantA;",
                  "    let result = constrain(&value);",
                  "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(&value));"
                ],
                [
                  "    let value = TestEnum::VariantA;",
                  "    let result = constrain(&value);",
                  "    assert!(std::ptr::eq(result, &value));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    enum TestEnum {",
                  "        VariantA,",
                  "        VariantB,",
                  "    }",
                  "    let value = TestEnum::VariantA;",
                  "    constrain(&value);",
                  "    let value = TestEnum::VariantA;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);",
                  "}"
                ],
                [
                  "{",
                  "    enum TestEnum {",
                  "        VariantA,",
                  "        VariantB,",
                  "    }",
                  "    let value = TestEnum::VariantA;",
                  "    constrain(&value);",
                  "    let value = TestEnum::VariantA;",
                  "    let result = constrain(&value);",
                  "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(&value));",
                  "}"
                ],
                [
                  "{",
                  "    enum TestEnum {",
                  "        VariantA,",
                  "        VariantB,",
                  "    }",
                  "    let value = TestEnum::VariantA;",
                  "    constrain(&value);",
                  "    let value = TestEnum::VariantA;",
                  "    let result = constrain(&value);",
                  "    assert!(std::ptr::eq(result, &value));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `&TestEnum`\n    --> serde/src/private/ser.rs:1381:5\n     |\n1381 |     assert_eq!(result, &value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     &TestEnum\n     |     &TestEnum\n     |\nnote: an implementation of `PartialEq` might be missing for `TestEnum`\n    --> serde/src/private/ser.rs:1373:5\n     |\n1373 |     enum TestEnum {\n     |     ^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestEnum` with `#[derive(PartialEq)]`\n     |\n1373 +     #[derive(PartialEq)]\n1374 |     enum TestEnum {\n     |\n\nerror[E0277]: `TestEnum` doesn't implement `std::fmt::Debug`\n    --> serde/src/private/ser.rs:1381:5\n     |\n1381 |     assert_eq!(result, &value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ `TestEnum` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `TestEnum`, which is required by `&TestEnum: std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `TestEnum` or manually `impl std::fmt::Debug for TestEnum`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `TestEnum` with `#[derive(Debug)]`\n     |\n1373 +     #[derive(Debug)]\n1374 |     enum TestEnum {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: Option<i32> = None;",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value: Option<i32> = None;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);"
                ],
                [
                  "    let value: Option<i32> = None;",
                  "    let result = constrain(&value);",
                  "    assert!(result.is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value: Option<i32> = None;",
                  "    constrain(&value);",
                  "    let value: Option<i32> = None;",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);",
                  "}"
                ],
                [
                  "{",
                  "    let value: Option<i32> = None;",
                  "    constrain(&value);",
                  "    let value: Option<i32> = None;",
                  "    let result = constrain(&value);",
                  "    assert!(result.is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value: Option<&i32> = None;",
                "    constrain(value.as_ref().unwrap_or(&0)); // uses default value to avoid panic",
                "}"
              ],
              "oracles": [
                [
                  "    let value: Option<&i32> = None;",
                  "    let result = constrain(value.as_ref().unwrap_or(&0));",
                  "    assert_eq!(result, &0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value: Option<&i32> = None;",
                  "    constrain(value.as_ref().unwrap_or(&0)); // uses default value to avoid panic",
                  "    let value: Option<&i32> = None;",
                  "    let result = constrain(value.as_ref().unwrap_or(&0));",
                  "    assert_eq!(result, &0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0308]: mismatched types\n    --> serde/src/private/ser.rs:1374:40\n     |\n1374 |     constrain(value.as_ref().unwrap_or(&0)); // uses default value to avoid panic\n     |                              --------- ^^ expected `&&i32`, found `&{integer}`\n     |                              |\n     |                              arguments to this method are incorrect\n     |\n     = note: expected reference `&&i32`\n                found reference `&{integer}`\nhelp: the return type of this call is `&{integer}` due to the type of the argument passed\n    --> serde/src/private/ser.rs:1374:15\n     |\n1374 |     constrain(value.as_ref().unwrap_or(&0)); // uses default value to avoid panic\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^--^\n     |                                        |\n     |                                        this argument influences the return type of `unwrap_or`\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/option.rs:990:12\nhelp: use `Option::map_or` to deref inner value of `Option`\n     |\n1374 |     constrain(value.as_ref().map_or(&0, |v| v)); // uses default value to avoid panic\n     |                              ~~~~~~   +++++++\n\nerror[E0308]: mismatched types\n    --> serde/src/private/ser.rs:1376:53\n     |\n1376 |     let result = constrain(value.as_ref().unwrap_or(&0));\n     |                                           --------- ^^ expected `&&i32`, found `&{integer}`\n     |                                           |\n     |                                           arguments to this method are incorrect\n     |\n     = note: expected reference `&&i32`\n                found reference `&{integer}`\nhelp: the return type of this call is `&{integer}` due to the type of the argument passed\n    --> serde/src/private/ser.rs:1376:28\n     |\n1376 |     let result = constrain(value.as_ref().unwrap_or(&0));\n     |                            ^^^^^^^^^^^^^^^^^^^^^^^^^--^\n     |                                                     |\n     |                                                     this argument influences the return type of `unwrap_or`\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/option.rs:990:12\nhelp: use `Option::map_or` to deref inner value of `Option`\n     |\n1376 |     let result = constrain(value.as_ref().map_or(&0, |v| v));\n     |                                           ~~~~~~   +++++++\n\nerror[E0277]: can't compare `&i32` with `{integer}`\n    --> serde/src/private/ser.rs:1377:5\n     |\n1377 |     assert_eq!(result, &0);\n     |     ^^^^^^^^^^^^^^^^^^^^^^ no implementation for `&i32 == {integer}`\n     |\n     = help: the trait `PartialEq<{integer}>` is not implemented for `&i32`, which is required by `&&i32: PartialEq<&{integer}>`\n     = note: required for `&&i32` to implement `PartialEq<&{integer}>`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = [1, 2, 3];",
                "    constrain(&value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = [1, 2, 3];",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);"
                ],
                [
                  "    let value = [1, 2, 3];",
                  "    let result = constrain(&value);",
                  "    assert!(std::any::TypeId::of::<&[i32]>() == std::any::TypeId::of_val(result));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value = [1, 2, 3];",
                  "    constrain(&value);",
                  "    let value = [1, 2, 3];",
                  "    let result = constrain(&value);",
                  "    assert_eq!(result, &value);",
                  "}"
                ],
                [
                  "{",
                  "    let value = [1, 2, 3];",
                  "    constrain(&value);",
                  "    let value = [1, 2, 3];",
                  "    let result = constrain(&value);",
                  "    assert!(std::any::TypeId::of::<&[i32]>() == std::any::TypeId::of_val(result));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0599]: no function or associated item named `of_val` found for struct `TypeId` in the current scope\n    --> serde/src/private/ser.rs:1377:67\n     |\n1377 |     assert!(std::any::TypeId::of::<&[i32]>() == std::any::TypeId::of_val(result));\n     |                                                                   ^^^^^^ function or associated item not found in `TypeId`\n     |\nnote: if you're trying to build a new `TypeId`, consider using `TypeId::of` which returns `TypeId`\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/core/src/any.rs:640:5\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let value = &[4, 5, 6];",
                "    constrain(value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value = &[4, 5, 6];",
                  "    let result = constrain(value);",
                  "    assert_eq!(result, value);"
                ],
                [
                  "    let value = &[4, 5, 6];",
                  "    let result = constrain(value);",
                  "    assert!(std::ptr::eq(result, value));"
                ],
                [
                  "    let value = &[4, 5, 6];",
                  "    let result = constrain(value);",
                  "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(value));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let value = &[4, 5, 6];",
                  "    constrain(value);",
                  "    let value = &[4, 5, 6];",
                  "    let result = constrain(value);",
                  "    assert_eq!(result, value);",
                  "}"
                ],
                [
                  "{",
                  "    let value = &[4, 5, 6];",
                  "    constrain(value);",
                  "    let value = &[4, 5, 6];",
                  "    let result = constrain(value);",
                  "    assert!(std::ptr::eq(result, value));",
                  "}"
                ],
                [
                  "{",
                  "    let value = &[4, 5, 6];",
                  "    constrain(value);",
                  "    let value = &[4, 5, 6];",
                  "    let result = constrain(value);",
                  "    assert!(std::mem::size_of_val(result) == std::mem::size_of_val(value));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    trait MyTrait {}",
                "    struct MyStruct;",
                "    impl MyTrait for MyStruct {}",
                "    let value: &dyn MyTrait = &MyStruct;",
                "    constrain(value);",
                "}"
              ],
              "oracles": [
                [
                  "    let value: &dyn MyTrait = &MyStruct;",
                  "    assert_eq!(std::any::type_name_of_val(value), \"MyStruct\");"
                ],
                [
                  "    let value: &dyn MyTrait = &MyStruct;",
                  "    assert_eq!(constrain(value), value);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    trait MyTrait {}",
                  "    struct MyStruct;",
                  "    impl MyTrait for MyStruct {}",
                  "    let value: &dyn MyTrait = &MyStruct;",
                  "    constrain(value);",
                  "    let value: &dyn MyTrait = &MyStruct;",
                  "    assert_eq!(std::any::type_name_of_val(value), \"MyStruct\");",
                  "}"
                ],
                [
                  "{",
                  "    trait MyTrait {}",
                  "    struct MyStruct;",
                  "    impl MyTrait for MyStruct {}",
                  "    let value: &dyn MyTrait = &MyStruct;",
                  "    constrain(value);",
                  "    let value: &dyn MyTrait = &MyStruct;",
                  "    assert_eq!(constrain(value), value);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `&dyn MyTrait`\n    --> serde/src/private/ser.rs:1379:5\n     |\n1379 |     assert_eq!(constrain(value), value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     &dyn MyTrait\n     |     &dyn MyTrait\n     |\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: `dyn MyTrait` doesn't implement `std::fmt::Debug`\n    --> serde/src/private/ser.rs:1379:5\n     |\n1379 |     assert_eq!(constrain(value), value);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `dyn MyTrait` cannot be formatted using `{:?}` because it doesn't implement `std::fmt::Debug`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `dyn MyTrait`, which is required by `&dyn MyTrait: std::fmt::Debug`\n     = help: the following other types implement trait `std::fmt::Debug`:\n               (dyn Any + 'static)\n               (dyn Any + Send + 'static)\n               (dyn Any + Send + Sync + 'static)\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}