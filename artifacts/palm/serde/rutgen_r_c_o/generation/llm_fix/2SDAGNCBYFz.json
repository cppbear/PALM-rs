{
  "name": "serde::de::value::private::unit_only",
  "name_with_impl": "serde::de::value::private::unit_only",
  "mod_info": {
    "name": "de::value::private",
    "loc": "serde/src/de/value.rs:1730:1:1894:2"
  },
  "visible": true,
  "loc": "serde/src/de/value.rs:1741:5:1748:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// expected return value/type: (\n            t,\n            UnitOnly {\n                marker: PhantomData,\n            },\n        )\n"
      ],
      "input_infer": "test input ranges: (any type T, any type E)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: i32 = 42;",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: i32 = 42;",
                  "    let expected_output = (42, UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: i32 = 42;",
                  "    let output = unit_only(input);",
                  "    let input: i32 = 42;",
                  "    let expected_output = (42, UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `(i32, private::UnitOnly<_>)`\n    --> serde/src/de/value.rs:1909:5\n     |\n1909 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     (i32, private::UnitOnly<_>)\n     |     (i32, private::UnitOnly<_>)\n     |\nnote: an implementation of `PartialEq` might be missing for `private::UnitOnly<_>`\n    --> serde/src/de/value.rs:1737:5\n     |\n1737 |     pub struct UnitOnly<E> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(PartialEq)]`\n     |\n1737 +     #[derive(PartialEq)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nerror[E0277]: `private::UnitOnly<_>` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1909:5\n     |\n1909 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `private::UnitOnly<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `private::UnitOnly<_>`, which is required by `(i32, private::UnitOnly<_>): std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `private::UnitOnly<_>` or manually `impl std::fmt::Debug for private::UnitOnly<_>`\n     = help: the following other types implement trait `std::fmt::Debug`:\n               ()\n               (A, Z, Y, X, W, V, U, T)\n               (B, A, Z, Y, X, W, V, U, T)\n               (C, B, A, Z, Y, X, W, V, U, T)\n               (D, C, B, A, Z, Y, X, W, V, U, T)\n               (E, D, C, B, A, Z, Y, X, W, V, U, T)\n               (T,)\n               (U, T)\n             and 5 others\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(Debug)]`\n     |\n1737 +     #[derive(Debug)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: &str = \"test\";",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: &str = \"test\";",
                  "    let expected_output = (input, UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: &str = \"test\";",
                  "    let output = unit_only(input);",
                  "    let input: &str = \"test\";",
                  "    let expected_output = (input, UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `(&str, private::UnitOnly<_>)`\n    --> serde/src/de/value.rs:1909:5\n     |\n1909 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     (&str, private::UnitOnly<_>)\n     |     (&str, private::UnitOnly<_>)\n     |\nnote: an implementation of `PartialEq` might be missing for `private::UnitOnly<_>`\n    --> serde/src/de/value.rs:1737:5\n     |\n1737 |     pub struct UnitOnly<E> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(PartialEq)]`\n     |\n1737 +     #[derive(PartialEq)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nerror[E0277]: `private::UnitOnly<_>` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1909:5\n     |\n1909 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `private::UnitOnly<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `private::UnitOnly<_>`, which is required by `(&str, private::UnitOnly<_>): std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `private::UnitOnly<_>` or manually `impl std::fmt::Debug for private::UnitOnly<_>`\n     = help: the following other types implement trait `std::fmt::Debug`:\n               ()\n               (A, Z, Y, X, W, V, U, T)\n               (B, A, Z, Y, X, W, V, U, T)\n               (C, B, A, Z, Y, X, W, V, U, T)\n               (D, C, B, A, Z, Y, X, W, V, U, T)\n               (E, D, C, B, A, Z, Y, X, W, V, U, T)\n               (T,)\n               (U, T)\n             and 5 others\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(Debug)]`\n     |\n1737 +     #[derive(Debug)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: f64 = 3.14;",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_first: f64 = 3.14;",
                  "    let expected_second = UnitOnly { marker: PhantomData };",
                  "    assert_eq!(output.0, expected_first);"
                ],
                [
                  "    let expected_first: f64 = 3.14;",
                  "    let expected_second = UnitOnly { marker: PhantomData };",
                  "    assert_eq!(output.1.marker, expected_second.marker);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: f64 = 3.14;",
                  "    let output = unit_only(input);",
                  "    let expected_first: f64 = 3.14;",
                  "    let expected_second = UnitOnly { marker: PhantomData };",
                  "    assert_eq!(output.0, expected_first);",
                  "}"
                ],
                [
                  "{",
                  "    let input: f64 = 3.14;",
                  "    let output = unit_only(input);",
                  "    let expected_first: f64 = 3.14;",
                  "    let expected_second = UnitOnly { marker: PhantomData };",
                  "    assert_eq!(output.1.marker, expected_second.marker);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0282]: type annotations needed\n    --> serde/src/de/value.rs:1906:18\n     |\n1906 |     let output = unit_only(input);\n     |                  ^^^^^^^^^ cannot infer type of the type parameter `E` declared on the function `unit_only`\n     |\nhelp: consider specifying the generic arguments\n     |\n1906 |     let output = unit_only::<f64, E>(input);\n     |                           ++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0282]: type annotations needed\n    --> serde/src/de/value.rs:1906:18\n     |\n1906 |     let output = unit_only(input);\n     |                  ^^^^^^^^^ cannot infer type of the type parameter `E` declared on the function `unit_only`\n     |\nhelp: consider specifying the generic arguments\n     |\n1906 |     let output = unit_only::<f64, E>(input);\n     |                           ++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: Vec<i32> = vec![1, 2, 3];",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output.0, expected_output.0);"
                ],
                [
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output.1.marker, expected_output.1.marker);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: Vec<i32> = vec![1, 2, 3];",
                  "    let output = unit_only(input);",
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output.0, expected_output.0);",
                  "}"
                ],
                [
                  "{",
                  "    let input: Vec<i32> = vec![1, 2, 3];",
                  "    let output = unit_only(input);",
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output.1.marker, expected_output.1.marker);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0282]: type annotations needed\n    --> serde/src/de/value.rs:1906:18\n     |\n1906 |     let output = unit_only(input);\n     |                  ^^^^^^^^^ cannot infer type of the type parameter `E` declared on the function `unit_only`\n     |\nhelp: consider specifying the generic arguments\n     |\n1906 |     let output = unit_only::<std::vec::Vec<i32>, E>(input);\n     |                           +++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0282]: type annotations needed\n    --> serde/src/de/value.rs:1907:62\n     |\n1906 |     let output = unit_only(input);\n     |                  ---------------- type must be known at this point\n1907 |     let expected_output = (input.clone(), UnitOnly { marker: PhantomData });\n     |                                                              ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n     |\nhelp: consider specifying the generic argument\n     |\n1907 |     let expected_output = (input.clone(), UnitOnly { marker: PhantomData::<T> });\n     |                                                                         +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: bool = true;",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = (true, UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: bool = true;",
                  "    let output = unit_only(input);",
                  "    let expected_output = (true, UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `(bool, private::UnitOnly<_>)`\n    --> serde/src/de/value.rs:1908:5\n     |\n1908 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     (bool, private::UnitOnly<_>)\n     |     (bool, private::UnitOnly<_>)\n     |\nnote: an implementation of `PartialEq` might be missing for `private::UnitOnly<_>`\n    --> serde/src/de/value.rs:1737:5\n     |\n1737 |     pub struct UnitOnly<E> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(PartialEq)]`\n     |\n1737 +     #[derive(PartialEq)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nerror[E0277]: `private::UnitOnly<_>` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1908:5\n     |\n1908 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `private::UnitOnly<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `private::UnitOnly<_>`, which is required by `(bool, private::UnitOnly<_>): std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `private::UnitOnly<_>` or manually `impl std::fmt::Debug for private::UnitOnly<_>`\n     = help: the following other types implement trait `std::fmt::Debug`:\n               ()\n               (A, Z, Y, X, W, V, U, T)\n               (B, A, Z, Y, X, W, V, U, T)\n               (C, B, A, Z, Y, X, W, V, U, T)\n               (D, C, B, A, Z, Y, X, W, V, U, T)\n               (E, D, C, B, A, Z, Y, X, W, V, U, T)\n               (T,)\n               (U, T)\n             and 5 others\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(Debug)]`\n     |\n1737 +     #[derive(Debug)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: (i32, &str) = (1, \"tuple\");",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = ((1, \"tuple\"), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: (i32, &str) = (1, \"tuple\");",
                  "    let output = unit_only(input);",
                  "    let expected_output = ((1, \"tuple\"), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `((i32, &str), private::UnitOnly<_>)`\n    --> serde/src/de/value.rs:1908:5\n     |\n1908 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     ((i32, &str), private::UnitOnly<_>)\n     |     ((i32, &str), private::UnitOnly<_>)\n     |\nnote: an implementation of `PartialEq` might be missing for `private::UnitOnly<_>`\n    --> serde/src/de/value.rs:1737:5\n     |\n1737 |     pub struct UnitOnly<E> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(PartialEq)]`\n     |\n1737 +     #[derive(PartialEq)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nerror[E0277]: `private::UnitOnly<_>` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1908:5\n     |\n1908 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `private::UnitOnly<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `private::UnitOnly<_>`, which is required by `((i32, &str), private::UnitOnly<_>): std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `private::UnitOnly<_>` or manually `impl std::fmt::Debug for private::UnitOnly<_>`\n     = help: the following other types implement trait `std::fmt::Debug`:\n               ()\n               (A, Z, Y, X, W, V, U, T)\n               (B, A, Z, Y, X, W, V, U, T)\n               (C, B, A, Z, Y, X, W, V, U, T)\n               (D, C, B, A, Z, Y, X, W, V, U, T)\n               (E, D, C, B, A, Z, Y, X, W, V, U, T)\n               (T,)\n               (U, T)\n             and 5 others\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(Debug)]`\n     |\n1737 +     #[derive(Debug)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: () = ();",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let expected_output = ((), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: () = ();",
                  "    let output = unit_only(input);",
                  "    let expected_output = ((), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output, expected_output);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0369]: binary operation `==` cannot be applied to type `((), private::UnitOnly<_>)`\n    --> serde/src/de/value.rs:1908:5\n     |\n1908 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     ((), private::UnitOnly<_>)\n     |     ((), private::UnitOnly<_>)\n     |\nnote: an implementation of `PartialEq` might be missing for `private::UnitOnly<_>`\n    --> serde/src/de/value.rs:1737:5\n     |\n1737 |     pub struct UnitOnly<E> {\n     |     ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(PartialEq)]`\n     |\n1737 +     #[derive(PartialEq)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nerror[E0277]: `private::UnitOnly<_>` doesn't implement `std::fmt::Debug`\n    --> serde/src/de/value.rs:1908:5\n     |\n1908 |     assert_eq!(output, expected_output);\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `private::UnitOnly<_>` cannot be formatted using `{:?}`\n     |\n     = help: the trait `std::fmt::Debug` is not implemented for `private::UnitOnly<_>`, which is required by `((), private::UnitOnly<_>): std::fmt::Debug`\n     = note: add `#[derive(Debug)]` to `private::UnitOnly<_>` or manually `impl std::fmt::Debug for private::UnitOnly<_>`\n     = help: the following other types implement trait `std::fmt::Debug`:\n               ()\n               (A, Z, Y, X, W, V, U, T)\n               (B, A, Z, Y, X, W, V, U, T)\n               (C, B, A, Z, Y, X, W, V, U, T)\n               (D, C, B, A, Z, Y, X, W, V, U, T)\n               (E, D, C, B, A, Z, Y, X, W, V, U, T)\n               (T,)\n               (U, T)\n             and 5 others\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `private::UnitOnly<_>` with `#[derive(Debug)]`\n     |\n1737 +     #[derive(Debug)]\n1738 |     pub struct UnitOnly<E> {\n     |\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information about an error, try `rustc --explain E0277`.\nerror: could not compile `serde` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let input: Vec<i32> = vec![];",
                "    let output = unit_only(input);",
                "}"
              ],
              "oracles": [
                [
                  "    let input: Vec<i32> = vec![];",
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output.0, expected_output.0);"
                ],
                [
                  "    let input: Vec<i32> = vec![];",
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert!(std::mem::discriminant(&output.1) == std::mem::discriminant(&expected_output.1));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let input: Vec<i32> = vec![];",
                  "    let output = unit_only(input);",
                  "    let input: Vec<i32> = vec![];",
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert_eq!(output.0, expected_output.0);",
                  "}"
                ],
                [
                  "{",
                  "    let input: Vec<i32> = vec![];",
                  "    let output = unit_only(input);",
                  "    let input: Vec<i32> = vec![];",
                  "    let expected_output = (input.clone(), UnitOnly { marker: PhantomData });",
                  "    assert!(std::mem::discriminant(&output.1) == std::mem::discriminant(&expected_output.1));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0282]: type annotations needed\n    --> serde/src/de/value.rs:1906:18\n     |\n1906 |     let output = unit_only(input);\n     |                  ^^^^^^^^^ cannot infer type of the type parameter `E` declared on the function `unit_only`\n     |\nhelp: consider specifying the generic arguments\n     |\n1906 |     let output = unit_only::<std::vec::Vec<i32>, E>(input);\n     |                           +++++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "   Compiling serde v1.0.219 (/home/utgen/workspace/serde/serde)\nerror[E0282]: type annotations needed\n    --> serde/src/de/value.rs:1908:62\n     |\n1906 |     let output = unit_only(input);\n     |                  ---------------- type must be known at this point\n1907 |     let input: Vec<i32> = vec![];\n1908 |     let expected_output = (input.clone(), UnitOnly { marker: PhantomData });\n     |                                                              ^^^^^^^^^^^ cannot infer type of the type parameter `T` declared on the struct `PhantomData`\n     |\nhelp: consider specifying the generic argument\n     |\n1908 |     let expected_output = (input.clone(), UnitOnly { marker: PhantomData::<T> });\n     |                                                                         +++++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `serde` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    }
  ]
}